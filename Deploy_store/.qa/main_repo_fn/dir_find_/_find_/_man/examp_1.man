# https://zalinux.ru/?p=1330#9

## Ищет файлы по имени core в или ниже директории /tmp и удаляет их.
 Обратите внимание, что это будет работать неправильно, если имеются имена файлов, содержащие символы новой строки, одинарные или двойные кавычки, или пробелы:

    find /tmp -name core -type f -print | xargs /bin/rm -f
## Ищет файлы по имени core в или ниже директории /tmp и удаляет их, работая с именами файлов так, что корректно обрабатываются имена файлов
 или директорий содержащих единичные или двойные кавычки, пробелы или символ новой строки. Тест -name ставится перед тестом -type, чтобы избежать необходимости вызывать stat(2) для каждого файла:

    find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
## Запускает file на каждый файл в или ниже текущей директории.
 Обратите внимание, что фигурные скобки заключены в единичные кавычки для защиты их от интерпретации как скриптовой пунктуации оболочки. Точка с запятой похожим образом защищена использованием обратного слеша, хотя в этой ситуации также можно было бы использовать одинарные кавычки:

    find . -type f -exec file '{}' \;
## Обойти файловую систему только один раз, вывести файлы и директории с setuid в /root/suid.txt и большие файлы в /root/big.txt.
 Данный запуск требует привилегий суперпользователя:

    sudo find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)
## Поиск файлов в вашей домашней директории, которые были изменены за последние двадцать четыре часа.
 Эта команда работает так поскольку время с момента последней модификации каждого файла делится на 24 часа, а остаток отбрасывается. Это означает, чтобы соответствовать -mtime 0 файл должен быть изменён в прошлом, которое произошло менее 24 часов назад.

    find $HOME -mtime 0
## Поиск файлов, которые являются выполнимыми, но не читаемыми:

    find /sbin /usr/sbin -executable \! -readable -print
## Поиск файлов, которые имеют разрешения на чтение и запись для их владельца и группы, но которые другие пользователи могут читать, но не записывать в них.
 Файл, который соответствует этим критериям, но имеет другой набор битов разрешений (например, если кто-нибудь может выполнять файл) не будет соответствовать:

    find . -perm 664
## Поиск файлов, которые имеют разрешения на чтение и запись их владельцем и группой, и которые другие пользователи могут читать, без учёта наличия любых других дополнительных битов разрешений
 (например, бита исполнимости). Этот пример будет соответствовать файлу, например, с режимом 0777.

    find . -perm -664
## Поиск файлов, в которые кто-либо может записывать 
(их владелец, или их группа, или кто-нибудь другой):

    find . -perm /222
## Все эти три команды делают то же самое, но первая использует восьмеричное представление прав доступа, а другие две используют символическую форму.
 Все эти команды ищут файлы, которые доступные для записи либо их владельцу, либо их группе. Эти файлы не обязаны быть доступны для записи одновременно для владельца и для группы, одного из вариантов достаточно:

    find . -perm /220
    find . -perm /u+w,g+w
    find . -perm /u=w,g=w
## Обе эти команды делают то же самое; поиск файлов, которые доступны для записи и их владельцу, и их группе:

    find . -perm -220
    find . -perm -g+w,u+w
# Обе эти две команды ищут файлы, которые доступны для чтения каждому (-perm -444 или -perm -a+r), имеют по крайней мере один установленный бит записи (-perm /222 или -perm /a+w), но ни для кого не являются исполнимым (соответственно, ! -perm /111 и ! -perm /a+x):

    find . -perm -444 -perm /222 ! -perm /111
    find . -perm -a+r -perm /a+w ! -perm /a+x
## Эта команда копирует содержимое /source-dir в /dest-dir, но пропускает файлы и директории с именем .snapshot (и всё внутри них). Она также пропускает файлы или директории, чьё имя заканчивается на ~, но не их содержимое.
 Конструкция -prune -o \( … -print0 \) является весьма популярной. Идея здесь в том, что выражение перед -prune соответствует тому, что должно быть обрезано. Тем не менее, само действие -prune возвращает true, поэтому последующее -o гарантирует, что файлы с правой стороны оцениваются только для тех директорий, которые не были обрезаны (содержимое обрезанных директорий даже не посещается, поэтому их содержимое является неподходящим). Выражение на правой стороне от -o заключено в круглые скобки только для ясности. Оно выражает, что действие -print0 имеет место только для вещей, к которым не было применено -prune. Поскольку условие по умолчанию И между тестами связывает более крепко, чем -o, всё равно так было бы по умолчанию, но круглые скобки помогают яснее показать, что происходит:

    cd /source-dir
    find . -name .snapshot -prune -o \( \! -name *~ -print0 \) | cpio -pmd0 /dest-dir
## Дана следующая директория проектов и ассоциированных с ними административных директорий SCM, выполнить эффективный поиск корней проекта:

    repo/project1/CVS
    repo/gnu/project2/.svn
    repo/gnu/project3/.svn
    repo/gnu/project3/src/.svn
    repo/project4/.git
В этом примере -prune предотвращает ненужное спускание в директории, которые уже были изучены (например, мы не ищем по project3/src, поскольку мы уже нашли project3/.svn), но гарантирует быть найденным родственным директориям (project2 и project3):

    find repo/ -exec test -d {}/.svn \; -or -exec test -d {}/.git \; -or -exec test -d {}/CVS \; -print -prune
