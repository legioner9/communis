# https://zalinux.ru/?p=2745

## Поиск файлов по имени в текущей директории {find <dir> -name}
Найти все файлы, чьё имя zalinux.txt в текущей рабочей директории:

    find . -name zalinux.txt
    ./zalinux.txt

## Поиск файлов по имени без учёта регистра {find <dir> -name -iname}

    find /home -iname zalinux.txt
    /home/mial/zalinux.txt
    /home/mial/Zalinux.txt

## Найти директории по имени {find <dir> -type d -name <regexp>}

    find / -type d -name Zalinux

## Найти все PHP файлы в директории {find . -type f -name "*.php"}

## Найти все файлы с правами доступа 777 {find . -type f -perm 0777 -print}

## Найти все файлы без! прав доступа 777 {find / -type f ! -perm 777}

## Поиск SGID файлов с доступом 644 {find / -perm 2644}

## Поиск файлов со Sticky Bit с правами доступа 551 {find / -perm 1551}

## Найти все файлы с установленным SUID. {find / -perm /u=s}

## Найти все файлы у которых установлен SGID {find / -perm /g=s}

## Найти все файлы, к которым есть права на чтение {find / -perm /u=r}

## Найти все файлы, к которым есть права на запись {find / -perm /u=w}

## Поиск файлов на которые есть права на запись у кого угодно (without symb) {find /etc/ -type f -perm -a+w}

## {find -L /tmp -type f -perm -a+r 2>/dev/null}

Следующая команда найдёт в папке /tmp все файлы на которые у кого угодно есть права чтения, при встрече символических ссылок она будет переходить по ним, в случае возникновения проблем с доступом, сообщения об ошибках выводиться не будут

## Найти все исполнимые файлы {find <dir> -perm /a=x}

## Найти все файлы с разрешениями равным 777 и использовать команду chmod для установки разрешений на 644 {find / -type f -perm 0777 -print -exec chmod 644 {} \;}

## Поиск и удаление нескольких файлов {find . -type f -name "*.txt" -exec rm -f {} \;}

## Поиск всех пустых файлов {find /tmp -type f -empty}

## Поиск всех пустых директорий {find /tmp -type f -name ".*"}

## Найти файл на основе имени пользователя {find / -user root -name hackware.txt}

## Найти все файлы принадлежащие пользователю {find /home -user st}

## Найти все файлы принадлежащие группе {find /home -group developer}

## Найти определённые файлы, принадлежащие пользователю {find /home -user mial -iname "*.txt"}

## Чтобы найти все файлы, которые были изменены ровно 50 дней назад {find / -mtime 50}

## Чтобы найти все файлы, к которым был получен доступ ровно 50 дней назад {find / -atime 50}

## были модифицированы более 50 дней назад и менее 100 дней назад: {find / -mtime +50 -mtime -100}

## (права доступа, владелец, группа) были изменены за последний час {find / -cmin -60}

## доступ к которым был сделан за последний час {find / -amin -60}

## найти все файлы размером ровно 50MB используйте {find / -size 50M}

## найти все файлы, чем размер более 50MB и менее 100MB {find / -size +50M -size -100M}

## Поиск и удаление файлов определённого размера {find / -size +100M -exec rm -rf {} \;}

## найти все .mp3 файла размером более чем 10MB и удалить их в одну команду {find / -type f -name *.mp3 -size +10M -exec rm {} \;}

## найти все файлы в текущей директории с файловыми расширениями .sh и .txt, {find . -type f \( -name "*.sh" -o -name "*.txt" \)}

### Объяснение предыдущей команды:

Объяснение предыдущей команды:

. (точка) означает текущую директорию
-type используется для указания типа файла, мы ищем обычные файлы, которые здесь обозначаются буквой f
-name используется для указания шаблона поиска. В данном случае указаны расширения файлов
-o означает «ИЛИ»
скобки () используются для установки приоритета логических операций
В результате получается следующее:

нужно найти файлы И (имя у них "*.sh" ИЛИ имя "*.txt")
Если бы скобки не использовались, то по правилам приоритета логических операций получилось бы следующее:

(нужно найти файлы И имя у них "*.sh") ИЛИ имя "*.txt"
Файловые расширения, поскольку они содержат символы с особым значением для оболочки, нужно поместить в кавычки. По этой же причине нужно экранировать скобки с помощью обратного слэша (\). 

## Для поиска по трём файловым расширениям .sh, .txt and .c {find . -type f \( -name "*.sh" -o -name "*.txt" -o -name "*.c" \)}




