#!/bin/bash

   COMMAND_OUTPUT >
      # Перенаправление stdout (вывода) в файл.
      # Если файл отсутствовал, то он создется, иначе -- перезаписывается.

      ls -lR > dir-tree.list
      # Создает файл, содержащий список дерева каталогов.

   : > filename
      # Операция > усекает файл "filename" до нулевой длины.
      # Если до выполнения операции файла не существовало,
      # то создается новый файл с нулевой длиной (тот же эффект дает команда 'touch').
      # Символ : выступает здесь в роли местозаполнителя, не выводя ничего.

   > filename
      # Операция > усекает файл "filename" до нулевой длины.
      # Если до выполнения операции файла не существовало,
      # то создается новый файл с нулевой длиной (тот же эффект дает команда 'touch').
      # (тот же результат, что и выше -- ": >", но этот вариант неработоспособен
      # в некоторых командных оболочках.)

   COMMAND_OUTPUT >>
      # Перенаправление stdout (вывода) в файл.
      # Создает новый файл, если он отсутствовал, иначе -- дописывает в конец файла.


      # Однострочные команды перенаправления
      # (затрагивают только ту строку, в которой они встречаются):
      # --------------------------------------------------------------------

   1>filename
      # Перенаправление вывода (stdout) в файл "filename".
   1>>filename
      # Перенаправление вывода (stdout) в файл "filename", файл открывается в режиме добавления.
   2>filename
      # Перенаправление stderr в файл "filename".
   2>>filename
      # Перенаправление stderr в файл "filename", файл открывается в режиме добавления.
   &>filename
      # Перенаправление stdout и stderr в файл "filename".

      #==============================================================================
      # Перенаправление stdout, только для одной строки.
      LOGFILE=script.log

      echo "Эта строка будет записана в файл \"$LOGFILE\"." 1>$LOGFILE
      echo "Эта строка будет добавлена в конец файла \"$LOGFILE\"." 1>>$LOGFILE
      echo "Эта строка тоже будет добавлена в конец файла \"$LOGFILE\"." 1>>$LOGFILE
      echo "Эта строка будет выведена на экран и не попадет в файл \"$LOGFILE\"."
      # После каждой строки, сделанное перенаправление автоматически "сбрасывается".



      # Перенаправление stderr, только для одной строки.
      ERRORFILE=script.errors

      bad_command1 2>$ERRORFILE       #  Сообщение об ошибке запишется в $ERRORFILE.
      bad_command2 2>>$ERRORFILE      #  Сообщение об ошибке добавится в конец $ERRORFILE.
      bad_command3                    #  Сообщение об ошибке будет выведено на stderr,
                                      #+ и не попадет в $ERRORFILE.
      # После каждой строки, сделанное перенаправление также автоматически "сбрасывается".
      #==============================================================================



   2>&1
      # Перенаправляется stderr на stdout.
      # Сообщения об ошибках передаются туда же, куда и стандартный вывод.

   i>&j
      # Перенаправляется файл с дескриптором i в j.
      # Вывод в файл с дескриптором i передается в файл с дескриптором j.

   >&j
      # Перенаправляется  файл с дескриптором 1 (stdout) в файл с дескриптором j.
      # Вывод на stdout передается в файл с дескриптором j.

   0< FILENAME
    < FILENAME
      # Ввод из файла.
      # Парная команде ">", часто встречается в комбинации с ней.
      #
      # grep search-word <filename


   [j]<>filename
      # Файл "filename" открывается на чтение и запись, и связывается с дескриптором "j".
      # Если "filename" отсутствует, то он создается.
      # Если дескриптор "j" не указан, то, по-умолчанию, бередся дескриптор 0, stdin.
      #
      # Как одно из применений этого -- запись в конкретную позицию в файле.
      echo 1234567890 > File    # Записать строку в файл "File".
      exec 3<> File       # Открыть "File" и связать с дескриптором 3.
      read -n 4 <&3             # Прочитать 4 символа.
      echo -n . >&3             # Записать символ точки.
      exec 3>&-                 # Закрыть дескриптор 3.
      cat File                  # ==> 1234.67890
      # Произвольный доступ, да и только!



   |
      # Конвейер (канал).
      # Универсальное средство для объединения команд в одну цепочку.
      # Похоже на ">", но на самом деле -- более обширная.
      # Используется для объединения команд, сценариев, файлов и программ в одну цепочку (конвейер).
      cat *.txt | sort | uniq > result-file
      # Содержимое всех файлов .txt сортируется, удаляются повторяющиеся строки,
      # результат сохраняется в файле "result-file".
