
<!-- saved from url=(0049)https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=KOI8-R">

  <meta name="generator" content="HTML Tidy for Linux/x86 (vers 1st October 2003), see www.w3.org">
        

  <title>Разработка графического интерфейса с помощью библиотеки
  Qt3</title>
  <meta name="GENERATOR" content="Modular DocBook HTML Stylesheet Version 1.7">
</head>

<body bgcolor="#DDE1C2">
<link rel="stylesheet" href="./Разработка графического интерфейса с помощью библиотеки Qt3_files/opennet4.css" type="text/css">
<!--htdig_noindex-->
<form method="get" action="https://www.opennet.ru/search.shtml">
<aside>
<div style="width: 100%; text-align: right; font-size: 70%; background: #E9EAD6; margin-bottom:-10px;">
Профиль: <b><a href="https://www.opennet.ru/~" rel="nofollow" title="/~ - сводная страница участника"><u>Аноним</u></a></b> (<a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=login">вход</a> | <a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=user_register">регистрация</a>)

</div>

<table border="0" cellspacing="0" cellpadding="0" width="100%">
<tbody><tr>
<td width="300" valign="BOTTOM" bgcolor="#E9EAD6" style="background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left">
<a href="https://www.opennet.ru/"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/opennet2.gif" height="60" width="249" alt="The OpenNET Project" border="0"></a><br>
</td>
<td width="100" align="CENTER" bgcolor="#E9EAD6" style="background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left">

</td><td width="50%" align="CENTER" bgcolor="#E9EAD6" style="background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left;padding-bottom:10px;">
<table width="100%" border="0">
<tbody><tr>
<td width="22%">
 <a href="https://www.opennet.ru/opennews/" class="h"><b>НОВОСТИ</b></a> (<a href="https://www.opennet.ru/news/opennet.shtml" class="h">+</a>)
</td><td width="18%%">
  <a href="https://www.opennet.ru/mp/" class="h"><b>КОНТЕНТ</b></a>
</td><td width="14%">
  <a href="http://wiki.opennet.ru/" class="h"><b>WIKI</b></a>
</td><td width="14%">
   <a href="https://www.opennet.ru/man.shtml" class="h"><b>MAN'ы</b></a>
</td><td width="16%">
   <a href="https://www.opennet.ru/forum/" class="h"><b>ФОРУМ</b></a>
</td><td width="16%">
<a href="https://www.opennet.ru/search.shtml" class="h" onmouseover="document.getElementById(&#39;form12&#39;).style.display=&#39;block&#39;;">Поиск</a>&nbsp;(<a href="https://www.opennet.ru/keywords/" class="h">теги</a>)
<input id="form12" style="display: none;" type="text" size="10" name="words" value="" title="для поиска в google наберите &quot;g фраза&quot;">
</td></tr>
</tbody></table>

</td><td align="right" width="20%" bgcolor="#E9EAD6" style="background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left;padding-bottom:5px;">

<a href="https://www.opennet.ru/opennews/opennews_all_utf.rss"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/rss.png" height="16" width="16" alt="RSS" title="RSS" border="0"></a>&nbsp;<a href="https://twitter.com/opennetru"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/twitter.png" height="16" width="16" alt="twitter" title="Twitter" border="0"></a>&nbsp;<a href="https://vk.com/opennet"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/vkontakte.gif" height="16" width="16" title="ВКонтакте" border="0"></a>&nbsp;<a href="https://zen.yandex.ru/opennet"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/zen.gif" height="16" width="16" title="Yandex Zen" border="0"></a>&nbsp;<a href="https://www.facebook.com/OpenNet.News/"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/facebook.gif" height="16" width="16" title="Facebook" border="0"></a>&nbsp;<a href="https://telegram.space/opennet_ru"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/telegram2.png" height="16" width="16" title="Telegram" border="0"></a>
</td></tr></tbody></table>
</aside>

<style>
    .hdr_mobile {
	text-align: center; 
	display: none;
	margin: 0px;
	padding: 0px;
    }
</style>
<div class="hdr_mobile">
<div style="margin-left: auto; margin-right: auto; width: 100%; height: 70px; border:1px solid #b0b190; min-width: 360px; max-width: 600px; background: #E9EAD6 url(&#39;/back.gif&#39;) repeat-x bottom left;">
<div style="float:left; width: 249px; height: 60px; margin-top: 10px;">
<a href="https://www.opennet.ru/"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/opennet2_lite.gif" style="height: 60px; width: 249px; border: 1px;" alt="The OpenNET Project / Index page"></a>
</div>
<div style="float: left; text-align: center; height: 70px; width: 331px; padding: 5px; margin-left: 10px;">
<br><small>[ <a href="https://www.opennet.ru/opennews/">новости</a>&nbsp;/<a href="https://www.opennet.ru/opennews/?full_lines=15&amp;lines=15&amp;mid_lines=00">+++</a> | <a href="https://www.opennet.ru/forum/">форум</a> | <a href="http://wiki.opennet.ru/">wiki</a> | <a href="https://www.opennet.ru/keywords/">теги</a>
| <a href="tg://resolve?domain=opennet_ru"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/telegram2.png" height="16" width="16" title="Telegram" border="0" style="margin-bottom: -4px;"></a>
]</small>
</div>
</div>
</div>
<div style="clear: both;"></div>


<div style="float: left; width: 279; text-align: left;padding-right: 60px;" id="adv">
</div>
<div style="padding-top: 0px;position:absolute;left:50%;margin-left:-235px;width:470px;" id="adv2">
</div>
<div style="width: 279;float: right;" id="adv3">
</div>
<div style="clear: both;"></div>
<br>
</form>
<!--/htdig_noindex-->


<table border="0" cellspacing="0" cellpadding="0" width="100%" style="margin-bottom: 5px;margin-top: 5px;">
<tbody><tr><td>
<table border="0" cellspacing="0" cellpadding="4" bgcolor="#E9EAD6" width="100%">
<tbody><tr bgcolor="#C7CBB1"><td><font color="#000090">
<b><a href="https://www.opennet.ru/docs/">Каталог документации</a> / 
<a href="https://www.opennet.ru/docs/124.shtml">Раздел "Программирование, языки"</a> /
<a href="https://www.opennet.ru/docs/RUS/qt3_prog/">Оглавление документа</a>
</b>
</font></td></tr>
</tbody></table>
</td></tr>
<tr bgcolor="#B0B190"><td><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/p.gif" height="3" width="1" alt=""></td></tr>
</tbody></table>


  <div class="BOOK">
    <a name="QT3"></a>

    <div class="TITLEPAGE">
      <h1 class="TITLE"><a name="AEN2"></a>Разработка графического
      интерфейса с помощью библиотеки Qt3</h1>

      <h3 class="AUTHOR"><a name="AEN4"></a>Авторы: Jasmin Blanchette,
      Mark Summerfield</h3>

      <h3 class="AUTHOR"><a name="AEN6"></a>Перевод: Андрей Киселёв
      (kis_an [at] mail.ru)</h3>

      <div class="LEGALNOTICE">
        <a name="AEN9"></a>

        <p>Оригинальная версия была опубликована издательством
        "Prentice Hall PTR". Вы сможете найти ее по адресу:
        <a href="http://www.phptr.com/conteimages/0131240722/downloads/blanchette_book.pdf" target="_top">http://www.phptr.com/conteimages/0131240722/downloads/blanchette_book.pdf</a>
           .</p>

        <p>Данная книга распространяется на условиях Open Publication
        License, v1.0 или более поздней. Полный текст лицензии вы
        найдете по адресу: <a href="http://www.opencontent.org/openpub/" target="_top">http://www.opencontent.org/openpub/</a>.</p>

        <ul>
          <li>
            <p>"Trolltech" и "Qt" --
            зарегистрированные торговые марки компании Trolltech.</p>
          </li>

          <li>
            <p>OpenGL -- торговая марка Silicon Graphics, Inc.</p>
          </li>

          <li>
            <p>Все остальные имена компаний и названия программных
            продуктов, упомянутые здесь, являются торговыми марками их
            соответствующих владельцев.</p>
          </li>
        </ul><br>
        <br>

        <p>Авторы, держатели авторских прав и издатель приложили немало
        усилий при подготовке этой книги, но не предоставляют никаких
        явных или подразумеваемых гарантий любого вида и не принимают
        на себя ответственность за возможные ошибки или упущения.
        Сведения, приводимые в этой книге, носят исключительно
        информационный характер и могут быть изменены без
        дополнительного уведомления. Ни авторы, ни издатель, ни
        держатели авторских прав не несут никакой ответственности за
        непредвиденные убытки, прямо или косвенно связанные с
        использованием информации или программ, содержащихся здесь.</p>
      </div>
      <hr>
    </div>

    <div class="TOC">
      <dl>
        <dt><strong>Содержание</strong></dt>

        <dt><a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#PREFACE">Вступительное слово.</a></dt>

        <dt><a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN41">Предисловие</a></dt>

        <dt><a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN61">Благодарности.</a></dt>

        <dt><a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN71">Краткая история развития Qt.</a></dt>

        <dt>Часть I. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN88">Основы Qt.</a></dt>

        <dd>
          <dl>
            <dt>1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER1">Начало.</a></dt>

            <dd>
              <dl>
                <dt>1.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#HELLOQT">Hello, Qt!</a></dt>

                <dt>1.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#MAKINGCONNECTIONS">Обработка
                сигналов.</a></dt>

                <dt>1.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGTHEREFERENCEDOCUMENTATION">Работа со справочной
                системой.</a></dt>
              </dl>
            </dd>

            <dt>2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER2">Создание диалогов.</a></dt>

            <dd>
              <dl>
                <dt>2.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SUBCLASSINGQDIALOG">Создание
                дочернего класса от QDialog.</a></dt>

                <dt>2.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SIGNALSANDSLOTSINDEPTH">Сигналы и
                слоты.</a></dt>

                <dt>2.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#RAPIDDIALOGDESIGN">Быстрая
                разработка диалогов.</a></dt>

                <dt>2.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SHAPECHANGINGDIALOGS">Диалоги с
                изменяющимся внешним видом.</a></dt>

                <dt>2.5. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#DYNAMICDIALOGS">Динамические
                диалоги.</a></dt>

                <dt>2.6. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#BUILTINWIDGETANDDIALOGCLASSES">Встроенные виджеты и
                классы диалогов.</a></dt>
              </dl>
            </dd>

            <dt>3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">Создание главного окна
            приложения</a></dt>

            <dd>
              <dl>
                <dt>3.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SUBCLASSINGQMAINWINDOW">Создание
                класса-наследника от QMainWindow.</a></dt>

                <dt>3.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CREATINGMENUSANDTOOLBARS">Создание
                меню и панелей инструментов.</a></dt>

                <dt>3.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#IMPLEMENTINGTHEFILEMENU">Реализация
                меню "File".</a></dt>

                <dt>3.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SETTINGUPTHESTATUSBAR">Настройка
                строки состояния.</a></dt>

                <dt>3.5. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGDIALOGS">Использование
                диалогов.</a></dt>

                <dt>3.6. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#STORINGSETTINGS">Сохранение
                пользовательских настроек приложения.</a></dt>

                <dt>3.7. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#MULTIPLEDOCUMENTS">Работа с
                несколькими документами одновременно.</a></dt>

                <dt>3.8. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SPLASHSCREENS">Экран-заставка.</a></dt>
              </dl>
            </dd>

            <dt>4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER4">Реализация функциональности
            приложения.</a></dt>

            <dd>
              <dl>
                <dt>4.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#THECENTRALWIDGET">Центральный
                виджет.</a></dt>

                <dt>4.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SUBCLASSINGQTABLE">Создание
                класса-потомка от QTable.</a></dt>

                <dt>4.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#LOADINGANDSAVING">Загрузка и
                сохранение.</a></dt>

                <dt>4.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#IMPLEMENTINGTHEEDITMENU">Реализация
                меню Edit.</a></dt>

                <dt>4.5. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#IMPLEMENTINGTHEOTHERMENUS">Реализация других
                меню.</a></dt>

                <dt>4.6. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SUBCLASSINGQTABLEITEM">Создание
                дочернего класса от QTableItem.</a></dt>
              </dl>
            </dd>

            <dt>5. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER5">Создание собственных
            виджетов.</a></dt>

            <dd>
              <dl>
                <dt>5.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CUSTOMIZINGQTWIDGETS">Переделка
                существующих виджетов Qt.</a></dt>

                <dt>5.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SUBCLASSINGQWIDGET">Создание
                класса-потомка от QWidget.</a></dt>

                <dt>5.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#INTEGRATINGCUSTOMWIDGETSWITHQTDESIGNER">Интеграция
                виджета в Qt Designer.</a></dt>

                <dt>5.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#DOUBLEBUFFERING">Двойная
                буферизация.</a></dt>
              </dl>
            </dd>
          </dl>
        </dd>

        <dt>Часть II. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN3344">Углубленные сведения</a></dt>

        <dd>
          <dl>
            <dt>6. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER6">Управление размещением
            виджетов.</a></dt>

            <dd>
              <dl>
                <dt>6.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#BASICLAYOUTS">Основы компоновки
                виджетов.</a></dt>

                <dt>6.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SPLITTERS">Разделители.</a></dt>

                <dt>6.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#WIDGETSTACKS">Многостраничные
                виджеты.</a></dt>

                <dt>6.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SCROLLVIEWS">Области просмотра с
                прокруткой.</a></dt>

                <dt>6.5. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#DOCKWINDOWS">Стыкуемые
                окна.</a></dt>

                <dt>6.6. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#MULTIPLEDOCUMENTINTERFACE">Многодокументный
                интерфейс.</a></dt>
              </dl>
            </dd>

            <dt>7. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER7">Обработка событий.</a></dt>

            <dd>
              <dl>
                <dt>7.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#REIMPLEMENTINGEVENTHANDLERS">Обработчики
                событий.</a></dt>

                <dt>7.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#INSTALLINGEVENTFILTERS">Установка
                фильтров событий.</a></dt>

                <dt>7.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#STAYINGRESPONSIVEDURINGINTENSIVEPROCESSING">Сокращение
                времени отклика при длительной обработке
                данных.</a></dt>
              </dl>
            </dd>

            <dt>8. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER8">Двух- и трехмерная
            графика.</a></dt>

            <dd>
              <dl>
                <dt>8.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#PAINTINGWITHQPAINTER">Рисование
                средствами QPainter.</a></dt>

                <dt>8.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#GRAPHICSWITHQCANVAS">Рисование
                средствами QCanvas.</a></dt>

                <dt>8.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#PRINTING">Вывод на печать.</a></dt>

                <dt>8.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#GRAPHICSWITHOPENGL">Графика
                OpenGL.</a></dt>
              </dl>
            </dd>

            <dt>9. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER9">Drag and Drop.</a></dt>

            <dd>
              <dl>
                <dt>9.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#ENABLINGDRAGANDDROP">Реализация
                механизма 'drag and drop' в
                приложениях.</a></dt>

                <dt>9.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SUPPORTINGCUSTOMDRAGTYPES">Поддержка
                нестандартных типов данных при перетаскивании.</a></dt>

                <dt>9.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#ADVANCEDCLIPBOARDHANDLING">Расширенные возможности
                буфера обмена.</a></dt>
              </dl>
            </dd>

            <dt>10. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER10">Ввод/вывод.</a></dt>

            <dd>
              <dl>
                <dt>10.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#READINGANDWRITINGBINARYDATA">Чтение
                и запись двоичных данных.</a></dt>

                <dt>10.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#READINGANDWRITINGTEXT">Чтение и
                запись текста.</a></dt>

                <dt>10.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#HANDLINGFILESANDDIRECTORIES">Работа
                с файлами и каталогами.</a></dt>

                <dt>10.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#INTERPROCESSCOMMUNICATION">Взаимодействия между
                процессами.</a></dt>
              </dl>
            </dd>

            <dt>11. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER11">Контейнерные классы.</a></dt>

            <dd>
              <dl>
                <dt>11.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#VECTORS">Векторы.</a></dt>

                <dt>11.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#LISTS">Списки.</a></dt>

                <dt>11.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#MAPS">Словари (map).</a></dt>

                <dt>11.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#POINTERBASEDCONTAINERS">Контейнеры
                указателей.</a></dt>

                <dt>11.5. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#QSTRINGANDQVARIANT">Классы QString
                и QVariant.</a></dt>
              </dl>
            </dd>

            <dt>12. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER12">Базы данных.</a></dt>

            <dd>
              <dl>
                <dt>12.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CONNECTINGANDQUERYING">Установление
                соединения и выполнение запроса.</a></dt>

                <dt>12.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#PRESENTINGDATAINTABULARFORM">Представление данных в
                табличной форме.</a></dt>

                <dt>12.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CREATINGDATAAWAREFORMS">Разработка
                форм, ориентированных на работу с базами
                данных.</a></dt>
              </dl>
            </dd>

            <dt>13. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER13">Работа с сетью.</a></dt>

            <dd>
              <dl>
                <dt>13.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGQFTP">Класс QFtp.</a></dt>

                <dt>13.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGQHTTP">Класс QHttp.</a></dt>

                <dt>13.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#TCPNETWORKINGWITHQSOCKET">Класс
                QSocket.</a></dt>

                <dt>13.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#UDPNETWORKINGWITHQSOCKETDEVICE">Протокол UDP и класс
                QSocketDevice.</a></dt>
              </dl>
            </dd>

            <dt>14. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER14">XML</a></dt>

            <dd>
              <dl>
                <dt>14.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#READINGXMLWITHSAX">Чтение
                XML-документов с помощью SAX.</a></dt>

                <dt>14.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#READINGXMLWITHDOM">Чтение
                XML-документов с помощью DOM.</a></dt>

                <dt>14.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#WRITINGXML">Запись в
                XML-документы.</a></dt>
              </dl>
            </dd>

            <dt>15. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER15">Интернационализация</a></dt>

            <dd>
              <dl>
                <dt>15.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#WORKINGWITHUNICODE">Unicode.</a></dt>

                <dt>15.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#MAKINGAPPLICATIONSTRANSLATIONAWARE">Разработка
                приложений, подготовленных к переводу.</a></dt>

                <dt>15.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#DYNAMICLANGUAGESWITCHING">Динамическое переключение
                языков.</a></dt>

                <dt>15.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#TRANSLATINGAPPLICATIONS">Перевод
                существующих приложений.</a></dt>
              </dl>
            </dd>

            <dt>16. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER16">Разработка справочной системы
            приложения.</a></dt>

            <dd>
              <dl>
                <dt>16.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#TOOLTIPSSTATUSTIPSANDWHATSTHISHELP">Всплывающие
                подсказки и справка "What's
                This?".</a></dt>

                <dt>16.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGQTEXTBROWSERASASIMPLEHELPENGINE">Использование
                QTextBrowser для отображения текста справки.</a></dt>

                <dt>16.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGQTASSISTANTFORPOWERFULONLINEHELP">Использование
                Qt Assistant для отображения текста справки.</a></dt>
              </dl>
            </dd>

            <dt>17. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER17">Многопоточность.</a></dt>

            <dd>
              <dl>
                <dt>17.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#WORKINGWITHTHREADS">Потоки.</a></dt>

                <dt>17.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#COMMUNICATINGWITHTHEGUITHREAD">Взаимодействие с
                главным потоком приложения.</a></dt>

                <dt>17.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGQTSCLASSESINNONGUITHREADS">Работа с классами Qt
                вне главного потока.</a></dt>
              </dl>
            </dd>

            <dt>18. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER18">Платформо-зависимые
            особенности.</a></dt>

            <dd>
              <dl>
                <dt>18.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#INTERFACINGWITHNATIVEAPIS">Взаимодействие с API
                операционной системы.</a></dt>

                <dt>18.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGACTIVEX">ActiveX.</a></dt>

                <dt>18.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SESSIONMANAGEMENT">Управление
                сеансами.</a></dt>
              </dl>
            </dd>

            <dt>19. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#ABOUTTHEAUTHORS">Об авторах.</a></dt>

            <dd>
              <dl>
                <dt>19.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN8505">Jasmin Blanchette</a></dt>

                <dt>19.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN8510">Mark Summerfield</a></dt>
              </dl>
            </dd>
          </dl>
        </dd>
      </dl>
    </div>

    <div class="PREFACE">
      <hr>

      <h1><a name="PREFACE"></a>Вступительное слово.</h1>

      <p>Почему Qt? Почему многие программисты выбирают ее? Ответы на
      эти вопросы вполне очевидны: Qt -- это единая, сохраняющая
      совместимость на уровне исходного кода, библиотека. Ее
      особенность -- богатство возможностей. Ее производительность
      обеспечивается языком программирования C++. Она доступна в
      исходных текстах. Она сопровождается хорошо проработанной
      документацией. Разработчики предоставляют высококачественную
      техническую поддержку. И многое, многое другое, что вы сможете
      прочесть в глянцевых проспектах от Trolltech. Это все хорошо, но
      тут упущен один важный момент: Qt пользуется успехом потому, что
      она НРАВИТСЯ программистам.</p>

      <p>Как так получается, что программистам нравятся одни технологии
      и не нравятся другие? Лично я полагаю, что инженеру -
      программисту нравится тот продукт, который несет в себе ощущение
      правильности, законченности, некоей внутренней красоты и не
      нравится тот, в котором чувствуются изъяны. Как еще можно
      объяснить тот факт, что некоторые из ярчайших программистов не в
      состоянии без посторонней помощи запрограммировать
      видеомагнитофон? Или что многие инженеры испытывают затруднения,
      когда сталкиваются лицом к лицу с телефонной системой компании? Я
      без особых проблем запоминаю длинные последовательности случайных
      чисел и команд, но когда дело доходит до управления
      автоответчиком -- я предпочитаю держаться в стороне. Телефонная
      система нашей компании требует, чтобы клавиша <strong class="COMMAND">&lt;*&gt;</strong> удерживалась не менее 2-х секунд,
      прежде чем можно будет набирать добавочный код. Если вы забудете
      это обстоятельство и продолжите набор добавочного кода без
      выполнения задержки, то вам придется набирать номер с самого
      начала. Но почему <strong class="COMMAND">&lt;*&gt;</strong>?
      Почему не <strong class="COMMAND">&lt;#&gt;</strong>, не
      <strong class="COMMAND">&lt;1&gt;</strong> или <strong class="COMMAND">&lt;5&gt;</strong>? Почему не любая другая из 12-ти
      клавиш? Почему именно 2 секунды? Почему не 1, не 3 или не 1.5?
      Почему именно так, а не иначе? Телефон настолько меня раздражает,
      что я предпочитаю пользоваться им только в самых крайних случаях,
      когда не позвонить просто невозможно.</p>

      <p>Программирование во многом похоже на нашу телефонную систему,
      только во много раз хуже. И тут к нам на помощь приходит Qt. Она
      разнолика. С одной стороны она наполнена глубочайшим смыслом. С
      другой -- полна забавных моментов. Qt позволяет полностью
      сконцентрироваться на решении задач. Когда разработчики
      библиотеки сталкивались с какой-либо проблемой, они не просто
      находили хорошее, быстрое или простое решение -- они находили в
      первую очередь <span class="emphasis"><em class="EMPHASIS">правильное</em></span> решение и затем подробно его
      документировали. Найденные архитектурные решения прошли
      длительное испытание временем. Тем не менее в библиотеке все еще
      существуют <span class="QUOTE">"узкие"</span> места, но
      они могут быть и будут исправлены.</p>

      <p>Задолго до того как Qt достигла пика своей популярности,
      разработчики, посвятившие себя этой библиотеке, сделали из нее
      нечто особенное. Эта преданность не угасла до сих пор и живет во
      всех, кто так или иначе связан с этой библиотекой. Для нас,
      работа над Qt -- это привилегия и большая ответственность. Мы
      гордимся возможностью сделать вашу профессиональную жизнь проще и
      приятнее.</p>

      <p>Библиотека Qt поставляется с замечательным комплектом
      документации. Но она в основном концентрируется на описании
      отдельных классов и лишь вскользь касается темы разработки
      сложных приложений. Данная книга заполняет этот пробел. Здесь
      рассказывается о том, что может предложить вам Qt, как с ней
      работать и как получить от нее максимум отдачи. Книга
      сопровождается большим количеством примеров, советов и подробных
      описаний.</p>

      <p>В настоящее время, на базе Qt, разработано гигантское
      количество приложений, как коммерческих, так и
      свободно-распространяемых. Одни из них ориентированы на
      узкоспециализированный рынок, другие предназначены для массового
      использования. Такая популярность наполняет нас гордостью и
      вдохновляет на поиски новых решений, которые сделают нашу
      библиотеку еще лучше. А с помощью этой книги появится еще больше
      высококачественных приложений, написанных с использованием
      библиотеки Qt.</p><a name="AEN38"></a>

      <table border="0" width="100%" cellspacing="0" cellpadding="0" class="BLOCKQUOTE">
        <tbody><tr>
          <td width="10%" valign="top">&nbsp;</td>

          <td width="80%" valign="top">
            <p class="LITERALLAYOUT">&nbsp;&nbsp;&nbsp;&nbsp;</p>
          </td>

          <td width="10%" valign="top">&nbsp;</td>
        </tr>

        <tr>
          <td colspan="2" align="right" valign="top">-- <span class="ATTRIBUTION">Маттиас Эттрич,
              Осло, Норвегия, Ноябрь 2003</span></td>

          <td width="10%">&nbsp;</td>
        </tr>
      </tbody></table>
    </div>

    <div class="PREFACE">
      <hr>

      <h1><a name="AEN41"></a>Предисловие</h1>

      <p>Qt -- это библиотека классов C++ и набор инструментального
      программного обеспечения, предназначенных для построения
      многоплатформенных приложений с графическим интерфейсом и
      исповедующих принцип <span class="QUOTE">"написав однажды --
      компилируй в любом месте"</span>. Qt представляет собой
      единую платформу для приложений, которые могут работать под
      управлением Windows 95/98/Me/2000/XP, Mac OS X, Linux, Solaris,
      HP-UX и других версий Unix.</p>

      <p>Цель данной книги -- научить вас писать программы, с
      графическим интерфейсом, основываясь на Qt 3. Обучение начинается
      с простенькой программы <span class="QUOTE">"Hello,
      Qt!"</span> и быстро переходит к описанию расширенных
      возможностей библиотеки, таких как -- создание собственных
      визуальных компонентов (widgets) и использование технологии
      <span class="QUOTE">"перетащил и бросил"</span> (drag
      and drop).</p>

      <p>Книга концентрируется на описании стиля и техники
      программирования в Qt 3, вместо того, чтобы просто изложить
      другими словами документацию, поставляемую разработчиками. Кроме
      того, поскольку мы принимаем участие в разработке Qt 4, мы
      постарались преподнести материал таким образом, чтобы полученные
      вами сведения не потеряли свою актуальность и после выхода в свет
      Qt 4.</p>

      <p>В своем повествовании мы предполагаем, что вы уже знакомы с
      языком программирования C++. Примеры программ, которые вы здесь
      встретите, написаны на C++. Причем мы использовали ограниченный
      круг особенностей этого языка -- только то, что действительно
      необходимо для того, чтобы начать работать с библиотекой. В тех
      местах, где использование более сложных конструкций языка C++
      неизбежно, мы будем давать довольно подробное описание.</p>

      <p>Qt завоевала репутацию мультиплатформенного набора
      инструментальных средств, однако, не смотря на это, чаще всего
      она используется для разработки приложений на какой-либо одной
      платформе. В качестве примера приложения, написанного с помощью
      Qt и получившего массовое распространение, можно привести
      <strong class="COMMAND">Adobe Photoshop Album</strong>. На базе
      Qt построено огромное количество узкоспециализированног
      программного обеспечения. Сюда можно отнести программы,
      разработанные для создания 3D-анимации, цифровой обработки
      видеоизображений, автоматизации разработки электронных
      компонентов (микросхем), для геологических исследований, для
      работы в области медицины и многие многие другие. Если вы
      зарабатываете себе на жизнь разработкой программ для платформы
      Windows, то вы с легкостью сможете расширить круг своих
      потребителей, за счет Mac OS X и Linux, просто пересобрав свои
      приложения под эти платформы.</p>

      <p>Qt распространяется на основе нескольких лицензий. Если вы
      предполагаете создавать программы на коммерческой основе, то вы
      должны приобрести коммерческую лицензию и коммерческую версию Qt.
      Если вы разрабатываете программы с открытым исходным кодом, то вы
      должны использовать некоммерческую версию библиотеки. Qt является
      основой, на которой построен KDE (K Desktop Environment) и
      множество других программных продуктов с открытыми исходными
      текстами.</p>

      <p>Кроме библиотеки из сотен классов мы предоставляем
      дополнительные компоненты, которые расширяют возможности
      библиотеки. Некоторые из них, такие как: модуль интеграции
      Qt/Motif и Qt Script for Applications (QSA), предлагаются
      компанией Trolltech, другие -- третьими фирмами и сообществом
      open source. За информацией, по дополнениям и расширениям,
      обращайтесь по адресу: <a href="http://www.trolltech.com/products/3rdparty/" target="_top">http://www.trolltech.com/products/3rdparty/</a>.
         Кроме того, Qt имеет свое собственное сообщество
         пользователей, которые обмениваются между собой информацией
         через списки рассылки. Перечень списков рассылки вы найдете
         здесь: <a href="http://lists.trolltech.com/" target="_top">http://lists.trolltech.com/</a>.</p>

      <p>Книга поделена на две больших части. Часть I охватывает
      теоретические и практические сведения, необходимые для разработки
      приложений с графическим интерфейсом в среде Qt 3. Этих сведений
      будет вполне достаточно для написания несложных программ. Часть
      II дает более углубленный материал. Главы в этой части могут
      читаться в любом порядке, но требуют предварительного
      ознакомления с первой частью книги.</p>

      <p>Если вы встретите ошибки в тексте или у вас появятся
      предложения, по-поводу будущих редакций этой книги, то мы будем
      рады прочитать ваши сообщения. Направляйте свои письма по
      адресам: <tt class="EMAIL">&lt;<a href="mailto:jasmin.blanchette@trolltech.com">jasmin.blanchette@trolltech.com</a>&gt;</tt>
      и <tt class="EMAIL">&lt;<a href="mailto:mark.summerfield@trolltech.com">mark.summerfield@trolltech.com</a>&gt;</tt>.
      Список обнаруженных опечаток будет размещен по адресу: <a href="http://vig.prenhall.com/catalog/academic/product/0,4096,0131240722,00.html" target="_top">http://vig.prenhall.com/catalog/academic/product/0,4096,0131240722,00.html</a>.</p>
    </div>

    <div class="PREFACE">
      <hr>

      <h1><a name="AEN61"></a>Благодарности.</h1>

      <p>Прежде всего мы хотели бы поблагодарить президента компании
      Trolltech -- Эрика Чамбенга (Eirik Chambe-Eng). Эрик не только с
      большим энтузиазмом отнесся к нашему желанию написать книгу, но и
      позволил уделить этому огромное количество времени. Эрик и
      главный управляющий Trolltech -- Хаавард Норд (Haavard Nord)
      взяли на себя труд прочитать рукопись и дали весьма ценные
      замечания. Их великодушие и дальновидность в немалой степени
      зависели от усилий Матиаса Эттрича (Matthias Ettrich) -- ведущего
      разработчика Trolltech и нашего босса. Матиас сквозь пальцы
      смотрел на наше пренебрежение трудовым распорядком, поскольку нас
      целиком захватила работа над книгой, и дал немало советов по
      стилю программирования в Qt.</p>

      <p>В качестве независимых рецензентов мы привлекли Пауля Кёртиса
      (Paul Curtis) и Клауса Шмидинджера (Klaus Schmidinger) -- оба
      являются прекрасными экспертами в Qt. Они с удивительным
      вниманием к техническим подробностям прочитали нашу книгу,
      подметили и исправили ряд трудно уловимых ошибок. А так же внесли
      свои предложения по улучшению содержимого.</p>

      <p>Самым неподкупным нашим рецензентом был Реджинальд Стадльбайер
      (Reginald Stadlbauer). <a name="AEN66" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#FTN.AEN66"><span class="footnote">[1]</span></a> Его
         технические познания стали для нас неоценимым источником
         информации. Он показал нам ряд возможностей Qt, о
         существовании которых мы даже не подозревали.</p>

      <p>Также, в рецензировании книги принимали участие Трентон Шульц
      (Trenton Schulz), Энди Шоу (Andy Shaw) и Андреас Аардал Ханссен
      (Andreas Aardal Hanssen). Трентон и Энди дали массу советов по
      всем аспектам книги и особенно по вопросам, касавшимся Qt/Mac и
      Qt/Windows. Андреас оказал неоценимую услугу при подготовке
      первой части книги.</p>

      <p>Немалую помощь мы получили от Уорвика Аллисона (Warwick
      Allison) (2D графика), Эрика Чамбенга (история развития Qt),
      Матиаса Эттрича (обработка событий и разработка собственных
      визуальных компонентов), Харальда Ферненгеля (Harald Fernengel)
      (базы данных), Волкера Хильшеймера (Volker Hilsheimer) (ActiveX),
      Брэдли Хьюса (Bradley Hughes) (многопоточность), Тронда
      Кьярнесена (Trond Kjernesen) (3D графика и базы данных), Ларса
      Кнолла (Lars Knoll) (2D графика), Сэма Магнусона (Sam Magnuson)
      (qmake), Димитрия Пападопулоса (Dimitri Papadopoulos) (Qt/X11),
      Пауля Олава Твета (Paul Olav Tvete) (разработка собственных
      визуальных компонентов и Qt/Embedded), Райнера Шмида (Rainer
      Schmid) (сети и XML) и Гуннара Слетта (Gunnar Sletta) (обработка
      событий).</p>

      <p>Выражаем особую благодарность команде технической поддержки и
      системным администраторам Trolltech, которые обеспечивали
      бесперебойную работу наших компьютеров и сетей.</p>
    </div>

    <div class="PREFACE">
      <hr>

      <h1><a name="AEN71"></a>Краткая история развития Qt.</h1>

      <p>Первый выход в свет библиотеки Qt состоялся в мае 1995 года.
      Первоначально она разрабатывалась Хаавардом Нордом (главный
      управляющий Trolltech) и Эриком Чамбенгом (президент компании
      Trolltech). Хаавард и Эрик встретились в стенах Норвежского
      Технологического Института, в городе Тронхейме, где они получали
      высшее образование.</p>

      <p>Хаавард начал интересоваться проблемами создания графического
      интерфейса на C++ с 1988 года. Тогда он получил от Шведской
      компании заказ на разработку библиотеки, средствами которой можно
      было бы реализовать графический интерфейс приложений. Спустя пару
      лет, летом 1990 года, Хаавард и Эрик начали совместную работу над
      приложением баз данных, которое обрабатывало снимки, получаемые с
      аппарата ультразвукового обследования. Система должна была иметь
      возможность работы через графический интерфейс с пользователем,
      под управлением операционных систем Unix, Macintosh и Windows.
      Однажды, Хаавард и Эрик вышли на улицу, чтобы подышать свежим
      воздухом и насладиться летним солнцем. Они присели на скамейку в
      парке и Хаавард сказал: "Нам нужна объектно-ориентированная
      система отображения информации". В результате обсуждения
      была заложена основа, для создания объектно-ориентированной,
      мультиплатформенной библиотеки, к разработке которой они должны
      были вскоре приступить.</p>

      <p>В 1991 году Хаавард написал первые несколько классов, из
      которых потом и появилась Qt. Эрик занялся разработкой общего
      дизайна библиотеки. На следующий год Эрику пришла в голову идея
      реализации "сигналов и слотов" -- простой но очень
      мощной парадигмы программирования графического интерфейса.
      Хаавард подхватил идею и воплотил ее в код. К 1993 году они
      завершили разработку первого графического ядра и приступили к
      созданию визуальных компонентов (widgets). В конце года Хаавард
      предложил Эрику открыть совместное дело и выпустить "лучшую
      в мире библиотеку реализации графического интерфейса на
      C++".</p>

      <p>1994 год, для двух молодых программистов, начался неудачно. У
      них не было ни заказов, ни готового продукта, ни денег. К
      счастью, их жены имели работу и готовы были поддержать своих
      супругов в течение двух лет, которые требовались на доведение
      библиотеки до того состояния, в котором она могла бы приносить
      доход.</p>

      <p>В качестве префикса, в именах классов, был выбран символ
      "Q", поскольку Хааварду очень нравилось как он выглядел
      в Emacs. Символ "t" был выбран потому, что с него
      начиналось слово "toolkit", по аналогии с
      "Xt" -- "X toolkit". Компания была
      зарегистрирована 4 марта 1994 года под названием "Quasar
      Technologies", которое затем было преобразовано в
      "Troll Tech", а затем и в "Trolltech".</p>

      <p>В апреле 1995 года, благодаря содействию профессора, у
      которого обучался Хаавард, Норвежская компания Metis заключила с
      ними контракт на разработку программного обеспечения на базе Qt.
      Примерно в то же время Trolltech нанял Арнта Гульбрандсена (Arnt
      Gulbrandsen) <a name="AEN79" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#FTN.AEN79"><span class="footnote">[2]</span></a> ,
         который изобрел и воплотил в жизнь справочную систему Qt.
         Кроме того он внес существенный вклад в разработку
         библиотеки.</p>

      <p>20 мая 1995 года, Qt 0.90 была выложена на sunsite.unc.edu.
      Шесть дней спустя, выход библиотеки был анонсирован на
      comp.os.linux.announce. Это был первый публичный выпуск. Qt тогда
      могла работать как под управлением Windows, так и под управлением
      Unix, предоставляя разработчикам единый API (Прикладной
      Интерфейс). Библиотека была выпущена под двумя лицензиями:
      коммерческой -- для разработки коммерческого программного
      обеспечения, и свободной -- для разработки программ с открытым
      исходным кодом. Контракт с фирмой Metis помог сохранить Trolltech
      на плаву, поскольку на протяжении долгих 10 месяцев не была
      продано ни одной коммерческой версии библиотеки.</p>

      <p>В марте 1996 года, Европейское Космическое Агентство закупило
      сразу 10 коммерческих лицензий. С несгибаемой верой в успех, Эрик
      и Хаавард наняли еще одного разработчика. В мае вышла Qt 0.97, а
      24 сентября 1996 года увидела свет Qt 1.0. К концу года появилась
      Qt 1.1, а число покупателей достигло восьми, которые закупили 18
      лицензий. В этом же году был основан проект KDE, во главе с
      Матиасом Эттричем.</p>

      <p>В апреле 1997 года вышла Qt 1.2. Решение Матиаса, об
      использовании Qt в качестве основы для KDE, де-факто сделало
      библиотеку стандартом, для разработки графического интерфейса в
      Linux. В сентябре 1997 года вышла Qt 1.3.</p>

      <p>Матиас присоединился к Trolltech в 1998 году, а в сентябре
      этого же года состоялся выход очередной версии Qt -- 1.40. В июне
      1999 года вышла Qt 2, в которую было внесено большое количество
      архитектурных изменений. К тому же она стала более зрелой, чем ее
      предшественницы. Для поддержки Unicode в нее было добавлено 40
      новых классов. Qt 2 была выпущена на основе новой открытой
      лицензии -- Q Public License (QPL), которая соответствовала Open
      Source Definition. В августе 1999, Qt победила на LinuxWorld, в
      номинации "Лучшая библиотека". Примерно в то же время
      была образована Trolltech Pty Ltd (Австралия).</p>

      <p>Первый выпуск Qt/Embedded состоялся в 2000 году. Она была
      разработана для работы в устройствах под управлением Embedded
      Linux и предоставляла свою оконную подсистему -- легковесную
      замену X11. И Qt/Embedded, и Qt/X11 предлагались под широко
      используемой лицензией GNU General Public License (GPL), так же
      как и под коммерческими лицензиями. В конце 2000 года, Trolltech
      образовала Trolltech Inc. (США) и выпустила первую версию Qtopia
      -- графическая среда для карманных устройств. В 2001 и в 2002
      годах, Qt/Embedded стала победительницей на LinuxWorld, в
      номинации "Лучшее решение для Embedded Linux".</p>

      <p>В 2001 году вышла Qt 3. Теперь эта библиотека может работать
      под управлением Windows, Unix, Linux, Embedded Linux и Mac OS X.
      В ее состав вошли 42 новых класса, а общий объем кода перевалил
      за 500 000 строк. Qt 3 стала победительницей Software Development
      Times "Jolt Productivity Award" 2002 года.</p>

      <p>С момента рождения, из года в год, компания удваивала объем
      продаж. Этот успех обеспечивался высоким качеством библиотеки и
      простотой ее использования. На протяжении практически всего
      периода существования компании, за маркетинговую политику и объем
      продаж отвечали всего несколько человек. Менее чем за
      десятилетие, Qt превратилась из малоизвестной библиотеки в
      программный продукт, известный тысячам и тысячам разработчиков во
      всем мире.</p>
    </div>

    <div class="PART">
      <a name="AEN88"></a>

      <div class="TITLEPAGE">
        <h1 class="TITLE">Часть I. Основы Qt.</h1>

        <div class="TOC">
          <dl>
            <dt><strong>Содержание</strong></dt>

            <dt>1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER1">Начало.</a></dt>

            <dd>
              <dl>
                <dt>1.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#HELLOQT">Hello, Qt!</a></dt>

                <dt>1.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#MAKINGCONNECTIONS">Обработка
                сигналов.</a></dt>

                <dt>1.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGTHEREFERENCEDOCUMENTATION">Работа со справочной
                системой.</a></dt>
              </dl>
            </dd>

            <dt>2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER2">Создание диалогов.</a></dt>

            <dd>
              <dl>
                <dt>2.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SUBCLASSINGQDIALOG">Создание
                дочернего класса от QDialog.</a></dt>

                <dt>2.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SIGNALSANDSLOTSINDEPTH">Сигналы и
                слоты.</a></dt>

                <dt>2.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#RAPIDDIALOGDESIGN">Быстрая
                разработка диалогов.</a></dt>

                <dt>2.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SHAPECHANGINGDIALOGS">Диалоги с
                изменяющимся внешним видом.</a></dt>

                <dt>2.5. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#DYNAMICDIALOGS">Динамические
                диалоги.</a></dt>

                <dt>2.6. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#BUILTINWIDGETANDDIALOGCLASSES">Встроенные виджеты и
                классы диалогов.</a></dt>
              </dl>
            </dd>

            <dt>3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">Создание главного окна
            приложения</a></dt>

            <dd>
              <dl>
                <dt>3.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SUBCLASSINGQMAINWINDOW">Создание
                класса-наследника от QMainWindow.</a></dt>

                <dt>3.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CREATINGMENUSANDTOOLBARS">Создание
                меню и панелей инструментов.</a></dt>

                <dt>3.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#IMPLEMENTINGTHEFILEMENU">Реализация
                меню "File".</a></dt>

                <dt>3.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SETTINGUPTHESTATUSBAR">Настройка
                строки состояния.</a></dt>

                <dt>3.5. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGDIALOGS">Использование
                диалогов.</a></dt>

                <dt>3.6. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#STORINGSETTINGS">Сохранение
                пользовательских настроек приложения.</a></dt>

                <dt>3.7. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#MULTIPLEDOCUMENTS">Работа с
                несколькими документами одновременно.</a></dt>

                <dt>3.8. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SPLASHSCREENS">Экран-заставка.</a></dt>
              </dl>
            </dd>

            <dt>4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER4">Реализация функциональности
            приложения.</a></dt>

            <dd>
              <dl>
                <dt>4.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#THECENTRALWIDGET">Центральный
                виджет.</a></dt>

                <dt>4.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SUBCLASSINGQTABLE">Создание
                класса-потомка от QTable.</a></dt>

                <dt>4.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#LOADINGANDSAVING">Загрузка и
                сохранение.</a></dt>

                <dt>4.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#IMPLEMENTINGTHEEDITMENU">Реализация
                меню Edit.</a></dt>

                <dt>4.5. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#IMPLEMENTINGTHEOTHERMENUS">Реализация других
                меню.</a></dt>

                <dt>4.6. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SUBCLASSINGQTABLEITEM">Создание
                дочернего класса от QTableItem.</a></dt>
              </dl>
            </dd>

            <dt>5. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER5">Создание собственных
            виджетов.</a></dt>

            <dd>
              <dl>
                <dt>5.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CUSTOMIZINGQTWIDGETS">Переделка
                существующих виджетов Qt.</a></dt>

                <dt>5.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SUBCLASSINGQWIDGET">Создание
                класса-потомка от QWidget.</a></dt>

                <dt>5.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#INTEGRATINGCUSTOMWIDGETSWITHQTDESIGNER">Интеграция
                виджета в Qt Designer.</a></dt>

                <dt>5.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#DOUBLEBUFFERING">Двойная
                буферизация.</a></dt>
              </dl>
            </dd>
          </dl>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER1"></a>Глава 1. Начало.</h1>

        <p>В этой главе мы расскажем -- как использовать функциональные
        возможности библиотеки Qt, для создания графического интерфейса
        с пользователем, в программах на языке C++. Напишем несколько
        небольших программ. А так же дадим краткое введение в два
        ключевых понятия Qt: "сигналы и слоты" и
        "разметка" (layout). В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER2">Главе
        2</a> будут даны более обширные сведения, а в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">Главе 3</a> рассмотрим пример создания настоящего
        приложения.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="HELLOQT"></a>1.1. Hello,
          Qt!</h1>

          <p>Ниже приводится текст простейшей Qt программы:</p>
          <pre class="PROGRAMLISTING"> 1 #include &lt;qapplication.h&gt;
 2 #include &lt;qlabel.h&gt;
 3 int main(int argc, char *argv[])
 4 {
 5     QApplication app(argc, argv);
 6     QLabel *label = new QLabel("Hello, Qt!", 0);
 7     app.setMainWidget(label);
 8     label-&gt;show();
 9     return app.exec();
10 }
      
</pre>Здесь, в строках 1 и 2, подключаются определения классов
<tt class="COMPUTEROUTPUT">QApplication</tt> и <tt class="COMPUTEROUTPUT">QLabel</tt>.<br>
          <br>

          <p>В строке 5 создается экземпляр класса <tt class="COMPUTEROUTPUT">QApplication</tt>, который управляет
          ресурсами приложения. Конструктору <tt class="COMPUTEROUTPUT">QApplication</tt> передаются аргументы
          <tt class="COMPUTEROUTPUT">argc</tt> и <tt class="COMPUTEROUTPUT">argv</tt>, поскольку Qt имеет возможность
          обрабатывать аргументы командной строки.</p>

          <p>В строке 6 создается визуальный компонент <tt class="COMPUTEROUTPUT">QLabel</tt>, который отображает надпись
          "Hello, Qt!". В терминологии Qt, все визуальные
          компоненты, из которых строится графический интерфейс,
          называются <span class="emphasis"><em class="EMPHASIS">виджетами</em></span> (widgets). Кнопки, меню,
          полосы прокрутки и разнообразные рамки -- все это виджеты.
          Одни виджеты могут содержать в себе другие виджеты, например,
          главное окно приложения -- это самый обычный виджет, который
          может содержать <tt class="COMPUTEROUTPUT">QMenuBar</tt>,
          <tt class="COMPUTEROUTPUT">QToolBar</tt>, <tt class="COMPUTEROUTPUT">QStatusBar</tt> и др. Аргумент 0,
          передаваемый конструктору <tt class="COMPUTEROUTPUT">QLabel</tt> (в строке 6) -- это
          "пустой" (null) указатель, который сообщает о том,
          что этот виджет не имеет "хозяина", т.е. не
          включается в другой виджет.</p>

          <p>В строке 7 назначается "главный" виджет
          приложения. Когда пользователь закрывает "главный"
          виджет приложения (например, нажатием на кнопку "X"
          в заголовке окна), то программа завершает свою работу. Если в
          программе не назначить главный виджет, то она продолжит
          исполнение в фоновом режиме даже после того, как пользователь
          закроет окно.</p>

          <p>В строке 8, метка делается видимой. Виджеты всегда
          создаются невидимыми, чтобы у программиста оставалась
          возможность настроить параметры отображения до того, как они
          станут видимы.</p>

          <p>В строке 9 выполняется передача управления библиотеке Qt.
          С этого момента программа переходит в режим ожидания, когда
          она ничего не делает, а просто ждет действий пользователя,
          например, нажатие на клавишу или кнопку мыши.</p>

          <p>Любое действие пользователя порождает <span class="emphasis"><em class="EMPHASIS">событие</em></span> (другими
          словами -- "сообщение"), в ответ на которое
          программа может вызвать одну или более функций. В этом
          смысле, приложения с графическим интерфейсом кардинально
          отличаются от обычных программ, с пакетной обработкой данных,
          которые приняв ввод от пользователя, они самостоятельно
          обрабатывают его, выдают результаты и завершают свою работу
          без дальнейшего участия человека.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 1.1. Окно приложения в Windows XP</p>
            </div>
          </div><br>

          <p>Теперь самое время проверить работу нашего приложения. Но
          прежде всего -- необходимо, чтобы у вас была установлена Qt
          3.2 (или более поздняя версия), а переменная окружения
          <tt class="ENVAR">PATH</tt> содержала корректный путь к
          каталогу <tt class="FILENAME">bin</tt>. (В Windows настройка
          переменной PATH выполняется автоматически, в процессе
          установки библиотеки Qt)</p>

          <p>Скопируйте текст программы в файл, с именем <tt class="FILENAME">hello.cpp</tt>, в каталог <tt class="FILENAME">hello</tt>.</p>

          <p>Перейдите в этот каталог и дайте команду:</p>
          <pre class="SCREEN">qmake -project      
      
</pre>она создаст платформо-независимый файл проекта
          (<tt class="FILENAME">hello.pro</tt>), а затем дайте
          следующую команду:
          <pre class="SCREEN">qmake hello.pro      
      
</pre>Эта команда создаст <tt class="FILENAME">Makefile</tt>, на основе
файла проекта. Дайте команду <tt class="FILENAME">make</tt>, чтобы
скомпилировать программу и затем запустите ее, набрав в командной
строке <tt class="USERINPUT"><strong>hello</strong></tt> (в Windows)
или <tt class="USERINPUT"><strong>./hello</strong></tt> (в Unix) или
<tt class="USERINPUT"><strong>open hello.app</strong></tt> (в Mac OS
X). Если вы работаете в Windows и используете Microsoft Visual C++, то
вместо команды <tt class="FILENAME">make</tt> вы должны дать команду
<tt class="FILENAME">nmake</tt>. Как альтернативный вариант -- вы
можете создать проект Visual Studio из файла <tt class="FILENAME">
          hello.pro</tt>, запустив команду:
          <pre class="SCREEN">qmake -tp vc hello.pro      
      
</pre>и затем скомпилировать программу в Visual Studio.<br>
          <br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 1.2. Метка с форматированным текстом.</p>
            </div>
          </div><br>

          <p>А теперь немного развлечемся. Изменим внешний вид метки,
          добавив форматирование текста в стиле HTML. Для этого,
          замените строку</p>
          <pre class="SCREEN">QLabel *label = new QLabel("Hello, Qt!", 0);      
      
</pre>на
          <pre class="SCREEN">QLabel *label = new QLabel("&lt;h2 &gt;&lt;i&gt;Hello&lt;/i&gt; "
                           "&lt;font color=red&gt;Qt!&lt;/font&gt;&lt;/h2&gt;", 0);
      
</pre>и пересоберите приложение.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="MAKINGCONNECTIONS"></a>1.2.
          Обработка сигналов.</h1>

          <p>Следующий пример показывает -- как организовать реакцию
          приложения на действия пользователя. Это приложение содержит
          кнопку, при нажатии на которую программа закрывается.
          Исходный текст очень похож на предыдущий пример, за
          исключением того, что теперь, в качестве главного виджета,
          вместо <tt class="CLASSNAME">QLabel</tt> используется
          <tt class="CLASSNAME">QPushButton</tt>, и добавлен код,
          который обслуживает факт ее нажатия.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 1.3. Приложение Quit.</p>
            </div>
          </div><br>
          <pre class="SCREEN"> 1 #include &lt;qapplication.h&gt;
 2 #include &lt;qpushbutton.h&gt; 
 3 int main(int argc, char *argv[]) 
 4 { 
 5   QApplication app(argc, argv); 
 6   QPushButton *button = new QPushButton("Quit", 0);      
 7   QObject::connect(button, SIGNAL(clicked()), 
 8                    &amp;app, SLOT(quit())); 
 9   app.setMainWidget(button); 
10   button-&gt;show(); 
11   return app.exec(); 
12 }
      
</pre>Виджеты Qt имеют возможность посылать приложению
          <span class="emphasis"><em class="EMPHASIS">сигналы</em></span>, извещая его о том, что
          пользователь произвел какое-либо действие или о том, что
          виджет изменил свое состояние <a name="AEN163" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#FTN.AEN163"><span class="footnote">[3]</span></a>
               . Например, экземпляры класса <tt class="CLASSNAME">QPushButton</tt> посылают приложению сигнал
               <tt class="METHODNAME">clicked()</tt>, когда
               пользователь нажимает на кнопку. Сигнал может быть
               "подключен" к функции-обработчику (такие
               функции-обработчики в Qt называются <span class="emphasis"><em class="EMPHASIS">слотами</em></span>).
               Таким образом, когда виджет посылает сигнал,
               автоматически вызывается слот. В нашем примере мы
               подключили сигнал <tt class="METHODNAME">clicked()</tt>,
               от кнопки, к слоту <tt class="METHODNAME">quit()</tt>,
               экземпляра класса <tt class="CLASSNAME">QApplication</tt>. Вызовы <tt class="METHODNAME">SIGNAL()</tt> и <tt class="METHODNAME">SLOT()</tt> -- это макроопределения, более
               подробно мы остановимся на них в следующей главе.<br>
          <br>

          <p>Теперь соберем приложение. Надеемся, что вы уже создали
          каталог <tt class="FILENAME">quit</tt> и разместили в нем
          файл <tt class="FILENAME">quit.cpp</tt>. Дайте команду
          <tt class="USERINPUT"><strong>qmake</strong></tt>, для
          создания файла проекта, а затем второй раз -- для создания
          <tt class="FILENAME">Makefile</tt>:</p>
          <pre class="SCREEN">qmake -project 
qmake quit.pro      
      
</pre>Теперь соберите приложение командой <tt class="USERINPUT">
          <strong>make</strong></tt> и запустите его. Если вы щелкнете
          по кнопке "Quit" или нажмете на клавиатуре клавишу
          "Пробел", то приложение завершит свою работу.<br>
          <br>

          <p>В следующем примере мы покажем как можно использовать
          сигналы и слоты для синхронизации двух виджетов. Эта
          программа предлагает пользователю ввести свой возраст.
          Сделать это можно либо с помощью кнопок управления счетчиком,
          либо с помощью ползунка.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.4.png"></p>

            <div class="CAPTION">
              <p>Рисунок 1.4. Приложение Age.</p>
            </div>
          </div><br>

          <p>Приложение содержит три виджета: <tt class="CLASSNAME">QSpinBox</tt>, <tt class="CLASSNAME">QSlider</tt>
          и <tt class="CLASSNAME">QHBox</tt> (область горизонтальной
          разметки). Главным виджетом приложения назначен <tt class="CLASSNAME">QHBox</tt>. Компоненты <tt class="CLASSNAME">QSpinBox</tt> и <tt class="CLASSNAME">QSlider</tt> помещены внутрь <tt class="CLASSNAME">QHBox</tt> и являются <span class="emphasis"><em class="EMPHASIS">подчиненными</em></span>, по
          отношению к нему.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.5.png"></p>

            <div class="CAPTION">
              <p>Рисунок 1.5. Виджеты приложения Age.</p>
            </div>
          </div><br>
          <pre class="SCREEN"> 1     #include &lt;qapplication.h&gt; 
 2      #include &lt;qhbox.h&gt;
 3      #include &lt;qslider.h&gt;
 4      #include &lt;qspinbox.h&gt;
 5      int main(int argc, char *argv[]) 
 6      { 
 7        QApplication app(argc, argv); 
 8        QHBox *hbox = new QHBox(0); 
 9        hbox-&gt;setCaption("Enter Your Age"); 
10        hbox-&gt;setMargin(6); 
11        hbox-&gt;setSpacing(6); 
12        QSpinBox *spinBox = new QSpinBox(hbox); 
13        QSlider *slider = new QSlider(Qt::Horizontal, hbox); 
14        spinBox-&gt;setRange(0, 130); 
15        slider-&gt;setRange(0, 130); 
16        QObject::connect(spinBox, SIGNAL(valueChanged(int)), 
17                         slider, SLOT(setValue(int))); 
18        QObject::connect(slider, SIGNAL(valueChanged(int)), 
19                         spinBox, SLOT(setValue(int))); 
20        spinBox-&gt;setValue(35); 
21        app.setMainWidget(hbox); 
22        hbox-&gt;show(); 
23        return app.exec(); 
24      }      
      
</pre>В строках с 8 по 11 создается и настраивается
          <tt class="CLASSNAME">QHBox</tt>. <a name="AEN203" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#FTN.AEN203"><span class="footnote">[4]</span></a>
               Чтобы вывести текст в заголовке окна, вызывается
               <tt class="METHODNAME">setCaption()</tt>. А затем
               устанавливается размер пустого пространства (6 пикселей)
               вокруг и между подчиненными виджетами.<br>
          <br>

          <p>В строках 12 и 13 создаются <tt class="CLASSNAME">QSpinBox</tt> и <tt class="CLASSNAME">QSlider</tt>, которым, в качестве владельца,
          назначается <tt class="CLASSNAME">QHBox</tt>.</p>

          <p>Не смотря на то, что мы явно не задали ни положение, ни
          размеры виджетов <tt class="CLASSNAME">QSpinBox</tt> и
          <tt class="CLASSNAME">QSlider</tt>, тем менее они очень
          аккуратно расположились внутри <tt class="CLASSNAME">QHBox</tt>. Собственно для этого и предназначен
          <tt class="CLASSNAME">QHBox</tt>. Он выполняет автоматическое
          размещение подчиненных виджетов, назначая им координаты
          размещения и размеры, в зависимости от их требований и
          собственных настроек. В Qt имеется много классов, подобных
          <tt class="CLASSNAME">QHBox</tt>, которые избавляют нас от
          рутинной работы по ручной подгонке положения и размеров
          визуальных компонентов.</p>

          <p>В строках 14 и 15 устанавливаются допустимые пределы
          изменения счетчика и ползунка. (Мы можем смело предположить,
          что возраст нашего пользователя едва ли превысит 130 лет.)
          Два вызова <tt class="METHODNAME">connect()</tt>, в строках с
          16 по 19 синхронизируют ползунок и счетчик, благодаря чему
          они всегда будут отображать одно и то же значение. Всякий
          раз, когда значение одного из виджетов изменяется, он
          посылает сигнал <tt class="METHODNAME">valueChanged( int
          )</tt>, который поступает в слот <tt class="METHODNAME">setValue( int )</tt> другого виджета.</p>

          <p>В строке 20 устанавливается первоначальное значение (35)
          счетчика. Когда это происходит, счетчик посылает сигнал
          <tt class="METHODNAME">valueChanged(int)</tt>, со значением
          входного аргумента, равным 35. Это число передается в слот
          <tt class="METHODNAME">setValue(int)</tt> виджета <tt class="CLASSNAME">QSlider</tt>, который устанавливает значение
          этого виджета равным 35. После этого уже <tt class="CLASSNAME">QSlider</tt> посылает сигнал <tt class="METHODNAME">valueChanged(int)</tt>, поскольку его значение
          только что изменилось, вызывая таким образом слот <tt class="METHODNAME">setValue(int)</tt> виджета <tt class="CLASSNAME">QSpinBox</tt>. Но на этот раз счетчик не посылает
          сигнал, поскольку его значение и так было равно 35. Таким
          образом предотвращается бесконечная рекурсия. Рисунок 1.6
          иллюстрирует эту ситуацию.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.6.png"></p>

            <div class="CAPTION">
              <p>Рисунок 1.6. Изменение одного значения вызывает
              изменение другого.</p>
            </div>
          </div><br>

          <p>В строке 22 <tt class="CLASSNAME">QHBox</tt> делается
          видимым (вместе со всеми подчиненными виджетами).</p>

          <p>Подход к формированию интерфейса в Qt очень прост для
          понимания и чрезвычайно гибок. В общем случае, программист
          выбирает необходимые ему виджеты, размещает их внутри
          областей выравнивания (layouts), которые в свою очередь
          принимают на себя обязанности по размещению виджетов, и
          настраивает свойства виджетов. На заключительном этапе
          устанавливаются взаимосвязи виджетов, через механизм сигналов
          и слотов, которые обусловливают поведение пользовательского
          интерфейса.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="USINGTHEREFERENCEDOCUMENTATION"></a>1.3. Работа со
          справочной системой.</h1>

          <p>Справочная система в Qt -- это пожалуй самый основной
          инструмент любого разработчика. Она описывает все классы и
          функции в этой библиотеке. (Документация к Qt 3.2 включает в
          себя описанее более 400 классов и 6000 функций.) В этой книге
          вы встретитесь с большим количеством классов и функций Qt, но
          далеко не со всеми. Поэтому совершенно необходимо, чтобы вы
          самостоятельно ознакомились со справочной системой Qt.</p>

          <div class="INFORMALTABLE">
            <a name="AEN239"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <thead style="background:black; color:white">
                <tr>
                  <th colspan="2" align="center" valign="middle">
                    <pre class="SCREEN">            
</pre>Стили виджетов
                    <pre class="SCREEN">            
</pre>
                  </th>
                </tr>
              </thead>

              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td colspan="2" align="center" valign="middle">
                    <pre class="SCREEN">            
</pre>Скриншоты, которые мы до сих пор видели, были получены в Windows
XP. Однако внешний вид виджетов изменяется, в зависимости от платформы,
на которой запускается приложение. С другой стороны, Qt в состоянии
эмулировать внешний вид любой из поддерживаемых платформ.
                    <pre class="SCREEN">            
</pre>
                  </td>
                </tr>

                <tr>
                  <td width="50%" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.7.1.png"></p>

                      <div class="CAPTION">
                        <p>Windows</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="50%" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.7.2.png"></p>

                      <div class="CAPTION">
                        <p>Motif</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td width="50%" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.7.3.png"></p>

                      <div class="CAPTION">
                        <p>MotifPlus</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="50%" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.7.4.png"></p>

                      <div class="CAPTION">
                        <p>CDE</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td width="50%" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.7.5.png"></p>

                      <div class="CAPTION">
                        <p>Platinum</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="50%" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.7.6.png"></p>

                      <div class="CAPTION">
                        <p>SGI</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td colspan="2" align="center" valign="top">
                    Рисунок 1.7. Стили, поддерживаемые Qt на любой
                    платформе.
                    <pre class="SCREEN"> 
            
</pre>
                  </td>
                </tr>

                <tr>
                  <td colspan="2" align="left" valign="top">
                    Пользователь может задать стиль отображения через
                    параметр командной строки <tt class="PARAMETER"><em>-style</em></tt>. Например, чтобы
                    запустить приложение Age со стилем отображения
                    Platinum в ОС Unix, нужно дать команду:
                    <pre class="SCREEN"> 
    ./age -style=Platinum        
            
</pre>
                  </td>
                </tr>

                <tr>
                  <td width="50%" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.8.1.png"></p>

                      <div class="CAPTION">
                        <p>Windows XP</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="50%" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.8.2.png"></p>

                      <div class="CAPTION">
                        <p>Mac</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td colspan="2" align="center" valign="top">
                    Рисунок 1.8. Платформо-зависимые стили.
                    <pre class="SCREEN"> 
            
</pre>
                  </td>
                </tr>
              </tbody>

              <tfoot style="background:black; color:white">
                <tr>
                  <th colspan="2" align="center" valign="middle">В отличие от других,
                      платформо-зависимые стили (Windows XP и Mac)
                      доступны только на этих платформах, т.к. в этом
                      случае отрисовка виджетов производится
                      графическим ядром операционной системы.</th>
                </tr>
              </tfoot>
            </table>
          </div>

          <p>Документация хранится в каталоге <tt class="FILENAME">doc\html</tt> в виде html-файлов. Для ее просмотра
          может использоваться любой web-браузер. Но Qt имеет свою
          утилиту просмотра документации -- <span class="emphasis"><em class="EMPHASIS">Qt Assistant</em></span>,
          которая предоставляет очень удобный способ навигации по
          справочнику, гораздо удобнее, чем этого можно добиться в
          web-браузере. Чтобы запустить утилиту -- выберите пункт
          <strong class="COMMAND">Qt 3.2.x|Qt Assistant</strong> в меню
          <strong class="COMMAND">"Пуск"</strong>
          операционной системы Windows или дайте команду <strong class="COMMAND">assistant</strong> в Unix.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.9.png"></p>

            <div class="CAPTION">
              <p>Рисунок 1.9. Внешний вид программы <span class="emphasis"><em class="EMPHASIS">Qt
              Assistant</em></span>.</p>
            </div>
          </div><br>

          <p>Ссылки в разделе <strong class="COMMAND">"API
          Reference"</strong> дают возможность навигации по
          классам различными способами. Так например, перейдя по ссылке
          <strong class="COMMAND">"All Classes"</strong> вы
          получите список всех классов библиотеки. По ссылке
          <strong class="COMMAND">"Main Classes"</strong> --
          только самые основные классы. В качестве упражнения
          попробуйте найти описания классов и функций, использовавшихся
          в нашем приложении. Обратите внимание: наследуемые методы
          описываются в базовых классах, например, описание класса
          <tt class="CLASSNAME">QPushButton</tt> не содержит метода
          <tt class="METHODNAME">show()</tt>, поскольку он наследуется
          от класса <tt class="CLASSNAME">QWidget</tt>. На рисунке ниже
          приводится диаграмма наследования для классов, использованных
          в нашем приложении:</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig1.10.png"></p>

            <div class="CAPTION">
              <p>Рисунок 1.10. Дерево наследования интересующих нас
              классов.</p>
            </div>
          </div><br>

          <p>Справочная документация для текущей версии Qt (и
          некоторых, более ранних версий) выкладывается в он-лайн по
          адресу: <a href="http://doc.trolltech.com/" target="_top">http://doc.trolltech.com/</a>. Здесь же вы
             найдете отдельные статьи из ежеквартальника <span class="emphasis"><em class="EMPHASIS">Qt Quarterly</em></span>,
             который рассылается всем коммерческим пользователям.</p>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER2"></a>Глава 2. Создание диалогов.</h1>

        <p>В этой главе мы расскажем -- как в Qt создаются диалоговые
        окна. Диалоговыми они называются потому, что обеспечивают
        способ общения (диалога) между пользователем и приложением.</p>

        <p>Диалоги предоставляют пользователям возможность что-то
        изменить, что-то задать, в соответствии с их предпочтениями. В
        большинстве своем, программы с графическим интерфейсом имеют
        главное окно, с полосой меню и панелью инструментов, и
        множество диалоговых окон, каждое из которых предназначено для
        обмена информацией с пользователем или вывода ее в определенном
        формате. Зачастую приложение может быть оформлено как одно
        диалоговое окно, которое напрямую взаимодействует с
        пользователем, получая от него команды и выполняя
        соответствующие им действия. Такие приложения называются
        <span class="emphasis"><em class="EMPHASIS">диалоговыми
        приложениями</em></span>. Примером диалогового приложения может
        служить программа-калькулятор.</p>

        <p>Для начала мы создадим диалоговое приложение
        "вручную", чтобы продемонстрировать основные принципы
        разработки диалогов. Затем покажем, как то же самое можно
        сделать значительно быстрее, с применением визуального
        построителя <span class="emphasis"><em class="EMPHASIS">Qt
        Designer</em></span>. С помощью этого инструмента разработка
        диалоговых окон проходит намного быстрее, к тому же с его
        помощью гораздо проще вносить изменения в визуальный дизайн во
        время доработки приложения.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SUBCLASSINGQDIALOG"></a>2.1.
          Создание дочернего класса от QDialog.</h1>

          <p>Наш первый пример -- это диалог поиска. Диалог будет
          реализован в виде класса, со своей собственной
          функциональностью. Это будет независимый компонент со своими
          сигналами и слотами.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.1. Диалог поиска в Linux (KDE).</p>
            </div>
          </div><br>

          <p>Исходные тексты приложения будут размещаться в двух
          файлах: <tt class="FILENAME">finddialog.h</tt> и <tt class="FILENAME">finddialog.cpp</tt>. Начнем с файла <tt class="FILENAME">finddialog.h</tt>.</p>
          <pre class="SCREEN"> 1 #ifndef FINDDIALOG_H 
 2 #define FINDDIALOG_H 
 3 #include &lt;qdialog.h&gt;
 4 class QCheckBox; 
 5 class QLabel; 
 6 class QLineEdit; 
 7 class QPushButton;      
      
</pre>Строки 1 и 2 (и 27) предотвращают множественное подключение
файла-заголовка.<br>
          <br>

          <p>В строке 3 подключается определение класса <tt class="CLASSNAME">QDialog</tt> -- базового для всех диалогов в Qt.
          <tt class="CLASSNAME">QDialog</tt> порожден от класса
          <tt class="CLASSNAME">QWidget</tt>.</p>

          <p>Строки с 4 по 7 -- это опережающие описания классов Qt,
          которые используются в нашем диалоге. <span class="emphasis"><em class="EMPHASIS">Опережающее
          описание</em></span> сообщает компилятору C++ о том, что этот
          класс существует, но подробности описания класса (обычно
          расположенного в отдельном заголовочном файле) здесь
          использоваться не будут. Ниже мы еще вернемся к этой
          теме.</p>

          <p>Теперь определим класс <tt class="CLASSNAME">FindDialog</tt>, указав в качестве родительского
          класса <tt class="CLASSNAME">QDialog</tt>:</p>
          <pre class="SCREEN"> 8 class FindDialog : public QDialog 
 9 { 
10     Q_OBJECT 
11 public: 
12     FindDialog(QWidget *parent = 0, const char *name = 0);      
      
</pre>Определение класса начинается с вызова макроса
          <tt class="PARAMETER"><em>Q_OBJECT</em></tt>. Это
          обязательное требование для всех классов, которые определяют
          свои собственные сигналы и слоты.<br>
          <br>

          <p>Далее следует типичный, для всех виджетов в Qt,
          конструктор -- <tt class="METHODNAME">FindDialog</tt>.
          Параметр <tt class="PARAMETER"><em>parent</em></tt> задает
          "владельца", т.е. виджет, на котором будет размещен
          данный компонент, а параметр <tt class="PARAMETER"><em>name</em></tt> -- имя (название) виджета.
          Параметр <tt class="PARAMETER"><em>name</em></tt> не является
          обязательным, в основном он используется для нужд отладки и
          тестирования.</p>
          <pre class="SCREEN">13 signals: 
14     void findNext(const QString &amp;str, bool caseSensitive); 
15     void findPrev(const QString &amp;str, bool caseSensitive);      
      
</pre>В секции <tt class="PARAMETER"><em>signals</em></tt> описаны два
сигнала, которые может посылать наше диалоговое окно, при нажатии на
кнопку Find. Если включен флажок "Search backward" (поиск в
обратном направлении), то посылается сигнал <tt class="METHODNAME">
          findPrev()</tt>, иначе -- <tt class="METHODNAME">findNext()</tt>.<br>
          <br>

          <p>Ключевое слово <tt class="PARAMETER"><em>signals</em></tt>, фактически является
          макроопределением. Препроцессор C++ преобразует его в
          стандартное представление C++ и только потом оно будет
          передано компилятору.</p>
          <pre class="SCREEN">16 private slots: 
17     void findClicked(); 
18     void enableFindButton(const QString &amp;text); 
19 private: 
20     QLabel *label; 
21     QLineEdit *lineEdit; 
22     QCheckBox *caseCheckBox;
23     QCheckBox *backwardCheckBox; 
24     QPushButton *findButton; 
25     QPushButton *closeButton; 
26 }; 
27 #endif      
      
</pre>В приватной секции класса мы объявили два слота. Они необходимы
для обеспечения взаимодействия с подчиненными виджетами, указатели на
которые описаны чуть ниже. Ключевое слово <tt class="PARAMETER">
          <em>slots</em></tt>, так же как и <tt class="PARAMETER"><em>signals</em></tt>, является
          макроопределением.<br>
          <br>

          <p>Поскольку все поля-переменные -- это указатели, нам нет
          нужды подключать заголовочные файлы, содержащие полные
          определения этих классов. Благодаря наличию опережающего
          описания, компилятор удовольствуется тем, что есть. Вместо
          опережающего описания классов мы могли бы подключить
          соответствующие заголовочные файлы (<tt class="FILENAME">&lt;qcheckbox.h&gt;, &lt;qlabel.h&gt;</tt> и
          т.д.), но это отрицательно скажется на скорости компиляции.
          Для маленьких приложений это не так заметно, но для больших
          проектов опережающее описание может дать существенный
          выигрыш.</p>

          <p>Перейдем к файлу <tt class="FILENAME">finddialog.cpp</tt>,
          который содержит реализацию класса <tt class="CLASSNAME">FindDialog</tt>:</p>
          <pre class="SCREEN"> 1 #include &lt;qcheckbox.h&gt;
 2 #include &lt;qlabel.h&gt;
 3 #include &lt;qlayout.h&gt;
 4 #include &lt;qlineedit.h&gt;
 5 #include &lt;qpushbutton.h&gt;
 
 6 #include "finddialog.h"      
      
</pre>Здесь подключаются заголовочные файлы с описаниями используемых
классов Qt. В строке 6 подключается определение нашего класса. Для
большинства классов Qt, их определения находятся в заголовочных файлах,
имена которых повторяют имя класса (все символы в именах файлов
переводятся в нижний регистр) и дополняются символами
          <tt class="FILENAME">.h</tt>.
          <pre class="SCREEN"> 7 FindDialog::FindDialog(QWidget *parent, const char *name) 
 8     : QDialog(parent, name) 
 9 { 
10     setCaption(tr("Find")); 
11     label = new QLabel(tr("Find &amp;what:"), this); 
12     lineEdit = new QLineEdit(this); 
13     label-&gt;setBuddy(lineEdit); 
14     caseCheckBox = new QCheckBox(tr("Match &amp;case"), this); 
15     backwardCheckBox = new QCheckBox(tr("Search &amp;backward"), this); 
16     findButton = new QPushButton(tr("&amp;Find"), this); 
17     findButton-&gt;setDefault(true); 
18     findButton-&gt;setEnabled(false); 
19     closeButton = new QPushButton(tr("Close"), this);      
      
</pre>В строке 8, конструктору базового класса передаются параметры
<tt class="PARAMETER"><em>parent</em></tt> и <tt class="PARAMETER">
          <em>name</em></tt>.<br>
          <br>

          <p>В строке 10 задается надпись, которая будет выводиться в
          заголовке окна -- "Find". Функция <tt class="FUNCTION">tr()</tt> определена в классе <tt class="CLASSNAME">QObject</tt> и любом другом подклассе, описание
          которого содержит вызов макроса <tt class="PARAMETER"><em>Q_OBJECT</em></tt>. Она выполняет трансляцию
          текста, передаваемого ей, на другие языки человеческого
          общения. Считается хорошим тоном, все строки, которые будут
          выводиться на экран, передавать через эту функцию, даже в том
          случае, если вы не планируете интернационализацию своего
          приложения. Проблемы интернационализации будут подробно
          освещены в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER15">Главе 15</a>.</p>

          <p>Затем, начиная со строки 11, создаются подчиненные
          виджеты. Здесь символ амперсанда ('&amp;')
          используется для обозначения клавиши быстрого доступа
          (акселератор). Например, в строке 16 создается кнопка Find,
          активировать которую можно нажатием на комбинацию клавиш
          Alt+F. Амперсанды так же могут использоваться для передачи
          фокуса ввода: в строке 11 создается метка, с акселератором
          (Alt+W), а в строке 13 метке назначается
          "дружественный" (buddy) компонент -- однострочное
          поле ввода. <span class="emphasis"><em class="EMPHASIS">"Дружественный"</em></span> виджет --
          это такой компонент, который будет получать фокус ввода при
          нажатии ускоряющей комбинации клавиш метки. Таким образом,
          когда пользователь нажмет комбинацию клавиш Alt+W
          (акселератор метки), то фокус ввода будет передан
          "дружественному" виджету, т.е. -- полю ввода.</p>

          <p>В строке 17, вызовом метода <tt class="METHODNAME">setDefault(true)</tt> <a name="AEN409" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#FTN.AEN409"><span class="footnote">[5]</span></a> ,
             назначается кнопка по-умолчанию. Кнопка по-умолчанию --
             это такая кнопка, которая будет активироваться при нажатии
             на клавишу Enter. В строке 18 накладывается запрет на
             кнопку Find. Когда виджет запрещен, он обычно отображается
             в серых тонах и не реагирует на действия пользователя.</p>
          <pre class="SCREEN">20 connect(lineEdit, SIGNAL(textChanged(const QString &amp;)), 
21     this, SLOT(enableFindButton(const QString &amp;))); 
22 connect(findButton, SIGNAL(clicked()), 
23     this, SLOT(findClicked())); 
24 connect(closeButton, SIGNAL(clicked()), 
25     this, SLOT(close()));      
      
</pre>Приватный слот <tt class="METHODNAME">enableFindButton(const
QString &amp;)</tt> вызывается при изменении содержимого поля ввода.
Приватный слот <tt class="METHODNAME">findClicked()</tt> вызывается,
когда пользователь щелкает по кнопке Find. Работа приложения
завершается после щелчка по кнопке Close. Слот <tt class="METHODNAME">
          close()</tt> наследуется от класса <tt class="CLASSNAME">QWidget</tt> и его поведение по-умолчанию --
          сокрытие виджета. Реализация слотов <tt class="METHODNAME">findClicked()</tt> и <tt class="METHODNAME">enableFindButton(const QString &amp;)</tt> будет
          приведена ниже.<br>
          <br>

          <p>Поскольку <tt class="CLASSNAME">QObject</tt> является
          одним из предков класса <tt class="CLASSNAME">FindDialog</tt>, то мы можем опустить префикс
          <tt class="METHODNAME">QObject::</tt> перед именем метода
          <tt class="METHODNAME">connect()</tt>.</p>
          <pre class="SCREEN">26     QHBoxLayout *topLeftLayout = new QHBoxLayout; 
27     topLeftLayout-&gt;addWidget(label); 
28     topLeftLayout-&gt;addWidget(lineEdit); 
29     QVBoxLayout *leftLayout = new QVBoxLayout; 
30     leftLayout-&gt;addLayout(topLeftLayout); 
31     leftLayout-&gt;addWidget(caseCheckBox); 
32     leftLayout-&gt;addWidget(backwardCheckBox); 
33     QVBoxLayout *rightLayout = new QVBoxLayout; 
34     rightLayout-&gt;addWidget(findButton); 
35     rightLayout-&gt;addWidget(closeButton); 
36     rightLayout-&gt;addStretch(1); 
37     QHBoxLayout *mainLayout = new QHBoxLayout(this); 
38     mainLayout-&gt;setMargin(11);
39     mainLayout-&gt;setSpacing(6); 
40     mainLayout-&gt;addLayout(leftLayout); 
41     mainLayout-&gt;addLayout(rightLayout); 
42 }      
      
</pre>На заключительном этапе выполняется выравнивание виджетов с
помощью <span class="emphasis"><em class="EMPHASIS">менеджеров
размещения</em></span>. Менеджер размещения (layout manager) -- это
объект, который управляет размерами и положением виджетов. Qt
предоставляет в наше распоряжение три менеджера размещения:
          <tt class="CLASSNAME">QHBoxLayout</tt> выравнивает виджеты по
          горизонтали, <tt class="CLASSNAME">QVBoxLayout</tt> -- по
          вертикали и <tt class="CLASSNAME">QGridLayouts</tt> -- по
          сетке. Менеджеры размещения (или, если хотите, менеджеры
          компоновки) могут содержать как отдельные виджеты, так и
          другие менеджеры размещения. Вкладывая друг в друга
          <tt class="CLASSNAME">QHBoxLayout</tt>, <tt class="CLASSNAME">QVBoxLayout</tt> и <tt class="CLASSNAME">QGridLayouts</tt>, в различных комбинациях, можно
          выстроить весьма замысловатый интерфейс диалога.<br>
          <br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.2. Компоновка диалога Find.</p>
            </div>
          </div><br>

          <p>В нашем приложении мы использовали два <tt class="CLASSNAME">QHBoxLayout</tt> и два <tt class="CLASSNAME">QVBoxLayout</tt>, как это показано на Рисунке
          2.2. Внешний менеджер компоновки (mainLayout) является
          главным, поскольку при создании ему был назначен, в качестве
          владельца, экземпляр класса <tt class="CLASSNAME">FindDialog</tt> -- <tt class="PARAMETER"><em>(this)</em></tt>. Он отвечает за размещение
          всех визуальных компонентов в области окна приложения.
          Оставшиеся 3 менеджера размещения являются подчиненными.
          Маленькая "пружинка", которая видна в правом нижнем
          углу рисунка -- это <span class="emphasis"><em class="EMPHASIS">распорка</em></span> (spacer). Она заполняет
          пустое пространство под кнопками Find и Close, заставляя их
          держаться в верхней части области выравнивания.</p>

          <p>Здесь есть один важный момент. Менеджеры компоновки не
          являются виджетами. Они порождены от класса <tt class="CLASSNAME">QLayout</tt>, который в свою очередь порожден от
          класса <tt class="CLASSNAME">QObject</tt>. На рисунке,
          контуры виджетов отрисованы сплошными линиями, а областей
          компоновки -- пунктирными, чтобы подчеркнуть различия,
          имеющиеся между ними. Во время работы приложения, менеджеры
          размещения (области выравнивания) не видны.</p>

          <p>Хотя менеджеры компоновки и не являются виджетами
          (визуальными компонентами), тем не менее они могут иметь как
          владельца, так и подчиненные компоненты. Понятия термина
          "владелец", у менеджера размещения и виджета,
          различаются. Если менеджер размещения встраивается в виджет
          (который передается менеджеру в качестве владельца), как это
          происходит в случае с <tt class="PARAMETER"><em>mainLayout</em></tt>, то он автоматически
          встраивается в этот виджет. Если менеджер создается без
          владельца (в данном случае это: <tt class="PARAMETER"><em>topLeftLayout</em></tt>, <tt class="PARAMETER"><em>leftLayout</em></tt> и <tt class="PARAMETER"><em>rightLayout</em></tt>), то он должен быть
          включен в состав другого менеджера, вызовом <tt class="METHODNAME">addLayout()</tt>.</p>

          <p>Механизм "владелец-подчиненный" реализован в
          классе <tt class="CLASSNAME">QObject</tt>, который является
          предком как для <tt class="CLASSNAME">QWidget</tt>, так и для
          <tt class="CLASSNAME">QLayout</tt>. Когда создается некий
          объект (виджет, менеджер компоновки или что-то еще), для
          которого явно указывается владелец, то он добавляется
          владельцем в свой список подчиненных компонентов. Когда
          владелец уничтожается, он проходит по списку подчиненных
          компонентов и уничтожает их одного за другим. Подчиненные
          компоненты, в свою очередь просматривают свои списки и
          уничтожают компоненты, подчиненные им и так до тех пор, пока
          дело не дойдет до компонентов, которые не имеют подчиненных
          объектов.</p>

          <p>Этот механизм упрощает управление памятью в приложении,
          снижая риск "утечки". Единственные объекты, которые
          необходимо уничтожать явно -- это те, которые были созданы
          оператором <tt class="FUNCTION">new</tt>, и не имеют
          владельца. Если первым удаляется подчиненный компонент, то Qt
          автоматически исключит его из списка владельца.</p>

          <p>Владелец имеет особое значение для виджетов. Подчиненные
          виджеты отображаются на экране внутри области, принадлежащей
          его владельцу. Когда удаляется какой-либо владелец, он не
          только удалит подчиненные объекты из памяти, но и сотрет их
          на экране.</p>

          <p>Когда один менеджер размещения вставляется в другой, с
          помощью функции <tt class="METHODNAME">addLayout()</tt>, то
          вложенный менеджер автоматически делается подчиненным
          объемлющему. В противоположность этому, когда в менеджер
          размещения вставляется виджет, вызовом <tt class="METHODNAME">addWidget()</tt>, то последний не меняет своего
          владельца.</p>

          <p>На рисунке 2.3 показано дерево
          "владелец-подчиненный" для приложения Find. Порядок
          взаимоотношений в этом дереве легко выводится из текста
          конструктора <tt class="METHODNAME">FindDialog</tt>,
          достаточно выделить строки, содержащие <tt class="METHODNAME">new</tt> и <tt class="METHODNAME">addLayout()</tt>. Важное замечание: Запомните,
          менеджеры размещения НЕ ЯВЛЯЮТСЯ владельцами виджетов,
          размещением которых они управляют.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.3. Дерево "владелец-подчиненный"
              диалога Find.</p>
            </div>
          </div><br>

          <p>В дополнение к менеджарам размещения, Qt предоставляет
          несколько <span class="emphasis"><em class="EMPHASIS">виджетов размещения</em></span>: <tt class="CLASSNAME">QHBox</tt> (с которым мы уже встречались в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER1">Главе 1</a>), <tt class="CLASSNAME">QVBox</tt> и <tt class="CLASSNAME">QGrid</tt>.
          Для своих подчиненных компонентов, эти классы выступают как в
          качестве владельцев так и в качестве менеджеров размещения.
          Для небольших приложений виджеты размещения более удобны, но
          они менее гибкие и требуют больший объем ресурсов, чем
          менеджеры.</p>

          <p>На этом мы заканчиваем рассмотрение реализации
          конструктора <tt class="METHODNAME">FindDialog</tt>.
          Поскольку подчиненные виджеты и менеджеры размещения
          создавались нами с помощью оператора <tt class="METHODNAME">new</tt>, то, казалось бы, возникает
          необходимость в написании деструктора, который удалил бы из
          памяти все, созданные нами компоненты, во время завершения
          приложения. Однако в этом нет необходимости, поскольку Qt
          автоматически сделает это во время уничтожения владельца,
          т.е. во время уничтожения класса <tt class="CLASSNAME">FindDialog</tt>.</p>

          <p>Перейдем к рассмотрению слотов:</p>
          <pre class="SCREEN">43 void FindDialog::findClicked() 
44 { 
45     QString text = lineEdit-&gt;text(); 
46     bool caseSensitive = caseCheckBox-&gt;isOn(); 

47     if (backwardCheckBox-&gt;isOn()) 
48         emit findPrev(text, caseSensitive); 
49     else 
50         emit findNext(text, caseSensitive); 
51 } 

52 void FindDialog::enableFindButton(const QString &amp;text) 
53 { 
54     findButton-&gt;setEnabled(!text.isEmpty()); 
55 }      
      
</pre>Слот <tt class="METHODNAME">findClicked()</tt> вызывается всякий
раз, когда пользователь щелкает мышкой по кнопке Find. Кнопка выдает
сигнал <tt class="METHODNAME">findPrev()</tt> или <tt class="METHODNAME">findNext()</tt>, в зависимости от состояния флажка Search
backward. Ключевое слово <tt class="PARAMETER"><em>emit</em></tt>
является макросом, определенным в библиотеке Qt.<br>
          <br>

          <p>Слот <tt class="METHODNAME">enableFindButton()</tt>
          вызывается, когда пользователь изменяет содержимое поля
          ввода. Если оно содержит какие-либо символы, то разрешается
          кнопка Find, в противном случае она запрещается.</p>

          <p>Реализацией этих двух слотов завершается разработка нашего
          диалога. Теперь создадим файл <tt class="FILENAME">main.cpp</tt>, в котором разместим текст основной
          программы для тестирования нашего виджета:</p>
          <pre class="SCREEN"> 1 #include &lt;qapplication.h&gt;
 
 2 #include "finddialog.h" 
 
 3 int main(int argc, char *argv[]) 
 4 { 
 5     QApplication app(argc, argv); 
 6     FindDialog *dialog = new FindDialog; 
 7     app.setMainWidget(dialog); 
 8     dialog-&gt;show(); 
 9     return app.exec(); 
10 }      
      
</pre>дадим команду <tt class="USERINPUT"><strong>qmake</strong></tt>,
как обычно. На этот раз, поскольку наш класс <tt class="CLASSNAME">
          FindDialog</tt> содержит вызов макроопределения <tt class="PARAMETER"><em>Q_OBJECT</em></tt>, утилита <tt class="USERINPUT"><strong>qmake</strong></tt> включит в <tt class="FILENAME">Makefile</tt> правила, вызывающие утилиту
          <tt class="USERINPUT"><strong>moc</strong></tt> -- компилятор
          метаобъектов.<br>
          <br>

          <p>Для корректной работы утилиты <tt class="USERINPUT"><strong>moc</strong></tt> необходимо, чтобы
          описание класса размещалось в заголовочном файле, отдельно от
          файла с реализацией. Код, сгенерированный утилитой <tt class="USERINPUT"><strong>moc</strong></tt> подключает этот
          заголовочный файл.</p>

          <p>Классы, в определении которых встречается макрос
          <tt class="PARAMETER"><em>Q_OBJECT</em></tt>, должны
          обрабатываться компилятором метаобъектов в обязательном
          порядке. На самом деле, это не такая большая проблема,
          поскольку <tt class="USERINPUT"><strong>qmake</strong></tt>
          автоматически добавит все необходимые правила в <tt class="FILENAME">Makefile</tt>. Но если вы забудете
          перегенерировать <tt class="FILENAME">Makefile</tt>, то
          линковщик будет "жаловаться" на отсутствие
          некоторых функций. Эти сообщения об ошибках могут порой
          вводить в заблуждение. Например, GCC выдает примерно такое
          предупреждение:</p>
          <pre class="SCREEN">   finddialog.o(.text+0x28): undefined reference to  
   FindDialog::QPaintDevice virtual table    
      
</pre>Visual C++ такое:
          <pre class="SCREEN">   finddialog.obj : error LNK2001: unresolved external symbol 
   "public:~virtual bool __thiscall FindDialog::qt_property(int, 
   int,class QVariant *)"      
      
</pre>Если это произошло, то перезапустите <tt class="USERINPUT">
          <strong>qmake</strong></tt> еще раз, чтобы обновить
          <tt class="FILENAME">Makefile</tt>, а затем пересоберите
          приложение.<br>
          <br>

          <p>Теперь запустите программу. Проверьте работу акселераторов
          Alt+W, Alt+C, Alt+B и Alt+F. Попробуйте "пройтись"
          по виджетам с помощью клавиши Tab. По-умолчанию, порядок
          навигации с помощью клавиши Tab, соответствует порядку, в
          котором создавались компоненты. Но он может быть изменен
          вызовом метода <tt class="METHODNAME">QWidget::setTabOrder()</tt>. Установку
          акселераторов и настройку порядка навигации по компонентам, с
          помощью клавиши Tab, можно считать дружественным жестом в
          сторону пользователей, которые не могут или не хотят
          пользоваться мышью. Удобное управление с клавиатуры высоко
          оценят опытные пользователи.</p>

          <p>В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">Главе 3</a> мы будем использовать
          наш диалог в реально работающем приложении. Там сигналы
          <tt class="METHODNAME">findPrev()</tt> и <tt class="METHODNAME">findNext()</tt> будут подключаться к
          соответствующим слотам.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SIGNALSANDSLOTSINDEPTH"></a>2.2.
          Сигналы и слоты.</h1>

          <p>Сигналы и слоты являются одним из фундаментальных
          механизмов в Qt. Он позволяет наладить обмен информацией
          между объектами, которые ничего не знают друг о друге. Мы уже
          пробовали присоединять сигналы к слотам, объявляли свои
          собственные сигналы и слоты, выполняли реализацию своих
          слотов и посылали свои сигналы. Теперь рассмотрим этот
          механизм поближе.</p>

          <p>По своей природе, слоты очень близки к обычным
          функциям-членам в языке C++. Они могут быть виртуальными, они
          могут подвергаться перегрузке, они могут быть публичными,
          защищенными или приватными и они могут вызываться напрямую,
          как и обычные функции-члены. Отличие состоит в том, что слот
          может быть подключен к сигналу. В этом случае, функция-слот
          вызывается автоматически всякий раз, когда посылается
          сигнал.</p>

          <p>Объявление <tt class="METHODNAME">connect()</tt> выглядит
          следующим образом:</p>
          <pre class="SCREEN">connect(sender, SIGNAL(signal), receiver, SLOT(slot));      
      
</pre>где <tt class="PARAMETER"><em>sender</em></tt> и
          <tt class="PARAMETER"><em>receiver</em></tt> -- это указатели
          на экземпляры класса <tt class="CLASSNAME">QObject</tt> (или
          его потомки), а <tt class="PARAMETER"><em>signal</em></tt> и
          <tt class="PARAMETER"><em>slot</em></tt> -- это сигнатуры
          функций. Макросы <tt class="PARAMETER"><em>SIGNAL()</em></tt>
          и <tt class="PARAMETER"><em>SLOT()</em></tt> по сути
          преобразуют свои аргументы в строки. В наших примерах мы до
          сих пор подключали к каждому из сигналов только один слот.
          Однако это не единственный способ.

          <ul>
            <li>
              <p><strong class="COMMAND">Один сигнал может быть
              подключен к нескольким слотам:</strong></p>
              <pre class="SCREEN">connect(slider, SIGNAL(valueChanged(int)), 
        spinBox, SLOT(setValue(int))); 
connect(slider, SIGNAL(valueChanged(int)), 
        this, SLOT(updateStatusBarIndicator(int)));          
            
</pre>Когда подается сигнал, то функции-слоты вызываются одна за
другой, в порядке подключения.<br>
              <br>
            </li>

            <li>
              <p><strong class="COMMAND">К одному слоту может быть
              подключено несколько сигналов:</strong></p>
              <pre class="SCREEN">connect(lcd, SIGNAL(overflow()), 
        this, SLOT(handleMathError())); 
connect(calculator, SIGNAL(divisionByZero()), 
        this, SLOT(handleMathError()));            
            
</pre>Когда посылается какой-либо из сигналов -- вызывается
функция-слот.<br>
              <br>
            </li>

            <li>
              <p><strong class="COMMAND">Сигнал может быть подключен к
              другому сигналу:</strong></p>
              <pre class="SCREEN">connect(lineEdit, SIGNAL(textChanged(const QString &amp;)), 
        this, SIGNAL(updateRecord(const QString &amp;)));            
            
</pre>Когда посылается первый сигнал, то вслед за ним подается и
второй. С точки зрения программы, соединение типа сигнал-сигнал ничем
не отличается от соединения типа сигнал-слот.<br>
              <br>
            </li>

            <li>
              <p><strong class="COMMAND">Связь между сигналом и слотом
              может быть разорвана:</strong></p>
              <pre class="SCREEN">disconnect(lcd, SIGNAL(overflow()), 
           this, SLOT(handleMathError()));            
            
</pre>Необходимость в этом возникает довольно редко, поскольку Qt сама
автоматически разрывает соединение, если один из объектов
уничтожается.<br>
              <br>
            </li>
          </ul>Соединяемые сигналы и слоты должны иметь идентичные
          сигнатуры (т.е. количество и типы входных аргументов):
          <pre class="SCREEN">connect(ftp, SIGNAL(rawCommandReply(int, const QString &amp;)), 
        this, SLOT(processReply(int, const QString &amp;)));      
      
</pre>Исключение составляет случай, когда сигнал имеет большее число
аргументов, чем слот. В этом случае "лишние" аргументы просто
не передаются в слот.<br>
          <br>

          <p>Если типы входных аргументов не совместимы, или сигнал или
          слот не определены, Qt выдаст предупреждение во время
          исполнения. Точно так же Qt выдаст предупреждение, если в
          сигнатуры сигналов или слотов включены имена аргументов (в
          методе <tt class="METHODNAME">connect()</tt>).</p>

          <div class="INFORMALTABLE">
            <a name="AEN555"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <thead style="background:black; color:white">
                <tr>
                  <th width="100%" align="center" valign="middle">
                    <pre class="SCREEN">            
</pre>Метаобъектная Система в библиотеке Qt
                    <pre class="SCREEN">            
</pre>
                  </th>
                </tr>
              </thead>

              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="100%" align="left" valign="top">
                    <p>Одно из самых значительных достижений Qt -- это
                    расширение возможностей языка C++ механизмом
                    создания независимых компонентов, которые могут
                    взаимодействовать между собой, не имея информации
                    друг о друге.</p>

                    <p>Этот механизм получил название <span class="emphasis"><em class="EMPHASIS">Meta Object
                    System</em></span> и предоставляет два ключевых
                    сервиса: сигналы-слоты и интроспекцию. Интроспекция
                    позволяет получать метаинформацию о потомках класса
                    <tt class="CLASSNAME">QObject</tt> во время
                    исполнения, включая список поддерживаемых сигналов,
                    слотов и имя класса объекта. Этот механизм также
                    реализует поддержку <span class="emphasis"><em class="EMPHASIS">свойств</em></span>
                    объектов (используются в <span class="emphasis"><em class="EMPHASIS">Qt
                    Designer</em></span>) и перевод текста (для нужд
                    интернационализации).</p>

                    <p>Стандарт C++ не обеспечивает возможность
                    получения динамической метаинформации, которая
                    необходима метаобъектной системе Qt. Поэтому данная
                    проблема была решена созданием дополнительного
                    инструмента <tt class="USERINPUT"><strong>moc</strong></tt>
                    (метаобъектный компилятор). Он собирает всю
                    необходимую информацию из классов <tt class="PARAMETER"><em>Q_OBJECT</em></tt> и делает ее
                    доступной через вызовы обычных функций языка C++,
                    что позволяет метаобъектной системе работать с
                    любым компилятором C++.</p>

                    <p>Механизм работает следующим образом:</p>

                    <ul>
                      <li>
                        <p>Макрос <tt class="PARAMETER"><em>Q_OBJECT</em></tt> объявляет
                        ряд функций, который должны присутствовать в
                        каждом потомке <tt class="CLASSNAME">QObject</tt>: <tt class="METHODNAME">metaObject()</tt>, <tt class="METHODNAME">className()</tt>, <tt class="METHODNAME">tr()</tt> и ряд других.</p>
                      </li>

                      <li>
                        <p>Утилита <tt class="USERINPUT"><strong>moc</strong></tt>
                        генерирует реализацию сигналов и функций,
                        объявленных макросом <tt class="PARAMETER"><em>Q_OBJECT</em></tt>.</p>
                      </li>

                      <li>
                        <p>Эти функции используются методами <tt class="METHODNAME">connect()</tt> и <tt class="METHODNAME">disconnect()</tt>.</p>
                      </li>
                    </ul><br>
                    <br>

                    <p>Все действия выполняются автоматически,
                    утилитами <tt class="USERINPUT"><strong>qmake</strong></tt> и
                    <tt class="USERINPUT"><strong>moc</strong></tt>,
                    так что вы довольно редко будете вспоминать об
                    этом. Но если вас одолевает любопытство --
                    загляните в исходные файлы, созданные <tt class="USERINPUT"><strong>moc</strong></tt>, и посмотрите
                    -- что да как.</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>До сих пор мы использовали сигналы и слоты исключительно с
          виджетами. Однако, этот механизм реализован непосредственно в
          классе <tt class="CLASSNAME">QObject</tt> и область его
          применения не ограничивается графическим интерфейсом. Он
          может использоваться любым классом, наследником <tt class="CLASSNAME">QObject</tt>:</p>
          <pre class="SCREEN">class Employee : public QObject
{
    Q_OBJECT
public:
    Employee() { mySalary = 0; }
    int salary() const { return mySalary; }
public slots:
    void setSalary(int newSalary);
signals:
    void salaryChanged(int newSalary);
private:
    int mySalary;
};
void Employee::setSalary(int newSalary)
{
    if (newSalary != mySalary) {
         mySalary = newSalary;
         emit salaryChanged(mySalary);
    }
}
      
</pre><br>
          <br>

          <p>Обратите внимание на реализацию слота <tt class="METHODNAME">setSalary()</tt>. Сигнал <tt class="METHODNAME">salaryChanged()</tt> посылается только в том
          случае, когда <tt class="COMPUTEROUTPUT">newSalary !=
          mySalary</tt>. Такой способ предотвращает попадание в
          бесконечный цикл при наличии обратной связи с другим
          объектом.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="RAPIDDIALOGDESIGN"></a>2.3.
          Быстрая разработка диалогов.</h1>

          <p>Qt разрабатывалась так, чтобы можно было писать код
          программы вручную без особого напряжения. Тем не менее,
          <span class="emphasis"><em class="EMPHASIS">Qt
          Designer</em></span> еще больше расширяет возможности
          программиста, предоставляя ему возможность визуального
          дизайна.</p>

          <p>В этом разделе мы, с помощью <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>,
          напишем диалог Go-to-Cell ("Перейти к ячейке"),
          показанный на рисунке 2.4. Совершенно неважно, как
          разрабатывается диалог -- вручную ли, или с помощью
          <span class="emphasis"><em class="EMPHASIS">Qt
          Designer</em></span>, всегда выполняется одна и та же
          последовательность действий:</p>

          <ul>
            <li>
              <p>Создаются и инициализируются подчиненные виджеты.</p>
            </li>

            <li>
              <p>Подчиненные виджеты вставляются в менеджеры
              размещения.</p>
            </li>

            <li>
              <p>Настраивается порядок навигации по виджетам клавишей
              Tab.</p>
            </li>

            <li>
              <p>Устанавливаются соединения сигнал-слот</p>
            </li>

            <li>
              <p>Реализуются дополнительные слоты диалога, если это
              необходимо.</p>
            </li>
          </ul><br>
          <br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.4.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.4. Диалог перехода к ячейке.</p>
            </div>
          </div><br>

          <p>Чтобы запустить <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>, выберите пункт
          <strong class="COMMAND">Qt 3.2.x|Qt Designer</strong> в меню
          <strong class="COMMAND">"Пуск"</strong> -- в ОС
          Windows или дайте команду <strong class="COMMAND">designer</strong> -- в Unix. После того как
          программа запустится, она предложит на выбор список шаблонов.
          Щелкните по шаблону <span class="emphasis"><em class="EMPHASIS">"Dialog"</em></span> и нажмите кнопку
          OK. После этого перед вами должна появиться заготовка
          будущего окна диалога с именем "Form1".</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.5.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.5. <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span> с заготовкой окна
              диалога.</p>
            </div>
          </div><br>

          <p>Для начала разместим виджеты на форме. На инструментальной
          панели, слева, щелкните по компоненту TextLabel, затем
          щелкните по форме -- в результате на форме появится компонент
          "метка". Аналогичным образом разместите на форме
          одно поле ввода (LineEdit), одну горизонтальную распорку
          (Spacer) и две кнопки (PushButton). Разместите их так, чтобы
          у вас получилось нечто похожее на рисунок 2.6. Не тратьте
          слишком много времени на позиционирование виджетов. Мы все
          равно будем использовать менеджеры размещения, которые
          выполнят эту работу за нас.</p>

          <p>Распорка (spacer) отображается на заготовке в виде синей
          пружинки. Во время работы уже готовой программы распорки не
          будут отображаться.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.6.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.6. Внешний вид заготовки формы с
              виджетами.</p>
            </div>
          </div><br>

          <p>Установите свойства для каждого из виджетов, используя
          <span class="emphasis"><em class="EMPHASIS">Редактор
          свойств</em></span>, расположенный в правой части главного
          окна <span class="emphasis"><em class="EMPHASIS">Qt
          Designer</em></span>.</p>

          <ol type="1">
            <li>
              <p>Щелкните по компоненту TextLabel и запишите в его
              свойство <tt class="PARAMETER"><em>name</em></tt> строку
              "label", а в свойство <tt class="PARAMETER"><em>text</em></tt> -- "&amp;Cell
              Location:".</p>
            </li>

            <li>
              <p>Щелкните по компоненту LineEdit и запишите в свойство
              <tt class="PARAMETER"><em>name</em></tt> строку
              "lineEdit".</p>
            </li>

            <li>
              <p>Для распорки запишите в свойство <tt class="PARAMETER"><em>orientation</em></tt>
              "Horizontal".</p>
            </li>

            <li>
              <p>Для первой кнопки запишите в свойство <tt class="PARAMETER"><em>name</em></tt> строку
              "okButton", в свойство <tt class="PARAMETER"><em>enabled</em></tt> -- "False", в
              свойство <tt class="PARAMETER"><em>default</em></tt> --
              "True" и в свойство <tt class="PARAMETER"><em>text</em></tt> -- "OK".</p>
            </li>

            <li>
              <p>Для второй кнопки. Запишите в свойство <tt class="PARAMETER"><em>name</em></tt> строку
              "cancelButton", а в свойство <tt class="PARAMETER"><em>text</em></tt> -- в "OK".</p>
            </li>

            <li>
              <p>Щелкните в любом свободном месте формы и запишите в
              свойство <tt class="PARAMETER"><em>name</em></tt> строку
              "GoToCellDialog", а в свойство <tt class="PARAMETER"><em>caption</em></tt> -- "Go to
              Cell".</p>
            </li>
          </ol>

          <p>Но это еще не все, нам нужно назначить дружественный
          компонент для метки, который будет реагировать на акселератор
          Alt+C. На данный момент метка отображается как
          "&amp;Cell Location:". Выберите пункт меню
          <strong class="COMMAND">Tools|Set Buddy</strong> (курсор мыши
          приобретет вид крестика). Затем поместите указатель мыши на
          метку, нажмите левую кнопку и, удерживая ее в нажатом
          положении, переместите указатель мыши на компонент LineEdit.
          Затем отпустите кнопку мыши. Изображение метки изменится --
          символ амперсанда исчезнет, а первый символ метки приобретет
          знак подчеркивания. В принципе, то же самое можно сделать
          внутри редактора свойств, установкой свойства <tt class="PARAMETER"><em>buddy</em></tt> метки.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.7.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.7. Внешний вид заготовки формы после
              установки свойств виджетов.</p>
            </div>
          </div><br>

          <p>Следующий шаг -- размещение виджетов на форме с помощью
          менеджеров компоновки:</p>

          <ol type="1">
            <li>
              <p>Щелкните мышью по метке. Нажмите клавишу Shift и
              удерживая ее -- щелкните по полю ввода. Оба компонента
              окажутся выделенными. Теперь выберите пункт меню
              <strong class="COMMAND">Layout|Lay Out
              Horizontally</strong>.</p>
            </li>

            <li>
              <p>Щелкните мышью по распорке. Нажмите клавишу Shift и
              удерживая ее -- щелкните сначала по кнопке
              "OK", а затем по кнопке "Cancel".
              Теперь выберите пункт меню <strong class="COMMAND">Layout|Lay Out Horizontally</strong>.</p>
            </li>

            <li>
              <p>Щелкните по свободному пространству на форме и
              выберите пункт меню <strong class="COMMAND">Layout|Lay
              Out Vertically</strong>.</p>
            </li>

            <li>
              <p>Выберите пункт меню <strong class="COMMAND">Layout|Adjust Size</strong>.</p>
            </li>
          </ol>

          <p>Красные контуры областей выравнивания, которые сейчас
          видны на заготовке, во время работы программы отображаться не
          будут.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.8.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.8. Внешний вид заготовки формы после
              настройки размещения компонентов.</p>
            </div>
          </div><br>

          <p>Теперь выберите пункт меню <strong class="COMMAND">Tools|Tab Order</strong>. На каждом из виджетов,
          которые могут принимать фокус, появятся цифры в синих
          кружочках. Щелчками мыши по компонентам установите желаемый
          порядок навигации клавишей Tab и нажмите Esc.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.9.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.9. Установка порядка навигации клавишей
              Tab.</p>
            </div>
          </div><br>

          <p>На этом дизайн внешнего вида формы можно считать
          завершенным. Теперь перейдем к настройке функциональной части
          -- свяжем сигналы и слоты и создадим свой слот. Выберите
          пункт меню <strong class="COMMAND">Edit|Connections</strong>,
          перед вами откроется окно редактора связей:</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.10.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.10. Окно редактора связей после установки
              всех соединений.</p>
            </div>
          </div><br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.11.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.11. Окно редактора слотов.</p>
            </div>
          </div><br>

          <p>Для начала создадим новый слот: щелкните по кнопке
          <strong class="COMMAND">Edit Slots...</strong>. Перед вами
          откроется окно редактора слотов (см. рис. 2.11). Создайте
          приватный слот с именем <tt class="METHODNAME">enableOkButton()</tt>.</p>

          <p>Затем необходимо настроить три соединения. Чтобы создать
          соединение -- щелкните по кнопке "New" и установите
          поля Sender, Signal, Receiver и Slot, выбирая требуемые
          значения из выпадающих списков в каждом из них. У вас должно
          получиться следующее:</p>
          <pre class="SCREEN">okButton      clicked()                     GoToCellDialog   accept()
cancelButton  clicked()                     GoToCellDialog   reject()      
lineEdit      textChanged(const QString &amp;)  GoToCellDialog   enableOkButton()
      
</pre><br>
          <br>

          <p>Чтобы посмотреть, как будет выглядеть окно диалога во
          время работы программы -- выберите пункт меню <strong class="COMMAND">Preview|Preview Form</strong>. Проверьте порядок
          навигации клавишей Tab. Проверьте работу акселератора Alt+C
          (поле ввода должно получить фокус ввода). Нажмите кнопку
          <strong class="COMMAND">Cancel</strong>, чтобы закрыть
          окно.</p>

          <p>Сохраните результаты работы в файле <tt class="FILENAME">gotocelldialog.ui</tt> в каталоге <tt class="FILENAME">gotocell</tt> и создайте файл <tt class="FILENAME">main.cpp</tt>, в том же каталоге, с помощью
          обычного текстового редактора:</p>
          <pre class="SCREEN">#include &lt;qapplication.h&gt;
#include "gotocelldialog.h"
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    GoToCellDialog *dialog = new GoToCellDialog;
    app.setMainWidget(dialog);
    dialog-&gt;show();
    return app.exec();
}
      
</pre>Создайте файл проекта и <tt class="FILENAME">Makefile</tt>
утилитой <tt class="USERINPUT"><strong>qmake</strong></tt>
          (<tt class="USERINPUT"><strong>qmake -project; qmake
          gotocell.pro</strong></tt>). Утилита <tt class="USERINPUT"><strong>qmake</strong></tt> сама обнаружит файл
          <tt class="FILENAME">gotocelldialog.ui</tt> и добавит в
          <tt class="FILENAME">Makefile</tt> все необходимые правила по
          созданию <tt class="FILENAME">gotocelldialog.h</tt> и
          <tt class="FILENAME">gotocelldialog.cpp</tt>. Все <tt class="FILENAME">.ui</tt> файлы преобразуются в код C++ с помощью
          утилиты <tt class="USERINPUT"><strong>uic</strong></tt> (User
          Interface Compiler -- Компилятор Пользовательских
          Интерфейсов).<br>
          <br>

          <p>Вся прелесть <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>-а состоит в том, что вы
          можете свободно изменять дизайн формы без необходимости
          вторгаться в исходный код на C++. Когда разработка дизайна
          ведется в тексте программы (вручную) то это может отнять
          довольно значительное время. <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>
          сохранит ваши силы и время.</p>

          <p>Если теперь запустить программу, то вы заметите:</p>

          <ul>
            <li>
              <p>Кнопка "OK" всегда остается запрещенной.</p>
            </li>

            <li>
              <p>Поле ввода принимает не только те символы, из которых
              может состоять номер искомой ячейки, но и любые
              другие.</p>
            </li>
          </ul>Мы должны решить эти проблемы.<br>
          <br>

          <p>Щелкните дважды по свободному пространству на форме, чтобы
          вызвать редактор исходного кода. В окне редактора добавьте
          следующие строки:</p>
          <pre class="SCREEN">#include &lt;qvalidator.h&gt;
void GoToCellDialog::init()
{
    QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");
    lineEdit-&gt;setValidator(new QRegExpValidator(regExp, this));
}
void GoToCellDialog::enableOkButton()
{
    okButton-&gt;setEnabled(lineEdit-&gt;hasAcceptableInput());
}
      
</pre>Функция <tt class="METHODNAME">init()</tt> автоматически
вызывается конструктором формы (конструктор генерируется утилитой
<tt class="USERINPUT"><strong>uic</strong></tt>). Она настраивает
проверку корректности ввода для LineEdit. Qt предоставляет три класса,
выполняющих проверку на корректность: <tt class="CLASSNAME">QIntValidator, QDoubleValidator</tt> и <tt class="CLASSNAME">QRegExpValidator</tt>. Для своих нужд мы будем использовать
последний, который будет выполнять проверку на основе регулярного
выражения: "[A-Za-z][1-9][0-9]{0,2}". Это выражение означает:
"Позволить ввод одного алфавитного символа в верхнем или нижнем
регистре, за которым должна следовать одна цифра, в диапазоне от 1 до
9, за которой может следовать до двух цифр, в диапазоне от 0 до
9".<br>
          <br>

          <p>Передавая аргумент <tt class="PARAMETER"><em>this</em></tt> (в вызов конструктора
          <tt class="METHODNAME">QRegExpValidator()</tt>), мы делаем
          объект класса <tt class="CLASSNAME">QRegExpValidator</tt>
          подчиненным, по отношению к <tt class="CLASSNAME">GoToCellDialog</tt>. Таким образом мы снимаем с
          себя ответственность за удаление этого объекта из памяти по
          завершении работы приложения.</p>

          <p>Слот <tt class="METHODNAME">enableOkButton()</tt>
          разрешает или запрещает кнопку "OK", в зависимости
          от того, насколько правильный номер ячейки содержится в поле
          ввода. Для проверки правильности используется функция
          <tt class="METHODNAME">QLineEdit::hasAcceptableInput()</tt>,
          которая обращается к объекту класса <tt class="CLASSNAME">QRegExpValidator</tt>, созданному в функции
          <tt class="CLASSNAME">init()</tt>.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.12.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.12. Окно редактора исходного кода.</p>
            </div>
          </div><br>

          <p>После этого опять сохраните диалог. <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>
          сохранит оба файла -- и <tt class="FILENAME">gotocelldialog.ui</tt>, и <tt class="FILENAME">gotocelldialog.ui.h</tt>. Пересоберите приложение
          и запустите его. Введите в поле ввода строку "A12"
          -- кнопка "OK" перейдет в разрешенное состояние.
          Попробуйте набрать произвольный текст и понаблюдайте за тем,
          как работает проверка корректности ввода. Нажмите кнопку
          "Cancel", чтобы завершить работу программы.</p>

          <p>В этом примере мы создали диалог с помощью <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span> и
          добавили некоторый код, с помощью редактора исходного кода
          <span class="emphasis"><em class="EMPHASIS">Qt
          Designer</em></span>-а. Интерфейсная часть диалога была
          сохранена в файле <tt class="FILENAME">gotocelldialog.ui</tt>
          (по сути файл формата XML), а исходный текст -- в файле
          <tt class="FILENAME">gotocelldialog.ui.h</tt>. Это очень
          удобно, поскольку <tt class="FILENAME">gotocelldialog.ui.h</tt> можно править в любом
          текстовом редакторе.</p>

          <p>Альтернативный подход заключается в разработке формы с
          помощью <span class="emphasis"><em class="EMPHASIS">Qt
          Designer</em></span> (как обычно), а затем создается
          дополнительный класс, порожденный от класса формы, в котором
          реализуется вся необходимая функциональность. Например, для
          нашего диалога Go-to-Cell можно было бы создать класс
          <tt class="CLASSNAME">GoToCellDialogImpl</tt>, как наследник
          класса <tt class="CLASSNAME">GoToCellDialog</tt> и
          реализовать в нем все необходимые функции. В результате
          такого подхода, новый заголовочный файл должен получиться
          таким:</p>
          <pre class="SCREEN">#ifndef GOTOCELLDIALOGIMPL_H
#define GOTOCELLDIALOGIMPL_H
#include "gotocelldialog.h"
class GoToCellDialogImpl : public GoToCellDialog
{
    Q_OBJECT
public:
    GoToCellDialogImpl(QWidget *parent = 0, const char *name = 0);
private slots:
    void enableOkButton();
};
#endif
      
</pre>А файл с реализацией:
          <pre class="SCREEN">#include &lt;qlineedit.h&gt;
#include &lt;qpushbutton.h&gt;
#include &lt;qvalidator.h&gt;
#include "gotocelldialogimpl.h"
GoToCellDialogImpl::GoToCellDialogImpl(QWidget *parent,
                                       const char *name)
    : GoToCellDialog(parent, name)
{
    QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");
    lineEdit-&gt;setValidator(new QRegExpValidator(regExp, this));
}
void GoToCellDialogImpl::enableOkButton()
{
    okButton-&gt;setEnabled(lineEdit-&gt;hasAcceptableInput());
}
      
</pre>Некоторые разработчики, исповедующие такой подход, наверняка
назвали бы базовый класс как: <tt class="CLASSNAME">GoToCellDialogBase</tt>, а класс реализации:
          <tt class="CLASSNAME">GoToCellDialog</tt>.<br>
          <br>

          <p>Создание классов-наследников может быть упрощено с помощью
          утилиты <tt class="USERINPUT"><strong>uic</strong></tt> и
          набора дополнительных аргументов командной строки. Так,
          например, утилита <tt class="USERINPUT"><strong>uic</strong></tt>, с ключом <tt class="PARAMETER"><em>-subdecl</em></tt>, создаст скелетон
          заголовочного файла, а с ключом <tt class="PARAMETER"><em>-subimpl</em></tt> -- соответствующий файл
          реализации.</p>

          <p>В данной книге мы будем работать только с файлами
          <tt class="FILENAME">.ui.h</tt>, поскольку это наиболее
          общеупотребимая практика, а создание дочерних классов, с
          помощью <tt class="USERINPUT"><strong>uic</strong></tt>,
          довольно простая задача. Чтобы поглубже разобраться в
          различиях этих двух подходов, рекомендуем прочитать главу
          "Designer Approach" в справочном руководстве,
          поставляемом вместе с <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>. Кроме того, прочитайте
          главу "Creating Dialogs", где показывается, как
          можно использовать вкладку "Members" для создания
          полей (переменных-членов) в классе формы.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SHAPECHANGINGDIALOGS"></a>2.4.
          Диалоги с изменяющимся внешним видом.</h1>

          <p>Мы рассмотрели примеры создания диалогов, которые никогда
          не меняют свой внешний вид. В некоторых случаях желательно
          иметь диалоги, которые могут динамически изменять свое
          представление. Наиболее часто на практике встречаются
          расширяемые диалоги и многостраничные диалоги. Оба вида
          диалогов могут быть созданы как в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>, так
          и в результате ручного кодирования.</p>

          <p>Расширяемые диалоги, обычно выводятся на экран в
          сокращенном варианте, но дают пользователю возможность
          выбирать между сокращенным и расширенным режимом
          представления информации. Расширяемые диалоги как правило
          используются в тех случаях, когда необходимо сокрыть
          дополнительные сведения, которые не являются обязательными и
          пользователь явно не выразил свое желание видеть их. В этом
          разделе мы разберем процесс создания расширяемого диалога,
          показанного на рисунке 2.13, с помощью <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.13.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.13. Диалог сортировки в простом и
              расширенном режимах.</p>
            </div>
          </div><br>

          <p>Это диалог сортировки, используемый в электронных
          таблицах. Он появляется, когда пользователь пытается
          отсортировать данные по одному или нескольким столбцам. В
          сокращенном представлении диалог позволяет выбрать столбец и
          порядок сортировки, в расширенном варианте добавляется
          возможность указать еще два столбца и порядок сортировки по
          каждому из них. Кнопка "More" позволяет переходить
          из сокращенного режима -- в расширенный и обратно.</p>

          <p>Мы создадим диалог в его расширенном виде, а потом, во
          время исполнения, будем скрывать дополнительные виджеты,
          чтобы обеспечить краткую форму диалога.</p>

          <ol type="1">
            <li>
              <p>Положите на заготовку формы GroupBox, два TextLabel,
              два ComboBox и одну горизонтальную распорку.</p>
            </li>

            <li>
              <p>"Растяните" GroupBox побольше, ухватив
              мышкой за правый нижний его угол.</p>
            </li>

            <li>
              <p>Разместите виджеты внутри GroupBox-а примерно так, как
              показано на рисунке 2.14(а)</p>
            </li>

            <li>
              <p>Ухватив мышкой за правый край второго ComboBox-а,
              сделайте его примерно в два раз больше первого.</p>
            </li>

            <li>
              <p>Запишите в свойство <tt class="PARAMETER"><em>title</em></tt>, GroupBox-а, строку
              "&amp;Primary Key". В свойство <tt class="PARAMETER"><em>text</em></tt> первой метки --
              "Column:", второй метки --
              "Order:".</p>
            </li>

            <li>
              <p>Щелкните мышкой дважды по первому ComboBox. Перед вами
              появится окно редактора, в котором добавьте один элемент
              с текстом "None".</p>
            </li>

            <li>
              <p>Щелкните мышкой дважды по второму ComboBox и добавьте
              элементы "Ascending" и
              "Descending".</p>
            </li>

            <li>
              <p>Теперь скомпонуем виджеты внутри GroupBox, для этого,
              щелкните по GroupBox и выберите пункт меню <strong class="COMMAND">Layout|Lay Out in a Grid</strong>. В результате
              вы должны получить нечто похожее на рисунок 2.14(б).</p>
            </li>
          </ol><br>
          <br>

          <div class="INFORMALTABLE">
            <a name="AEN834"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="50%" align="left" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.14a.png"></p>

                      <div class="CAPTION">
                        <p>Рисунок 2.14(а). До выполнения
                        компоновки.</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="50%" align="left" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.14b.png"></p>

                      <div class="CAPTION">
                        <p>Рисунок 2.14(б). После выполнения
                        компоновки.</p>
                      </div>
                    </div><br>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>Если компоновка выполнилась не так как надо или вы
          допустили какую нибудь ошибку, вы всегда можете выбрать пункт
          меню <strong class="COMMAND">Edit|Undo</strong> и отменить
          произведенное действие. После чего можете повторить
          попытку.</p>

          <p>Теперь добавим группы виджетов для расширенного
          представления:</p>

          <ol type="1">
            <li>
              <p>Растяните форму диалога, чтобы хватило места для
              дополнительных виджетов. Выберите GroupBox и скопируйте
              его в буфер обмена, выбрав пункт меню <strong class="COMMAND">Edit|Copy</strong>. Вставьте новые группы
              виджетов, дважды выбрав пункт меню <strong class="COMMAND">Edit|Paste</strong>. Переместите новые
              GroupBox-ы на свои места. Измените у них свойство
              <tt class="PARAMETER"><em>title</em></tt>.</p>
            </li>

            <li>
              <p>Создайте кнопки "OK", "Cancel" и
              "More".</p>
            </li>

            <li>
              <p>Для кнопки "OK" установите свойство
              <tt class="PARAMETER"><em>default</em></tt> в TRUE.</p>
            </li>

            <li>
              <p>Добавьте две вертикальные распорки.</p>
            </li>

            <li>
              <p>Расположите кнопки "OK", "Cancel"
              и "More" по вертикали. Переместите одну из
              распорок так, чтобы она встала между кнопками
              "Cancel" и "More". Выделите все
              четыре элемента и выберите пункт меню <strong class="COMMAND">Layout|Lay Out Vertically</strong>.</p>
            </li>

            <li>
              <p>Вторую распорку переместите так, чтобы она встала
              между первым и вторым GroupBox.</p>
            </li>

            <li>
              <p>Установите свойство <tt class="PARAMETER"><em>sizeHint</em></tt> у вертикальных
              распорок в значение (20, 10).</p>
            </li>

            <li>
              <p>Разместите виджеты так, как это показано нарисунке
              2.15(а).</p>
            </li>

            <li>
              <p>Выберите пункт меню <strong class="COMMAND">Layout|Lay
              Out in a Grid</strong>. У вас должна получиться
              заготовка, показанная на рисунке 2.15(б)</p>
            </li>
          </ol><br>
          <br>

          <div class="INFORMALTABLE">
            <a name="AEN881"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="50%" align="left" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.15a.png"></p>

                      <div class="CAPTION">
                        <p>Рисунок 2.15(а). До выполнения
                        компоновки.</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="50%" align="left" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.15b.png"></p>

                      <div class="CAPTION">
                        <p>Рисунок 2.15(б). После выполнения
                        компоновки.</p>
                      </div>
                    </div><br>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>В результате такого размещения мы получили
          "сетку" из двух колонок и четырех строк -- всего
          восемь ячеек. Первый GroupBox, левая вертикальная распорка,
          второй и третий GroupBox занимают по одной ячейке. Кнопки
          "OK", "Cancel", "More" и правая
          вертикальная распорка занимают две ячейки. И вправом нижнем
          углу диалога у нас остаются две пустых ячейки. Если у вас не
          получилась такая компоновка виджетов -- отмените ее и
          повторите попытку.</p>

          <p>Проверьте свойство формы <tt class="PARAMETER"><em>resizeMode</em></tt>. Оно должно быть
          установлено как "Fixed", благодаря чему
          пользователь не сможет растягивать окно диалога. Тогда, всю
          ответственность за размер окна диалога возьмут на себя
          менеджеры размещения, изменяя его в случае, когда подчиненные
          виджеты показываются или скрываются. Это гарантирует показ
          окна диалога с оптимальными размерами.</p>

          <p>Дайте форме имя "SortDialog" и установите
          свойство <tt class="PARAMETER"><em>caption</em></tt> в
          "Sort". Дайте имена виджетам, в соответствии с
          рисунком 2.16.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.16.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.16. Имена виджетов на форме.</p>
            </div>
          </div><br>

          <p>В заключение соединим сигналы и слоты:</p>

          <ol type="1">
            <li>
              <p>Соедините <tt class="PARAMETER"><em>okButton
              clicked()</em></tt> с <tt class="PARAMETER"><em>SortDialog accept()</em></tt></p>
            </li>

            <li>
              <p>Соедините <tt class="PARAMETER"><em>cancelButton
              clicked()</em></tt> с <tt class="PARAMETER"><em>SortDialog reject()</em></tt></p>
            </li>

            <li>
              <p>Соедините <tt class="PARAMETER"><em>moreButton
              toggled(bool)</em></tt> с <tt class="PARAMETER"><em>secondaryGroupBox
              setShown(bool)</em></tt></p>
            </li>

            <li>
              <p>Соедините <tt class="PARAMETER"><em>moreButton
              toggled(bool)</em></tt> с <tt class="PARAMETER"><em>tertiaryGroupBox
              setShown(bool)</em></tt></p>
            </li>
          </ol><br>
          <br>

          <p>Щелкните мышкой по форме дважды, чтобы запустить редактор
          и добавьте следующий текст:</p>
          <pre class="SCREEN"> 1 void SortDialog::init()
 2 {
 3     secondaryGroupBox-&gt;hide();
 4     tertiaryGroupBox-&gt;hide();
 5     setColumnRange('A', 'Z');
 6 }
 
 7 void SortDialog::setColumnRange(QChar first, QChar last)
 8 {
 9     primaryColumnCombo-&gt;clear();
10     secondaryColumnCombo-&gt;clear();
11     tertiaryColumnCombo-&gt;clear();

12     secondaryColumnCombo-&gt;insertItem(tr("None"));
13     tertiaryColumnCombo-&gt;insertItem(tr("None"));

14     primaryColumnCombo-&gt;setMinimumSize(
15             secondaryColumnCombo-&gt;sizeHint());
16     QChar ch = first;
17     while (ch &lt;= last) {
18         primaryColumnCombo-&gt;insertItem(ch);
19         secondaryColumnCombo-&gt;insertItem(ch);
20         tertiaryColumnCombo-&gt;insertItem(ch);
21         ch = ch.unicode() + 1;
22     }
23   }
      
</pre>Функция <tt class="METHODNAME">init</tt> делает второй и третий
GroupBox невидимыми.<br>
          <br>

          <p>Слот <tt class="METHODNAME">setColumnRange()</tt>
          инициализирует содержимое выпадающих списков, в соответствии
          с именами выделенных колонок в электронной таблице. Мы
          вставили элемент "None", во второй и третий
          выпадающий списки, на тот случай, если пользователь пожелает
          выполнить сортировку только по одному столбцу. Не смотря на
          то, что мы не создавали это слот в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>, тем
          не менее он его обнаружит самостоятельно, а <tt class="USERINPUT"><strong>uic</strong></tt> создаст соответствующее
          объявление в определении класса <tt class="CLASSNAME">SortDialog</tt>.</p>

          <p>В строках 14 и 15 можно наблюдать один хитрый трюк,
          связаный с размещением компонента. Функция <tt class="METHODNAME">QWidget::sizeHint()</tt> возвращает
          "идеальный" размер виджета, который пробует
          соблюсти система размещения. Дело в том, что виджетам с
          различным содержимым могут быть заданы различные размеры. Для
          выпадающих списков это означает, что второй и третий списки,
          содержащие слово "None", могут иметь больший
          размер, чем первый, в котором указано односимвольное имя
          столбца. Чтобы избежать такой несогласованности, мы задаем
          мнимальный размер, для первого выпадающего списка, равный
          "идеальному" размеру второго.</p>

          <p>Ниже приводится текст функции <tt class="METHODNAME">main()</tt>, которая устанавливает диапазон
          выделенных столбцов от "C" до "F" и затем
          вызывает диалог:</p>
          <pre class="SCREEN">#include &lt;qapplication.h&gt;
#include "sortdialog.h"
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    SortDialog *dialog = new SortDialog;
    app.setMainWidget(dialog);
    dialog-&gt;setColumnRange('C', 'F');
    dialog-&gt;show();
    return app.exec();
}
      
</pre>На этом мы завершаем рассмотрение расширяемого диалога. Из
примера видно, что разработка расширяемых диалогов ненамного сложнее,
чем обычных. Все что нам потребовалось добавить -- это кнопка перехода
из режима в режим, несколько дополнительных сигналов и слотов, и
фиксированный размер формы.<br>
          <br>

          <p>Другой тип диалогов, изменяющих свое представление -- это
          многостраничные диалоги. Создание многостраничных диалогов
          проходит еще проще. Такого рода диалоги можно строить
          несколькими способами:</p>

          <ul>
            <li>
              <p>В качестве основы можно использовать <tt class="CLASSNAME">QTabWidget</tt>. Сверху он имеет набор
              вкладок, которые управляются встроенным <tt class="CLASSNAME">QWidgetStack</tt>.</p>
            </li>

            <li>
              <p>Можно использовать связку <tt class="CLASSNAME">QListBox</tt> и <tt class="CLASSNAME">QWidgetStack</tt>, в которой текущий элемент
              <tt class="CLASSNAME">QListBox</tt>-а определяет страницу
              в <tt class="CLASSNAME">QWidgetStack</tt>.</p>
            </li>

            <li>
              <p>Или связку из классов <tt class="CLASSNAME">QListView</tt> или <tt class="CLASSNAME">QIconView</tt> и <tt class="CLASSNAME">QWidgetStack</tt>, объединяемые так же как и
              в случае с <tt class="CLASSNAME">QListBox</tt>.</p>
            </li>
          </ul>Класс <tt class="CLASSNAME">QWidgetStack</tt>
          обсуждается в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER6">Главе 6</a>.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="DYNAMICDIALOGS"></a>2.5.
          Динамические диалоги.</h1>

          <p>Динамическими называются такие диалоги, которые создаются
          на основе <tt class="FILENAME">.ui</tt> файлов во время
          работы программы (то бишь "на лету"). В случае с
          динамическими диалогами, файлы <tt class="FILENAME">.ui</tt>
          не конвертируются утилитой <tt class="USERINPUT"><strong>uic</strong></tt> в код C++, а
          загружаются программой во время исполнения, с помощью класса
          <tt class="CLASSNAME">QWidgetFactory</tt>, примерно таким
          образом:</p>
          <pre class="SCREEN">QDialog *sortDialog = (QDialog *)
                      QWidgetFactory::create("sortdialog.ui");
      
</pre>Доступ к виджетам на форме такого диалога осуществляется вызовом
функции <tt class="METHODNAME">QObject::child()</tt>:
          <pre class="SCREEN">QComboBox *primaryColumnCombo = (QComboBox *)
        sortDialog-&gt;child("primaryColumnCombo", "QComboBox");
      
</pre>Эта функция возвращает "пустой" указатель, если на
форме диалога не был найден виджет с заданным именем и типом.<br>

          <br>

          <p>Класс <tt class="CLASSNAME">QWidgetFactory</tt> размещен в
          отдельной библиотеке. Чтобы иметь возможность работы с
          классом <tt class="CLASSNAME">QWidgetFactory</tt> из Qt
          приложений, необходимо добавить такую строчку в <tt class="FILENAME">.pro</tt> файл:</p>
          <pre class="SCREEN">LIBS += -lqui      
      
</pre>Этот синтаксис одинаков для любой платформы, даже при том, что он
определенно имеет отношение к Unix.<br>
          <br>

          <p>Динамические диалоги позволяют изменять компоновку формы
          без необходимости пересборки приложения. Исчерпывающий пример
          работы с динамическими диалогами вы найдете в главе
          "Subclassing and Dynamic Dialogs" справочного
          руководства к <span class="emphasis"><em class="EMPHASIS">Qt
          Designer</em></span>.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="BUILTINWIDGETANDDIALOGCLASSES"></a>2.6. Встроенные виджеты и
          классы диалогов.</h1>

          <p>Qt предоставляет полный набор встроенных виджетов и
          диалогов общего назначения, которые подойдут в большинстве
          ситуаций. В этом разделе мы представим изображения
          большинства из них. Некоторые из специализированных
          визуальных компонентов будут рассматриваться ниже, в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">Главе 3</a> (<tt class="CLASSNAME">QMenuBar</tt>,
          <tt class="CLASSNAME">QPopupMenu</tt> и <tt class="CLASSNAME">QToolBar</tt>) и в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER12">Главе
          12</a> (компоненты для работы с базами данных, такие как
          <tt class="CLASSNAME">QDataView</tt> и <tt class="CLASSNAME">QDataTable</tt>). Большинство из встроенных
          виджетов и диалогов будут использоваться в примерах программ
          в данной книге. Ниже представлены скриншоты виджетов в
          классическом Windows-стиле.</p>

          <div class="INFORMALTABLE">
            <a name="AEN987"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="300" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.17a.png"></p>

                      <div class="CAPTION">
                        <p>QPushButton</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="300" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.17b.png"></p>

                      <div class="CAPTION">
                        <p>QCheckBox</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="300" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.17c.png"></p>

                      <div class="CAPTION">
                        <p>QRadioButton</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td>&nbsp;</td>

                  <td width="300" align="center" valign="top">Рисунок 2.17 Кнопки</td>

                  <td>&nbsp;</td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>В Qt имеется три вида "кнопок": <tt class="CLASSNAME">QPushButton, QCheckBox</tt> и <tt class="CLASSNAME">QRadioButton</tt>. Кнопка типа <tt class="CLASSNAME">QPushButton</tt> обычно используется для того,
          чтобы инициировать какое-либо действие. Может работать как
          кнопка с фиксацией (первый щелчок, чтобы нажать, второй --
          чтобы отпустить). Кнопки типа <tt class="CLASSNAME">QRadioButton</tt> обычно используются совместно с
          <tt class="CLASSNAME">QButtonGroup</tt> и работают как группа
          кнопок с взаимозависимой фиксацией, т.е. в каждой группе
          кнопок, в нажатом состоянии может находиться только одна из
          них. Кнопки типа <tt class="CLASSNAME">QCheckBox</tt>, в
          отличие от <tt class="CLASSNAME">QRadioButton</tt>, работают
          как кнопки с взаимонезависимой фиксацией.</p>

          <div class="INFORMALTABLE">
            <a name="AEN1022"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="450" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.18a.png"></p>

                      <div class="CAPTION">
                        <p>QGroupBox</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="450" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.18b.png"></p>

                      <div class="CAPTION">
                        <p>QFrame</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td width="450" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.18c.png"></p>

                      <div class="CAPTION">
                        <p>QTabWidget</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="450" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.18d.png"></p>

                      <div class="CAPTION">
                        <p>QToolBox</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td colspan="2" align="center" valign="top">Рисунок 2.18 Контейнеры</td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>Контейнеры в Qt -- это виджеты, которые могут содержать в
          себе другие виджеты. Кроме того, контейнер <tt class="CLASSNAME">QFrame</tt> может использоваться как
          самостоятельный виджет, для рисования линий. Здесь не показан
          контейнер <tt class="CLASSNAME">QButtonGroup</tt>, визуально
          он идентичен контейнеру <tt class="CLASSNAME">QGroupBox</tt>.</p>

          <p>Контейнеры <tt class="CLASSNAME">QTabWidget</tt> и
          <tt class="CLASSNAME">QToolBox</tt> -- это многостраничные
          виджеты. Каждая страница -- это подчиненный виджет. Нумерация
          страниц начинается с 0.</p>

          <div class="INFORMALTABLE">
            <a name="AEN1062"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="450" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.19a.png"></p>

                      <div class="CAPTION">
                        <p>QListBox</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="450" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.19b.png"></p>

                      <div class="CAPTION">
                        <p>QListView</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td width="450" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.19c.png"></p>

                      <div class="CAPTION">
                        <p>QIconView</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="450" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.19d.png"></p>

                      <div class="CAPTION">
                        <p>QTable</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td colspan="2" align="center" valign="top">Рисунок 2.19 Списки элементов.</td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>Списки элементов оптимизированы для работы с большими
          объемами данных и часто снабжаются полосами прокрутки. Полосы
          прокрутки реализованы в классе <tt class="CLASSNAME">QScrollView</tt>, являющимся базовым для списков
          элементов и другого типа виджетов.</p>

          <div class="INFORMALTABLE">
            <a name="AEN1097"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="300" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.20a.png"></p>

                      <div class="CAPTION">
                        <p>QLabel</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="300" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.20b.png"></p>

                      <div class="CAPTION">
                        <p>QLCDNumber</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="300" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.20c.png"></p>

                      <div class="CAPTION">
                        <p>QProgressBar</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td>&nbsp;</td>

                  <td width="300" align="center" valign="top">Рисунок 2.20 Виджеты отображения
                      информации.</td>

                  <td>&nbsp;</td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>Виджет <tt class="CLASSNAME">QLabel</tt> используется для
          вывода надписей в форматированном виде (с использованием
          простейших тегов HTML)</p>

          <p>Виджет <tt class="CLASSNAME">QTextBrowser</tt> (здесь не
          приводится), порожден от <tt class="CLASSNAME">QTextEdit</tt>
          и предназначен для вывода текста в режиме read-only (только
          для чтения). Обладает поддержкой синтаксиса HTML, которая
          включает в себя поддержку списков, таблиц, изображений и
          гиперссылок. Qt Assistant использует этот виджет для вывода
          текста документации.</p>

          <div class="INFORMALTABLE">
            <a name="AEN1129"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="285" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.21a.png"></p>

                      <div class="CAPTION">
                        <p>QLineEdit</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="300" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.21b.png"></p>

                      <div class="CAPTION">
                        <p>QComboBox</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="285" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.21c.png"></p>

                      <div class="CAPTION">
                        <p>QSpinBox</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td width="285" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.21d.png"></p>

                      <div class="CAPTION">
                        <p>QDateEdit</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="300" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.21e.png"></p>

                      <div class="CAPTION">
                        <p>QDateTimeEdit</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="285" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.21f.png"></p>

                      <div class="CAPTION">
                        <p>QTimeEdit</p>
                      </div>
                    </div><br>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="INFORMALTABLE">
            <a name="AEN1173"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="455" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.21g.png"></p>

                      <div class="CAPTION">
                        <p>QSlider</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="455" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.21h.png"></p>

                      <div class="CAPTION">
                        <p>QScrollBar</p>
                      </div>
                    </div><br>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          <div class="INFORMALTABLE">
            <a name="AEN1191"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="605" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.21i.png"></p>

                      <div class="CAPTION">
                        <p>QTextEdit</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="305" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.21j.png"></p>

                      <div class="CAPTION">
                        <p>QDial</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td colspan="2" align="center" valign="top">Рисунок 2.21 Виджеты ввода
                      информации.</td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>Виджет <tt class="CLASSNAME">QLineEdit</tt> обладает
          возможностью наложения ограничений на вводимые символы с
          помощью маски ввода или проверки корректности ввода
          (validator). Виджет <tt class="CLASSNAME">QTextEdit</tt>,
          наследник класса <tt class="CLASSNAME">QScrollView</tt>,
          обладает возможностью редактирования текста большого
          объема.</p>

          <div class="INFORMALTABLE">
            <a name="AEN1215"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="455" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.22a.png"></p>

                      <div class="CAPTION">
                        <p>QColorDialog</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="455" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.22b.png"></p>

                      <div class="CAPTION">
                        <p>QFontDialog</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td colspan="2" align="center" valign="top">Рисунок 2.22 Диалоги выбора цвета и
                      шрифта.</td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>В Qt имеется целый набор стандартных, наиболее употребимых
          диалогов, которые предоставляют пользователю возможность
          выбрать цвет, шрифт, файл или принтер.</p>

          <div class="INFORMALTABLE">
            <a name="AEN1236"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="455" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.23a.png"></p>

                      <div class="CAPTION">
                        <p>QFileDialog</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="455" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.23b.png"></p>

                      <div class="CAPTION">
                        <p>QPrintDialog</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td colspan="2" align="center" valign="top">Рисунок 2.23 Диалоги выбора файла и
                      принтера.</td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>В операционных системах Windows и Mac OS X, по мере
          возможности, используются "родные" диалоги.</p>

          <div class="INFORMALTABLE">
            <a name="AEN1257"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="450" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.24a.png"></p>

                      <div class="CAPTION">
                        <p>QInputDialog</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="450" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.24b.png"></p>

                      <div class="CAPTION">
                        <p>QProgressDialog</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td width="450" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.24c.png"></p>

                      <div class="CAPTION">
                        <p>QMessageBox</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="450" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.24d.png"></p>

                      <div class="CAPTION">
                        <p>QErrorMessage</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td colspan="2" align="center" valign="top">Рисунок 2.23 Диалоги обратной связи
                      с пользователем.</td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>В Qt так же имеется целый ряд диалогов обратной связи с
          пользователем. Диалоги <tt class="CLASSNAME">QMessageBox</tt>
          и <tt class="CLASSNAME">QErrorMessage</tt> используются для
          вывода сообщений, причем последний запоминает -- выводилось
          ли это сообщение ранее. Операции, протяженные по времени,
          могут быть оформлены в виде <tt class="CLASSNAME">QProgressDialog</tt>, показывающего ход
          выполнения работы. Для того, чтобы запросить у пользователя
          ввод одной строки или числа, очень удобно использовать
          <tt class="CLASSNAME">QInputDialog</tt>.</p>

          <p>И последний диалог, который мы покажем -- это <tt class="CLASSNAME">QWizard</tt>, своего рода каркас для создания
          разного рода "мастеров".</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig2.25.png"></p>

            <div class="CAPTION">
              <p>Рисунок 2.25. QWizard.</p>
            </div>
          </div><br>

          <p>Библиотека Qt предоставляет широкий выбор виджетов и
          диалогов общего назначения. Очень часто специфические
          требования к диалогам могут быть удовлетворены за счет
          соединения сигналов и слотов и реализации своих собственных
          слотов в программе.</p>

          <p>Иногда программист сталкивается с необходимостью писать
          свои собственные виджеты. В Qt это делается легко и просто и
          вашим виджетам будет доступна вся функциональность, которая
          доступна и обычным встроенным виджетам. Они даже могут быть
          интегрированы в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>, таким образом у вас есть
          возможность пользоваться ими так же как и встроенными
          визуальными компонентами. Более подробно, проблема разработки
          своих собственных визуальных компонентов будет рассмотрена в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER5">Главе 5</a>.</p>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER3"></a>Глава 3. Создание главного окна
        приложения</h1>

        <p>В этой главе мы рассмотрим процесс создания главного окна
        приложения. По прочтении ее, вы сможете построить интерфейс
        приложения, который будет содержать меню, панели инструментов,
        строку состояния и набор дополнительных диалогов.</p>

        <div class="MEDIAOBJECT">
          <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.1.png"></p>

          <div class="CAPTION">
            <p>Рисунок 3.1. Приложение -- электронная таблица.</p>
          </div>
        </div><br>

        <p>Главное окно -- это своего рода каркас, на который
        "натягивается" весь пользовательский интерфейс
        приложения. Здесь мы рассмотрим пример создания главного окна
        электронной таблицы. Внешний вид нашего будущего приложения
        приводится на рисунке 3.1. В этом приложении мы будем
        использовать диалоги "Find", "Go-to-Cell" и
        "Sort", которые были созданы нами в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER2">Главе 2</a>.</p>

        <p>Внутри большинства приложений с графическим интерфейсом
        "прячется" код, который обеспечивает основные
        функциональные возможности программы, например, работа с
        файлами или обработка данных, представляемых пользовательским
        интерфейсом. В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER4">Главе 4</a> мы покажем --
        как реализуется такого рода функциональность, на примере нашей
        электронной таблицы.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SUBCLASSINGQMAINWINDOW"></a>3.1.
          Создание класса-наследника от QMainWindow.</h1>

          <p>Главное окно любого приложения -- это класс-наследник
          <tt class="CLASSNAME">QMainWindow</tt>. Большинство приемов,
          используемых при создания диалогов и о которых мы говорили в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER2">Главе 2</a>, вполне применимы и при
          создании главного окна приложения.</p>

          <p>Главное окно может быть создано в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>, но
          мы все будем делать "вручную", чтобы
          продемонстрировать процесс создания главного окна во всех
          деталях. Если вы предпочитаете визуальное проектирование --
          прочитайте главу "Creating a Main Window
          Application" в справочном руководстве к <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>.</p>

          <p>Исходные тексты главного окна будут располагаться в двух
          файлах: <tt class="FILENAME">mainwindow.cpp</tt> и <tt class="FILENAME">mainwindow.cpp</tt>. Начнем с файла заголовка:</p>
          <pre class="SCREEN">#ifndef MAINWINDOW_H 
#define MAINWINDOW_H 
#include &lt;qmainwindow.h&gt; 
#include &lt;qstringlist.h&gt; 
class QAction; 
class QLabel; 
class FindDialog; 
class Spreadsheet; 

class MainWindow : public QMainWindow 
{ 
  Q_OBJECT 
public: 
  MainWindow(QWidget *parent = 0, const char *name = 0); 

protected: 
  void closeEvent(QCloseEvent *event); 
  void contextMenuEvent(QContextMenuEvent *event);      
      
</pre>Это определение класса <tt class="CLASSNAME">MainWindow</tt> --
наследника <tt class="CLASSNAME">QMainWindow</tt>. Оно содержит макрос
<tt class="PARAMETER"><em>Q_OBJECT</em></tt>, поскольку реализует свои
собственные сигналы и слоты.<br>
          <br>

          <p>Функция <tt class="METHODNAME">closeEvent()</tt>, в классе
          <tt class="CLASSNAME">QWidget</tt>, объявлена как
          виртуальная. Она автоматически вызывается перед завершением
          приложения. Мы перекрываем ее в <tt class="CLASSNAME">MainWindow</tt> для того, чтобы иметь возможность
          спросить у пользователя -- желает ли он сохранить
          произведенные изменения, а также для того, чтобы сохранить на
          диск пользовательские настройки.</p>

          <p>Аналогично, функция <tt class="METHODNAME">contextMenuEvent()</tt> вызывается, когда
          пользователь щелкает правой кнопкой мыши по виджету. Мы
          перекрываем ее в <tt class="CLASSNAME">MainWindow</tt> для
          того, чтобы вывести контекстное меню.</p>
          <pre class="SCREEN">private slots: 
  void newFile();
  void open(); 
  bool save(); 
  bool saveAs(); 
  void find(); 
  void goToCell(); 
  void sort(); 
  void about();     
      
</pre>Реализация действий некоторых пунктов меню, таких как
<strong class="COMMAND">File|New</strong> и <strong class="COMMAND">
          Help|About</strong>, выполнена в виде приватных слотов
          <tt class="CLASSNAME">MainWindow</tt>. Большинство слотов
          имеют тип <tt class="METHODNAME">void</tt>, но слоты
          <tt class="METHODNAME">save()</tt> и <tt class="METHODNAME">saveAs</tt> возвращают результат типа <tt class="METHODNAME">bool</tt>. Значение, возвращаемое слотом,
          игнорируется в случае вызова по сигналу, но когда слот
          вызывается как обычная функция, то мы получаем от него
          возвращаемое значение, которое можем использовать для своих
          нужд.
          <pre class="SCREEN">  void updateCellIndicators(); 
  void spreadsheetModified(); 
  void openRecentFile(int param); 

private: 
  void createActions(); 
  void createMenus(); 
  void createToolBars(); 
  void createStatusBar(); 
  void readSettings(); 
  void writeSettings(); 
  bool maybeSave(); 
  void loadFile(const QString &amp;fileName); 
  void saveFile(const QString &amp;fileName); 
  void setCurrentFile(const QString &amp;fileName); 
  void updateRecentFileItems(); 
  QString strippedName(const QString &amp;fullFileName);      
      
</pre>Дополнительные приватные функции, необходимые для обслуживания
пользовательского интерфейса.
          <pre class="SCREEN">  Spreadsheet *spreadsheet; 
  FindDialog *findDialog; 
  QLabel *locationLabel; 
  QLabel *formulaLabel; 
  QLabel *modLabel; 
  QStringList recentFiles; 
  QString curFile; 
  QString fileFilters; 
  bool modified; 
  
  enum { MaxRecentFiles = 5 }; 
  int recentFileIds[MaxRecentFiles]; 
  
  QPopupMenu *fileMenu; 
  QPopupMenu *editMenu; 
  QPopupMenu *selectSubMenu; 
  QPopupMenu *toolsMenu; 
  QPopupMenu *optionsMenu; 
  QPopupMenu *helpMenu; 
  QToolBar *fileToolBar; 
  QToolBar *editToolBar;
  QAction *newAct; 
  QAction *openAct; 
  QAction *saveAct; 
  ... 
  QAction *aboutAct; 
  QAction *aboutQtAct; 
}; 
#endif      
      
</pre>Кроме функций, класс главного окна имеет ряд скрытых переменных.
Все они будут описаны по мере необходимости.<br>
          <br>

          <p>Теперь перейдем к реализации:</p>
          <pre class="SCREEN">#include &lt;qaction.h&gt; 
#include &lt;qapplication.h&gt; 
#include &lt;qcombobox.h&gt; 
#include &lt;qfiledialog.h&gt; 
#include &lt;qlabel.h&gt; 
#include &lt;qlineedit.h&gt; 
#include &lt;qmenubar.h&gt; 
#include &lt;qmessagebox.h&gt; 
#include &lt;qpopupmenu.h&gt; 
#include &lt;qsettings.h&gt; 
#include &lt;qstatusbar.h&gt; 

#include "cell.h" 
#include "finddialog.h" 
#include "gotocelldialog.h" 
#include "mainwindow.h" 
#include "sortdialog.h" 
#include "spreadsheet.h"      
      
</pre>Здесь подключаются заголовки всех классов Qt, которые
используются в приложении, а также заголовок класса главного окна и ряд
других заголовочных файлов, таких как <tt class="FILENAME">finddialog.h, gotocelldialog.h</tt> и <tt class="FILENAME">
          sortdialog.h</tt>, которые мы создали в предыдущей главе.
          <pre class="SCREEN">  MainWindow::MainWindow(QWidget *parent, const char *name) 
    : QMainWindow(parent, name) 
  { 
    spreadsheet = new Spreadsheet(this); 
    setCentralWidget(spreadsheet); 
    createActions(); 
    createMenus(); 
    createToolBars(); 
    createStatusBar(); 
    readSettings(); 
    setCaption(tr("Spreadsheet")); 
    setIcon(QPixmap::fromMimeSource("icon.png")); 
    findDialog = 0; 
    fileFilters = tr("Spreadsheet files (*.sp)"); 
    modified = false; 
  }      
      
</pre>Конструктор начинается с создания виджета <tt class="PARAMETER">
          <em>Spreadsheet</em></tt>, который будет центральным виджетом
          главного окна. Центральный виджет занимает все пространство,
          находящееся между панелью инструментов (toolbar) и строкой
          состояния (statusbar). Класс <tt class="CLASSNAME">Spreadsheet</tt> является потомком класса
          <tt class="CLASSNAME">QTable</tt> и добавляет некоторые
          свойства, характерные для электронных таблиц. Среди них можно
          назвать поддержку формул, которая будет реализована в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER4">Главе 4</a>.<br>
          <br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 3.2. Раскладка виджетов в главном окне.</p>
            </div>
          </div><br>

          <p>Далее вызываются приватные функции <tt class="METHODNAME">createActions(), createMenus(),
          createToolBars()</tt> и <tt class="METHODNAME">createStatusBar()</tt>, которые создают
          остальную часть главного окна. Для восстановления
          пользовательских настроек вызывается функция <tt class="METHODNAME">readSettings()</tt>.</p>

          <p>В качестве иконки приложения устанавливается <tt class="FILENAME">icon.png</tt>. Qt поддерживает различные форматы
          графических файлов, включая BMP, GIF <a name="AEN1370" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#FTN.AEN1370"><span class="footnote">[6]</span></a>
             , JPEG, MNG, PNG, PNM, XBM и XPM. Вызов <tt class="METHODNAME">QWidget::setIcon()</tt> выводит иконку в
             верхний левый угол окна. К сожалению, отсутствует
             платформо-независимый способ помещения иконки на рабочий
             стол.</p>

          <p>Программы с графическим интерфейсом обычно используют
          достаточно большое число изображений. Qt, в свою очередь,
          предоставляет значительное число методов работы с
          изображениями в приложениях. Наиболее употребимые из них:</p>

          <ul>
            <li>
              <p>Сохранение изображений в файлы и загрузка из файлов, в
              процессе работы приложения.</p>
            </li>

            <li>
              <p>Включение изображений формата XPM в исходный код.</p>
            </li>

            <li>
              <p>Механизм "коллекции изображений"
              ("image collection").</p>
            </li>
          </ul>

          <p>В данном примере мы будем использовать механизм
          "коллекции изображений", поскольку работать с ним
          намного проще, чем загружать файлы в процессе исполнения. К
          тому же он может взаимодействовать со всеми, поддерживаемыми
          библиотекой, графическими форматами. Все изображения мы будем
          хранить в каталоге <tt class="FILENAME">images</tt>. Чтобы
          создать файл на языке C++ (он будет создан утилитой
          <tt class="USERINPUT"><strong>uic</strong></tt>), который
          будет хранить наши изображения, добавим следующие строки в
          файл <tt class="FILENAME">.pro</tt>:</p>
          <pre class="SCREEN">IMAGES = images/icon.png \ 
         images/new.png \ 
         images/open.png \ 
         ... 
         images/find.png \ 
         images/gotocell.png      
      
</pre>Изображения будут помещены в исполняемый файл приложения и могут
быть получены вызовом <tt class="METHODNAME">QPixmap::fromMimeSource()</tt>. Преимущество такого
способа организации хранения изображений заключается в том, что они
никогда не потеряются, поскольку находятся внутри исполняемого
файла.<br>
          <br>

          <p>Если главное окно создается в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>, то
          вы можете использовать визуальные средства, предоставляемые
          построителем, для вставки изображений в коллекцию.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="CREATINGMENUSANDTOOLBARS"></a>3.2. Создание меню и панелей
          инструментов.</h1>

          <p>Большинство современных приложений имеют как меню, так и
          панели инструментов, которые содержат более или менее
          идентичный набор команд. Меню дают пользователю возможность
          заняться "исследованием" приложения, изучать
          доступные команды, а панели инструментов служат для быстрого
          доступа к командам, используемым наиболее часто.</p>

          <p>Qt значительно упрощает разработку меню и панелей
          инструментов за счет использования концепции
          "действия" (action). <span class="emphasis"><em class="EMPHASIS">Action</em></span> -- это
          элемент, который может быть добавлен в меню и/или на панель
          инструментов. Для создания меню и панели инструментов
          необходимо выполнить следующие шаги:</p>

          <ul>
            <li>
              <p>Создать "действие" (action).</p>
            </li>

            <li>
              <p>Добавить его в меню.</p>
            </li>

            <li>
              <p>Добавить его на панель инструментов.</p>
            </li>
          </ul>В нашем приложении все необходимое выполняет функция
          <tt class="METHODNAME">createActions()</tt>:
          <pre class="SCREEN">void MainWindow::createActions() 
{ 
  newAct = new QAction(tr("&amp;New"), tr("Ctrl+N"), this); 
  newAct-&gt;setIconSet(QPixmap::fromMimeSource("new.png")); 
  newAct-&gt;setStatusTip(tr("Create a new spreadsheet file")); 
  connect(newAct, SIGNAL(activated()), this, SLOT(newFile()));      
      
</pre>В данном случае создается новое "действие" с названием
"New", горячей комбинацией клавиш Ctrl+N и с владельцем --
главным окном приложения. Затем к "действию" прицепляются
иконка (<tt class="FILENAME">new.png</tt>) и текст подсказки, который
будет выводиться в строке состояния. В заключение -- сигнал
          <tt class="METHODNAME">activated()</tt> подключается к слоту
          главного окна <tt class="METHODNAME">newFile()</tt>, который
          будет описан в следующем разделе. Без этого соединения, при
          выборе пункта меню "File|New" или при нажатии на
          кнопку "New" (в панели инструментов), ничего
          происходить не будет.<br>
          <br>

          <p>Аналогичным образом создаются все остальные
          "действия" (action).</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 3.3. Меню приложения Spreadsheet.</p>
            </div>
          </div><br>

          <p>Команда (action) "Show Grid", в меню
          "Options" реализуется несколько иначе:</p>
          <pre class="SCREEN">  showGridAct = new QAction(tr("&amp;Show Grid"), 0, this); 
  showGridAct-&gt;setToggleAction(true); 
  showGridAct-&gt;setOn(spreadsheet-&gt;showGrid()); 
  showGridAct-&gt;setStatusTip(tr("Show or hide the spreadsheet s " "grid")); 
  connect(showGridAct, SIGNAL(toggled(bool)), spreadsheet, SLOT(setShowGrid(bool)));      
      
</pre>Эта команда имеет два фиксированных состояния --
включено-выключено. В меню рядом с ней отображается галочка (когда
включено), а на панели инструментов она выглядит как кнопка с
фиксацией. Когда "действие" включено, то компонент
          <tt class="PARAMETER"><em>Spreadsheet</em></tt> отображается
          в окне приложения. Мы инициализируем "действие"
          значением по-умолчанию -- включено. Таким образом выполняется
          начальная синхронизация "действия" с фактическим
          режимом отображения компонента <tt class="PARAMETER"><em>Spreadsheet</em></tt>. Затем мы подключаем
          сигнал <tt class="METHODNAME">toggled(bool)</tt> к слоту
          <tt class="METHODNAME">setShowGrid(bool)</tt>, компонента
          <tt class="PARAMETER"><em>Spreadsheet</em></tt>. После этого
          "действие" (action) добавляется в меню или на
          панель инструментов. Теперь пользователь может
          "включать" и "выключать" таблицу.<br>
          <br>

          <p>Команды "Show Grid" и
          "Auto-recalculate" -- являются
          "действиями" с независимой фиксацией. Однако,
          <tt class="CLASSNAME">QAction</tt> имеет наследника --
          <tt class="CLASSNAME">QActionGroup</tt>, с помощью которого
          можно создавать группы "действий" с зависимой
          фиксацией.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.4.png"></p>

            <div class="CAPTION">
              <p>Рисунок 3.4. About Qt.</p>
            </div>
          </div><br>
          <pre class="SCREEN">  aboutQtAct = new QAction(tr("About &amp;Qt"), 0, this); 
  aboutQtAct-&gt;setStatusTip(tr("Show the Qt library's About box")); 
  connect(aboutQtAct, SIGNAL(activated()), qApp, SLOT(aboutQt())); 
}    
    
</pre>

          <p>Для вызова диалога "AboutQt" используется слот
          <tt class="METHODNAME">aboutQt()</tt> глобальной переменной
          <tt class="PARAMETER"><em>qApp</em></tt> -- экземпляр класса
          <tt class="CLASSNAME">QApplication</tt>.</p>

          <p>После создания всех "действий" (action) мы можем
          разместить их в меню:</p>
          <pre class="SCREEN">void MainWindow::createMenus() 
{ 
  fileMenu = new QPopupMenu(this); 
  newAct-&gt;addTo(fileMenu); 
  openAct-&gt;addTo(fileMenu); 
  saveAct-&gt;addTo(fileMenu); 
  saveAsAct-&gt;addTo(fileMenu); 
  fileMenu-&gt;insertSeparator(); 
  exitAct-&gt;addTo(fileMenu); 
  
  for (int i = 0; i &lt; MaxRecentFiles; ++i) 
    recentFileIds[i] = -1;      
      
</pre>В Qt все меню являются экземплярами <tt class="CLASSNAME">
          QPopupMenu</tt>. Мы создали меню "File" и затем
          добавили в него пункты "New", "Open",
          "Save", "Save As" и "Exit".
          Перед пунктом "Exit" добавлен разделитель, чтобы
          визуально отделить его от остальных. Цикл <tt class="COMPUTEROUTPUT">for</tt> инициализирует <tt class="PARAMETER"><em>recentFileIds</em></tt> -- массив файлов,
          открывавшихся недавно. Мы еще вернемся к этому массиву, когда
          приступим к рассмотрению реализации слотов меню
          "File" в следующем разделе.
          <pre class="SCREEN">  editMenu = new QPopupMenu(this); 
  cutAct-&gt;addTo(editMenu); 
  copyAct-&gt;addTo(editMenu); 
  pasteAct-&gt;addTo(editMenu); 
  deleteAct-&gt;addTo(editMenu); 
  
  selectSubMenu = new QPopupMenu(this); 
  selectRowAct-&gt;addTo(selectSubMenu); 
  selectColumnAct-&gt;addTo(selectSubMenu); 
  selectAllAct-&gt;addTo(selectSubMenu); 
  editMenu-&gt;insertItem(tr("&amp;Select"), selectSubMenu); 
  
  editMenu-&gt;insertSeparator(); 
  findAct-&gt;addTo(editMenu); 
  goToCellAct-&gt;addTo(editMenu);      
      
</pre>Меню "Edit" включает в себя подменю, которое так же
является экземпляром класса <tt class="CLASSNAME">QPopupMenu</tt>. Мы
просто создаем подменю и вставляем его в то место меню
"Edit", где оно должно находиться.
          <pre class="SCREEN">  toolsMenu = new QPopupMenu(this); 
  recalculateAct-&gt;addTo(toolsMenu); 
  sortAct-&gt;addTo(toolsMenu); 
  
  optionsMenu = new QPopupMenu(this); 
  showGridAct-&gt;addTo(optionsMenu);      
  autoRecalcAct-&gt;addTo(optionsMenu); 
  
  helpMenu = new QPopupMenu(this); 
  aboutAct-&gt;addTo(helpMenu); 
  aboutQtAct-&gt;addTo(helpMenu); 
  
  menuBar()-&gt;insertItem(tr("&amp;File"), fileMenu); 
  menuBar()-&gt;insertItem(tr("&amp;Edit"), editMenu); 
  menuBar()-&gt;insertItem(tr("&amp;Tools"), toolsMenu); 
  menuBar()-&gt;insertItem(tr("&amp;Options"), optionsMenu); 
  menuBar()-&gt;insertSeparator(); 
  menuBar()-&gt;insertItem(tr("&amp;Help"), helpMenu); 
}  
      
</pre>Меню "Tools", "Options" и "Help"
создаются аналогичным образом и в конце, все созданные меню вставляются
в полосу меню, в верхней части главного окна приложения. Функция
<tt class="METHODNAME">QMainWindow::menuBar()</tt> возвращает указатель
на экземпляр класса <tt class="CLASSNAME">QMenuBar</tt>, который
создается автоматически, при первом вызове <tt class="METHODNAME">
          menuBar()</tt>. Мы добавили разделитель между меню
          "Options" и "Help". В случае отображения
          в стиле Motif и ему подобных, меню "Help" смещается
          в крайнее правое положение, в других стилях отображения
          разделитель игнорируется.<br>
          <br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.5a.png"></p>
          </div>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.5b.png"></p>

            <div class="CAPTION">
              <p>Рисунок 3.5. Полоса меню в стиле Motif и Windows.</p>
            </div>
          </div><br>

          <p>Создание панелей инструментов происходит очень похожим
          образом:</p>
          <pre class="SCREEN">void MainWindow::createToolBars() 
{ 
  fileToolBar = new QToolBar(tr("File"), this); 
  newAct-&gt;addTo(fileToolBar); 
  openAct-&gt;addTo(fileToolBar); 
  saveAct-&gt;addTo(fileToolBar); 
  
  editToolBar = new QToolBar(tr("Edit"), this); 
  cutAct-&gt;addTo(editToolBar); 
  copyAct-&gt;addTo(editToolBar); 
  pasteAct-&gt;addTo(editToolBar); 
  editToolBar-&gt;addSeparator(); 
  findAct-&gt;addTo(editToolBar); 
  goToCellAct-&gt;addTo(editToolBar); 
}      
      
</pre>Мы создали две панели инструментов -- "File" и
"Edit". Как и меню, панели инструментов могут включать в себя
разделители.<br>
          <br>

          <p><span class="INLINEMEDIAOBJECT"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.6a.png"></span> <span class="INLINEMEDIAOBJECT"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.6b.png"></span></p>

          <p>Рисунок 3.6. Панели инструментов приложения
          Spreadsheet.</p>

          <p>Теперь, когда мы закончили создание главного меню и
          панелей инструментов, добавим контекстное меню.</p>
          <pre class="SCREEN">void MainWindow::contextMenuEvent(QContextMenuEvent *event) 
{ 
  QPopupMenu contextMenu(this); 
  cutAct-&gt;addTo(&amp;contextMenu); 
  copyAct-&gt;addTo(&amp;contextMenu); 
  pasteAct-&gt;addTo(&amp;contextMenu); 
  contextMenu.exec(event-&gt;globalPos()); 
}      
      
</pre>Когда пользователь щелкает правой кнопкой мыши, то виджету
посылается событие (event) "контекстное меню". Перекрывая
метод <tt class="METHODNAME">QWidget::contextMenuEvent()</tt>, мы можем
перехватить это событие и показать контекстное меню в позиции курсора
мыши.<br>
          <br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.7.png"></p>

            <div class="CAPTION">
              <p>Рисунок 3.5. Контекстное меню приложения
              Spreadsheet.</p>
            </div>
          </div><br>

          <p>События, точно так же как сигналы и слоты, являются одним
          из фундаментальных аспектов программирования в Qt. События
          рождаются в недрах библиотеки, чтобы сообщить о щелчках
          мышью, о нажатиях клавиш, о попытках изменения размеров и
          т.п.. Они могут быть перехвачены и обработаны за счет
          перекрытия виртуальных функций, как это делается в нашем
          случае.</p>

          <p>Отлавливать событие мы будем в <tt class="VARNAME">MainWindow</tt> потому, что здесь реализуются все
          наши "действия" (actions). Однако, это событие
          можно поймать и в виджете <tt class="VARNAME">Spreadsheet</tt>. Когда пользователь щелкнет правой
          кнопкой мыши по виджету, то этот виджет первым получит
          событие. Если виджет перекроет реализацию функции <tt class="METHODNAME">contextMenuEvent()</tt> и обработает событие, то
          дальше передаваться оно не будет. В противном случае оно
          будет передано дальше -- владельцу виджета (<tt class="VARNAME">MainWindow</tt>). Более подробно события будут
          рассматриваться в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER7">Главе 7</a>.</p>

          <p>Функция-обработчик события вызова контекстного меню
          отличается от всего, что мы до сих пор видели, поскольку она
          создает экземпляр <tt class="CLASSNAME">QPopupMenu</tt>,
          размещая его на стеке. Хотя, в принципе, можно было бы
          создать/удалить этот виджет и с помощью операторов <tt class="PARAMETER"><em>new/delete</em></tt>:</p>
          <pre class="SCREEN">  QPopupMenu *contextMenu = new QPopupMenu(this); 
  cutAct-&gt;addTo(contextMenu); 
  copyAct-&gt;addTo(contextMenu); 
  pasteAct-&gt;addTo(contextMenu); 
  contextMenu-&gt;exec(event-&gt;globalPos()); 
  delete contextMenu;      
      
</pre>Еще один примечательный аспект -- это функция
          <tt class="METHODNAME">exec()</tt>. Она выводит меню на
          экран, в заданную позицию, и ожидает, пока пользователь не
          сделает свой выбор, после чего управление возвращается в
          точку вызова. С этого момента экземпляр <tt class="CLASSNAME">QPopupMenu</tt> нам больше не нужен, поэтому он
          удаляется. В случае размещения на стеке -- он будет уничтожен
          автоматически, по завершении работы функции.<br>
          <br>

          <p>Часть интерфейса, касающуюся меню и панелей инструментов,
          можно считать завершенной. В следующем разделе мы рассмотрим
          реализацию слотов меню "File".</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="IMPLEMENTINGTHEFILEMENU"></a>3.3. Реализация меню
          "File".</h1>

          <p>В этом разделе мы рассмотрим реализацию всех слотов меню
          "File".</p>
          <pre class="SCREEN">void MainWindow::newFile() 
{ 
  if (maybeSave()) { 
    spreadsheet-&gt;clear(); 
    setCurrentFile(""); 
  } 
}      
      
</pre>Слот <tt class="METHODNAME">newFile()</tt> вызывается, когда
пользователь выбирает пункт меню <strong class="COMMAND">"File|New"</strong> или щелкает по кнопке
"New" на панели инструментов. Функция <tt class="METHODNAME">
          maybeSave()</tt> спрашивает пользователя: "Do you want
          to save your changes?" ("Желаете ли сохранить
          изменения?"), если файл был изменен. Она возвращает
          <tt class="PARAMETER"><em>true</em></tt>, если пользователь
          ответил "Yes" или "No" (в случае ответа
          "Yes" -- файл сохраняется), и <tt class="PARAMETER"><em>false</em></tt> -- если пользователь нажал на
          кнопку "Cancel" ("Отмена"). Приватная
          функция <tt class="METHODNAME">setCurrentFile()</tt>
          обновляет заголовок окна программы, показывая, что
          редактируется неозаглавленный документ.<br>
          <br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.8.png"></p>

            <div class="CAPTION">
              <p>Рисунок 3.8. Запрос: "Do you want to save your
              changes?"</p>
            </div>
          </div><br>
          <pre class="SCREEN">bool MainWindow::maybeSave() 
{ 
  if (modified) { 
    int ret = QMessageBox::warning(this, tr("Spreadsheet"), 
                  tr("The document has been modified.\n" 
                     "Do you want to save your changes?"), 
                  QMessageBox::Yes | QMessageBox::Default, 
                  QMessageBox::No, 
                  QMessageBox::Cancel | QMessageBox::Escape); 
    if (ret == QMessageBox::Yes) 
      return save(); 
    else if (ret == QMessageBox::Cancel) 
      return false;      
  } return true; 
}  
      
</pre>Функция <tt class="METHODNAME">maybeSave()</tt> выводит перед
пользователем диалоговое окно с запросом (см. рис. 3.8). Диалог имеет
три кнопки -- три варианта ответа: "Yes", "No" и
"Cancel". Модификатор <tt class="METHODNAME">QMessageBox::Default</tt> назначает кнопку "Yes"
-- кнопкой по-умолчанию. Модификатор <tt class="METHODNAME">QMessageBox::Escape</tt> связывает кнопку "No" с
клавишей Esc.<br>
          <br>

          <p>Вызов <tt class="METHODNAME">QMessageBox::warning()</tt>
          может показаться на первый взгляд немного не понятным.
          Синтаксис этого метода:</p>
          <pre class="SCREEN">QMessageBox::warning(parent, caption, messageText, 
                     button0, button1, ...);      
      
</pre>Класс <tt class="CLASSNAME">QMessageBox</tt> имеет еще ряд
аналогичных методов: <tt class="METHODNAME">information(),
question()</tt> и <tt class="METHODNAME">critical()</tt>, Все они
отображают диалоговое окно с различными иконками.

          <div class="INFORMALTABLE">
            <a name="AEN1509"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="200" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.9a.png"></p>

                      <div class="CAPTION">
                        <p>Information</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="200" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.9b.png"></p>

                      <div class="CAPTION">
                        <p>Question</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="200" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.9c.png"></p>

                      <div class="CAPTION">
                        <p>Warning</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="200" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.9d.png"></p>

                      <div class="CAPTION">
                        <p>Critical</p>
                      </div>
                    </div><br>
                  </td>

                  <td> </td>

                  <td> </td>

                  <td> </td>
                </tr>
              </tbody>
            </table>
          </div>Рисунок 3.9. Иконки диалога запроса.
          <pre class="SCREEN">void MainWindow::open() 
{ 
  if (maybeSave()) { 
    QString fileName = 
            QFileDialog::getOpenFileName(".", fileFilters, this); 
    if (!fileName.isEmpty()) 
      loadFile(fileName); 
  } 
}      
      
</pre>Слот <tt class="METHODNAME">open()</tt> соответствует пункту меню
<strong class="COMMAND">"File|Open"</strong>. Аналогично
слоту <tt class="METHODNAME">newFile()</tt> -- сначала вызывается
функция <tt class="METHODNAME">maybeSave()</tt>, чтобы сохранить
имеющиеся изменения. Затем, с помощью функции <tt class="METHODNAME">
          QFileDialog::getOpenFileName()</tt>, у пользователя
          запрашивается имя открываемого файла. Она выводит перед
          пользователем диалоговое окно, которое предлагает выбрать
          требуемый файл и возвращает программе его имя или пустую
          строку, если пользователь отменил операцию открытия
          файла.<br>
          <br>

          <p>Функции <tt class="METHODNAME">getOpenFileName()</tt>
          передаются три аргумента. Первый аргумент -- это каталог, где
          может находиться файл, в нашем случае -- это текущий каталог.
          Второй аргумент -- <tt class="PARAMETER"><em>fileFilters</em></tt>, задет фильтр имен
          файлов. Фильтр состоит из двух частей -- текста описания и
          шаблона. В конструкторе <tt class="METHODNAME">MainWindow</tt> фильтр был инициализирован
          так:</p>
          <pre class="SCREEN">  fileFilters = tr("Spreadsheet files (*.sp)");      
      
</pre>Если бы наша программа дополнительно поддерживала файлы форматов
CSV и Lotus 1-2-3, то фильтр имен файлов мог бы быть инициализирован
следующим образом:
          <pre class="SCREEN">  fileFilters = tr("Spreadsheet files (*.sp)\n" 
                   "Comma-separated values files (*.csv)\n" 
                   "Lotus 1-2-3 files (*.wk?)");      
      
</pre>И наконец третий аргумент указывает, что окно диалога является
подчиненным, по отношению к главному окну приложения.<br>
          <br>

          <p>Для диалоговых окон, отношение
          "владелец-подчиненный", носит иной смысл, чем для
          виджетов. Диалоговое окно всегда отображает поверх других
          окон, но если оно имеет владельца, то центрируется
          относительно него. Этот же диалог вызывается по нажатии на
          кнопку "Open", на панели инструментов. <a name="P51"></a></p>
          <pre class="SCREEN">void MainWindow::loadFile(const QString &amp;fileName) 
{ 
  if (spreadsheet-&gt;readFile(fileName)) { 
    setCurrentFile(fileName); 
    statusBar()-&gt;message(tr("File loaded"), 2000); 
  } else { 
    statusBar()-&gt;message(tr("Loading canceled"), 2000); 
  } 
}      
      
</pre>Функция <tt class="METHODNAME">loadFile()</tt> вызывается из
<tt class="METHODNAME">open()</tt> для загрузки файла. Мы вынесли
операцию загрузки файла в отдельную функцию, потому что она потребуется
нам при реализации слота, открывающего недавно использовавшиеся
файлы.<br>
          <br>

          <p>Непосредственное чтение файла с диска выполняется в
          функции <tt class="METHODNAME">Spreadsheet::readFile()</tt>.
          Если чтение прошло без ошибок, то вызывается <tt class="METHODNAME">setCurrentFile()</tt>, чтобы обновить заголовок
          окна. В противном случае <tt class="METHODNAME">readFile()</tt> выведет окно с сообщением об
          ошибке. Обычно, считается хорошей практикой давать
          возможность низкоуровневым компонентам выводить свои
          сообщения, поскольку в этом случае диагностика ошибок может
          быть выполнена более точно.</p>

          <p>В обоих случаях, в строку состояния выводится сообщение,
          которое демонстрируется 2000 миллисекунд (2 секунды).</p>
          <pre class="SCREEN">bool MainWindow::save() 
{ 
  if (curFile.isEmpty()) { 
    return saveAs(); 
  } else { 
    saveFile(curFile); 
    return true; 
  } 
} 

void MainWindow::saveFile(const QString &amp;fileName) 
{ 
  if (spreadsheet-&gt;writeFile(fileName)) { 
    setCurrentFile(fileName); 
    statusBar()-&gt;message(tr("File saved"), 2000); 
  } else { 
    statusBar()-&gt;message(tr("Saving canceled"), 2000); 
  } 
}      
      
</pre>Слот <tt class="METHODNAME">save()</tt> соответствует пункту меню
<strong class="COMMAND">"File|Save"</strong>. Если файлу
ранее уже было назначено имя, то он сохраняется вызовом
          <tt class="METHODNAME">saveFile()</tt>, иначе вызывается
          <tt class="METHODNAME">saveAs()</tt>.
          <pre class="SCREEN">bool MainWindow::saveAs() 
{ 
  QString fileName = 
          QFileDialog::getSaveFileName(".", fileFilters, this); 
  if (fileName.isEmpty()) 
    return false; 
    
  if (QFile::exists(fileName)) { 
    int ret = QMessageBox::warning(this, tr("Spreadsheet"), 
                tr("File %1 already exists.\n" 
                   "Do you want to overwrite it?") 
                .arg(QDir::convertSeparators(fileName)), 
                QMessageBox::Yes | QMessageBox::Default, 
                QMessageBox::No | QMessageBox::Escape); 
    if (ret == QMessageBox::No) 
      return true; 
  } 
  if (!fileName.isEmpty()) 
    saveFile(fileName); 
  return true; 
}      
      
</pre>Слот <tt class="METHODNAME">saveAs()</tt> соответствует пункту
меню <strong class="COMMAND">"File|Save As"</strong>. Он
запрашивает у пользователя имя сохраняемого файла, вызовом
          <tt class="METHODNAME">QFileDialog::getSaveFileName()</tt>.
          Если пользователь нажмет кнопку "Cancel", то
          возвращается значение <tt class="PARAMETER"><em>false</em></tt>, которое затем передается
          выше, функцией <tt class="METHODNAME">maybeSave()</tt>. Иначе
          возвращается имя файла, которое может быть как новым именем,
          так и именем существующего файла. В последнем случае перед
          пользователем демонстрируется предупреждение:<br>
          <br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.10.png"></p>

            <div class="CAPTION">
              <p>Рисунок 3.10. Запрос: "Do you want to overwrite
              it?"</p>
            </div>
          </div><br>

          <p>Диалогу передается текст:</p>
          <pre class="SCREEN">      tr("File %1 already exists\n" 
         "Do you want to override it?") 
      .arg(QDir::convertSeparators(fileName))      
      
</pre>где функция <tt class="METHODNAME">QString::arg()</tt> выполняет
подстановку спецификатора <span class="emphasis"><em class="EMPHASIS">
          "%1"</em></span> своим аргументом. Например, если
          предположить, что имя файла <tt class="FILENAME">A:\tab04.sp</tt>, то вышеприведенный код будет
          полностью эквивалентен следующему:
          <pre class="SCREEN">      "File A:\\tab04.sp already exists.\n" 
      "Do you want to override it?"     
      
</pre>есстественно, если исходить из предположения, что приложение не
было переведено на какой либо другой язык. Функция <tt class="METHODNAME">QDir::convertSeparators()</tt> выполняет преобразование
платформо-зависимых разделителей элементов пути в файловой системе
("/" -- для Unix и Mac OS X, "\" -- для Windows) в
символ прямого слэша.
          <pre class="SCREEN">void MainWindow::closeEvent(QCloseEvent *event) 
{ 
  if (maybeSave()) { 
    writeSettings(); 
    event-&gt;accept(); 
  } else { 
    event-&gt;ignore(); 
  } 
}      
      
</pre>Когда пользователь выбирает пункт меню <strong class="COMMAND">
          "File|Exit"</strong> или закрывает приложение
          нажатием на кнопку "X" в заголовке окна, то
          вызывается слот <tt class="METHODNAME">QWidget::close()</tt>.
          Он передает приложению событие "close". Перекрыв
          функцию <tt class="METHODNAME">QWidget::closeEvent()</tt>, мы
          можем предотвратить закрытие окна и решить -- что делать
          дальше.<br>
          <br>

          <p>Если в приложении имеются несохраненные данные и
          пользователь отменил операцию сохранения файла, то мы просто
          "игнорируем" событие и продолжаем работу. В
          противном случае -- мы подтверждаем закрытие приложения и
          приложение завершает свою работу.</p>
          <pre class="SCREEN">void MainWindow::setCurrentFile(const QString &amp;fileName) 
{ 
  curFile = fileName; 
  modLabel-&gt;clear(); 
  modified = false; 
  if (curFile.isEmpty()) { 
    setCaption(tr("Spreadsheet")); 
  } else { 
    setCaption(tr("%1 - %2").arg(strippedName(curFile)) 
                            .arg(tr("Spreadsheet"))); 
    recentFiles.remove(curFile); 
    recentFiles.push_front(curFile); 
    updateRecentFileItems(); 
  } 
} 

QString MainWindow::strippedName(const QString &amp;fullFileName) 
{ 
  return QFileInfo(fullFileName).fileName(); 
}      
      
</pre>В функции <tt class="METHODNAME">setCurrentFile()</tt> мы
записываем имя файла в приватную переменную-член <tt class="PARAMETER">
          <em>curFile</em></tt>, сбрасываем признак "изменен"
          и обновляем заголовок окна. Обратите внимание: теперь мы
          использовали два спецификатора, вида <span class="emphasis"><em class="EMPHASIS">"%n"</em></span>.
          Подстановкой первого (<span class="emphasis"><em class="EMPHASIS">"%1"</em></span>) занимается первый
          вызов <tt class="METHODNAME">arg()</tt>, второго
          (<span class="emphasis"><em class="EMPHASIS">"%2"</em></span>) -- второй вызов. Такую
          форму записи можно несколько упростить:
          <pre class="SCREEN">      setCaption(strippedName(curFile) + tr(" - Spreadsheet"));     
      
</pre>но использование <tt class="METHODNAME">arg()</tt> дает большую
гибкость переводчикам. Чтобы не загромождать заголовок окна длинной
строкой, мы удалили из нее путь к файлу с помощью функции
          <tt class="METHODNAME">strippedName()</tt>.<br>
          <br>

          <p>Затем обновляется список файлов <tt class="PARAMETER"><em>recentFiles</em></tt>, использовавшихся
          недавно. Для начала вызывается <tt class="METHODNAME">remove()</tt>, которая удаляет имя файла из
          списка, а затем <tt class="METHODNAME">push_front()</tt>
          добавляет имя файла в начало. Вызов <tt class="METHODNAME">remove()</tt> необходим для предотвращения
          появления дублирующихся записей. После обновления списка
          вызывается <tt class="METHODNAME">updateRecentFileItems()</tt>, которая выполняет
          обновление меню <strong class="COMMAND">"File"</strong>.</p>

          <p>Переменная <tt class="PARAMETER"><em>recentFiles</em></tt>
          имеет тип <tt class="CLASSNAME">QStringList</tt> (список
          строк <tt class="CLASSNAME">QString</tt>). В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER11">Главе 11</a> мы подробнее остановимся на
          классах-контейнерах, таких как <tt class="CLASSNAME">QStringList</tt>.</p>

          <p>На этом реализация меню <strong class="COMMAND">"File"</strong> практически завершена. Но
          остается еще один момент. Необходимо выполнить реализацию
          слота открывающего файлы из списка недавно использовавшихся
          файлов. <a name="P54"></a></p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.11.png"></p>

            <div class="CAPTION">
              <p>Рисунок 3.11. Меню <strong class="COMMAND">"File"</strong> со списком недавно
              использовавшихся файлов.</p>
            </div>
          </div><br>
          <pre class="SCREEN">void MainWindow::updateRecentFileItems() 
{ 
  while ((int)recentFiles.size() &gt; MaxRecentFiles) 
    recentFiles.pop_back(); 
    
  for (int i = 0; i &lt; (int)recentFiles.size(); ++i) { 
    QString text = tr("&amp;%1 %2") 
                   .arg(i + 1) 
                   .arg(strippedName(recentFiles[i])); 
    if (recentFileIds[i] == -1) { 
      if (i == 0) 
        fileMenu-&gt;insertSeparator(fileMenu-&gt;count() - 2); 
      recentFileIds[i] = 
              fileMenu-&gt;insertItem(text, this,
                                   SLOT(openRecentFile(int)), 
                                   0, -1, 
                                   fileMenu-&gt;count() - 2); 
      fileMenu-&gt;setItemParameter(recentFileIds[i], i); 
    } else { 
      fileMenu-&gt;changeItem(recentFileIds[i], text); 
    } 
  } 
}
      
</pre>Функция <tt class="METHODNAME">updateRecentFileItems()</tt>
вызывается для обновления элементов меню, соответствующих недавно
открывавшимся файлам. Для начала удаляются все "лишние"
элементы, начиная с конца списка (длина списка не может превышать числа
<tt class="PARAMETER"><em>MaxRecentFiles</em></tt>. которое определено
в <tt class="FILENAME">mainwindow.h</tt> и равно числу 5)<br>
          <br>

          <p>Затем в меню добавляется новый элемент или используется
          существующий. В самый первый раз в меню добавляется
          разделитель, отделяющий список файлов от остальных пунктов.
          Чуть ниже мы объясним назначение функции <tt class="METHODNAME">setItemParameter()</tt>.</p>

          <p>На первый взгляд кажется странным, что в функции
          <tt class="METHODNAME">updateRecentFileItems()</tt> мы
          создаем элементы меню, но никогда не удаляем их! Однако тут
          нет ничего странного. Мы можем смело утверждать, что в
          течение сессии список файлов уменьшаться не будет.</p>

          <p>Функция <tt class="METHODNAME">QPopupMenu::insertItem()</tt> имеет следующий
          синтаксис:</p>
          <pre class="SCREEN">fileMenu-&gt;insertItem(text, receiver, slot, accelerator, id, index);      
      
</pre>где <tt class="PARAMETER"><em>text</em></tt> -- это текст,
который будет отображаться, в данном случае мы используем имя файла без
пути к нему. Можно было бы использовать полное имя файла, но это
сделает панель меню слишком широкой. Если у вас возникнет необходимость
сохранять в меню полный путь к файлу вместе с его именем, то
рекомендуем оформлять список файлов в виде подменю.<br>
          <br>

          <p>Аргументы <tt class="PARAMETER"><em>receiver</em></tt> и
          <tt class="PARAMETER"><em>slot</em></tt> определяют
          функцию-обработчик, которая будет вызываться при выборе этого
          пункта меню. В нашем примере мы указали слот <tt class="METHODNAME">openRecentFile(int)</tt> главного окна.</p>

          <p>В аргументах <tt class="PARAMETER"><em>accelerator</em></tt> и <tt class="PARAMETER"><em>id</em></tt> мы передаем значения
          по-умолчанию. Это означает, что данный пункт меню не имеет
          комбинации "горячих" клавиш, а идентификатор
          (<tt class="PARAMETER"><em>id</em></tt>) генерируется
          автоматически. Мы сохраняем полученный <tt class="PARAMETER"><em>id</em></tt> в массиве <tt class="PARAMETER"><em>recentFileIds</em></tt>, что позднее позволит
          нам обращаться к пункту меню по его идентификатору.</p>

          <p>Аргумент <tt class="PARAMETER"><em>index</em></tt> -- это
          порядковый номер записи в меню. Значение <tt class="PARAMETER"><em>fileMenu-&gt;count()-2,</em></tt> означает,
          что пункт меню вставляется выше разделителя, отделяющего
          пункт <strong class="COMMAND">"Exit"</strong>.</p>
          <pre class="SCREEN">void MainWindow::openRecentFile(int param) 
{ 
  if (maybeSave()) 
    loadFile(recentFiles[param]); 
}      
      
</pre>Слот <tt class="METHODNAME">openRecentFile()</tt> открывает файл,
соответствующий выбранному пункту меню. В качестве аргумента
          <tt class="PARAMETER"><em>param</em></tt> передается число,
          записанное нами вызовом <tt class="METHODNAME">setItemParameter()</tt>. Мы выбрали числа
          такими, что теперь можем использовать их как индексы в списке
          <tt class="PARAMETER"><em>recentFiles</em></tt>.<br>
          <br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.12.png"></p>

            <div class="CAPTION">
              <p>Рисунок 3.12. Соответствие между пунктами меню и
              полными именами файлов.</p>
            </div>
          </div><br>

          <p>Таким образом мы решаем проблему сопоставления пунктов
          меню полным именам файлов. Менее элегантный способ
          заключается в создании пяти "действий" (action) и
          соединении их с пятью различными слотами.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SETTINGUPTHESTATUSBAR"></a>3.4.
          Настройка строки состояния.</h1>

          <p>На этом мы заканчиваем описание настройки меню и панели
          инструментов, и переходим к строке состояния. В обычном
          режиме строка состояния содержит три индикатора: номер
          текущей ячейки, формула в текущей ячейке и MOD -- признак
          того, что файл был изменен. Но помимо этого строка состояния
          может использоваться для отображения подсказок и других
          сообщений.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.13a.png"></p>

            <div class="CAPTION">
              <p>Обычный режим.</p>
            </div>
          </div><br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.13b.png"></p>

            <div class="CAPTION">
              <p>Подсказка</p>
            </div>
          </div><br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.13c.png"></p>

            <div class="CAPTION">
              <p>Сообщение</p>
            </div>
          </div><br>

          <p>Рисунок 3.13. Строка состояния.</p>

          <p>Создается и настраивается строка состояния в функции
          <tt class="METHODNAME">createStatusBar()</tt>, которая
          вызывается из конструктора <tt class="METHODNAME">MainWindow</tt>:</p>
          <pre class="SCREEN">void MainWindow::createStatusBar() 
{ 
  locationLabel = new QLabel(" W999 ", this); 
  locationLabel-&gt;setAlignment(AlignHCenter); 
  locationLabel-&gt;setMinimumSize(locationLabel-&gt;sizeHint()); 
  
  formulaLabel = new QLabel(this); 
  
  modLabel = new QLabel(tr(" MOD "), this); 
  modLabel-&gt;setAlignment(AlignHCenter); 
  modLabel-&gt;setMinimumSize(modLabel-&gt;sizeHint());      
  modLabel-&gt;clear(); 
  
  statusBar()-&gt;addWidget(locationLabel); 
  statusBar()-&gt;addWidget(formulaLabel, 1); 
  statusBar()-&gt;addWidget(modLabel); 
  
  connect(spreadsheet, SIGNAL(currentChanged(int, int)), 
          this, SLOT(updateCellIndicators())); 
  connect(spreadsheet, SIGNAL(modified()), 
          this, SLOT(spreadsheetModified())); 
  updateCellIndicators(); 
}
      
</pre>Она возвращает указатель на созданный ею компонент - строку
состояния. (Компонент строки состояния создается автоматически, при
первом вызове функции <tt class="METHODNAME">statusBar()</tt>.)
Индикаторы -- это простые метки (<tt class="CLASSNAME">QLabel</tt>),
текст в которых изменяется по мере необходимости. Во время создания,
меткам передается указатель на "владельца"
          (<tt class="PARAMETER"><em>this</em></tt>), хотя в этом нет
          особой необходимости, поскольку <tt class="METHODNAME">QStatusBar::addWidget()</tt>
          "переподчиняет" их автоматически, назначая в
          качестве "владельца" сам компонент строки
          состояния.<br>
          <br>

          <p>Из рисунка 3.13 видно, что метки имеют различные размеры.
          Адрес ячейки и индикатор MOD -- самые короткие, а метка,
          отображающая действующую в ячейке формулу, самая длинная.
          Кроме того, при изменении размеров окна, все дополнительное
          пространство должно выделяться именно ей. Такое поведение
          достигается за счет указания фактора "stretch"
          (значение 1 в вызове <tt class="METHODNAME">QStatusBar::addWidget()</tt>). Для других двух
          меток этот фактор по-умолчанию принимается равным нулю, что
          означает фиксированный размер меток.</p>

          <p>Когда <tt class="CLASSNAME">QStatusBar</tt> размещает
          виджеты, он сначала выделяет место для
          "нерастягиваемых" компонентов (выделяя им
          "идеальный" размер, определяемый вызовом <tt class="METHODNAME">QWidget::sizeHint()</tt>), а затем все остальное
          пространство отдается "растягиваемым" виджетам.
          "Идеальный" размер, в свою очередь, зависит от
          содержимого виджетов и меняется при изменении содержимого.
          Задавая начальные значения меток ("W999" и
          "MOD"), мы тем самым определяем их минимально
          возможный размер.</p>

          <p>В конце функции мы выполняем соединения между сигналами
          <tt class="VARNAME">Spreadsheet</tt> к двум слотам <tt class="VARNAME">MainWindow</tt>: <tt class="METHODNAME">updateCellIndicators()</tt> и <tt class="METHODNAME">spreadsheetModified()</tt>.</p>
          <pre class="SCREEN">void MainWindow::updateCellIndicators() 
{ 
  locationLabel-&gt;setText(spreadsheet-&gt;currentLocation()); 
  formulaLabel-&gt;setText(" " + spreadsheet-&gt;currentFormula()); 
}
      
</pre>Слот <tt class="METHODNAME">updateCellIndicator()</tt> обновляет
метки, которые отображают адрес текущей ячейки и действующую в ней
формулу. Он вызывается всякий раз, когда пользователь переходит из
одной ячейки в другую. Кроме того, он вызывается как обычная функция, в
конце <tt class="METHODNAME">createStatusBar()</tt>, для инициализации
меток. Это совершенно необходимо, так как <tt class="VARNAME">
          Spreadsheet</tt> не выдает сигнал <tt class="METHODNAME">currentChanged()</tt> во время инициализации.
          <pre class="SCREEN">void MainWindow::spreadsheetModified() 
{ 
  modLabel-&gt;setText(tr("MOD")); 
  modified = true; 
  updateCellIndicators(); 
}
      
</pre>Слот <tt class="METHODNAME">spreadsheetModified()</tt> обновляет
все три индикатора и устанавливает признак <tt class="VARNAME">
          modified</tt> в <tt class="PARAMETER"><em>true</em></tt>.
          (Эта переменная используется для определения несохраненных
          изменений).
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="USINGDIALOGS"></a>3.5.
          Использование диалогов.</h1>

          <p>Здесь мы расскажем о принципах работы с диалогами в Qt --
          о том как они создаются, инициализируются, запускаются и как
          от них получить выбор, сделанный пользователем. Здесь мы
          будем использовать диалоги "Find",
          "Go-to-Cell" и "Sort", созданные нами в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER2">Главе 2</a>. Кроме того, мы создадим
          простенький диалог "About" ("О
          программе").</p>

          <p>Начнем с диалога "Find". Так как мы хотим, чтобы
          пользователь имел возможность переключаться между главным
          окном приложения и окном диалога, необходимо, чтобы
          диалоговое окно было НЕМОДАЛЬНЫМ. <span class="emphasis"><em class="EMPHASIS">Немодальным</em></span>
          называется такое окно, которое работает независимо от
          остальных окон приложения.</p>

          <p>Как правило, при создании немодальных диалогов, их сигналы
          подключаются к слотам, которые обеспечивают реакцию на
          действия пользователя.</p>
          <pre class="SCREEN">void MainWindow::find() 
{ 
  if (!findDialog) { 
    findDialog = new FindDialog(this); 
    connect(findDialog, SIGNAL(findNext(const QString &amp;, bool)), 
            spreadsheet, SLOT(findNext(const QString &amp;, bool))); 
    connect(findDialog, SIGNAL(findPrev(const QString &amp;, bool)), 
            spreadsheet, SLOT(findPrev(const QString &amp;, bool))); 
  } 
  
  findDialog-&gt;show(); 
  findDialog-&gt;raise(); 
  findDialog-&gt;setActiveWindow(); 
}
      
</pre>Диалог "Find" предназначен для выполнения поиска
некоторого значения в таблице. Слот <tt class="METHODNAME">find()</tt>
вызывается, когда пользователь выбирает пункт меню
          <strong class="COMMAND">"Edit|Find"</strong>, и
          предназначен для вывода диалогового окна на экран. С этого
          момента возможны три сценария дальнейшего развития событий:

          <ul>
            <li>
              <p>Пользователь вызвал диалог впервые.</p>
            </li>

            <li>
              <p>Диалог вызывался ранее, но после этого пользователь
              закрыл его.</p>
            </li>

            <li>
              <p>Диалог вызывался ранее и не закрывался (окно диалога
              видно на экране).</p>
            </li>
          </ul>Если диалог не был создан ранее, то он создается и
          устанавливаются соединения между сигналами <tt class="METHODNAME">findNext()</tt> и <tt class="METHODNAME">findPrev()</tt> диалога, и соответствующим
          слотами <tt class="VARNAME">Spreadsheet</tt>. Мы могли бы
          создать диалог и в конструкторе <tt class="METHODNAME">MainWindow</tt>, но не делаем этого по
          соображениям уменьшения времени, необходимого на запуск
          приложения.<br>
          <br>

          <p>Далее вызываются <tt class="METHODNAME">show()</tt>,
          <tt class="METHODNAME">raise()</tt> и <tt class="METHODNAME">setActiveWindow()</tt>, которые выводят окно
          диалога на экран, поверх других окон приложения, и
          активизируют его. Метод <tt class="METHODNAME">show()</tt>
          делает окно диалога видимым, но оно может уже присутствовать
          на экране -- в этом случае функция <tt class="METHODNAME">show()</tt> ничего не делает. Так как нам
          необходимо вывести диалог поверх других окон и активизировать
          его, мы должны вызвать <tt class="METHODNAME">raise()</tt> и
          <tt class="METHODNAME">setActiveWindow()</tt>. В качестве
          альтернативы можно предложить следующий код:</p>
          <pre class="SCREEN">  if (findDialog-&gt;isHidden()) { 
    findDialog-&gt;show(); 
  } else { 
    findDialog-&gt;raise(); 
    findDialog-&gt;setActiveWindow(); 
  }     
      
</pre>но он более медлительный.<br>
          <br>

          <p>Перейдем к диалогу "Go-to-Cell". В этом случае
          нет необходимости переключаться между окном приложения и
          окном диалога. Отсюда следует, что окно диалога
          "Go-to-Cell" должно быть МОДАЛЬНЫМ. <span class="emphasis"><em class="EMPHASIS">Модальным</em></span>
          называется такое окно, которое блокирует возможность
          взаимодействия пользователя с другими окнами приложения до
          тех пор, пока не будет закрыто модальное окно. Все диалоги
          нашего приложения, за исключением "Find", будут
          модальными.</p>

          <p>Немодальные диалоги вызываются при помощи функции
          <tt class="METHODNAME">show()</tt> (если перед этим не
          вызывалась функция <tt class="METHODNAME">setModal()</tt>,
          которая делает окно модальным). Модальные диалоги вызываются
          функцией <tt class="METHODNAME">exec()</tt>. Как правило, для
          модальных диалогов не требуется устанавливать соединения
          между сигналами и слотами.</p>
          <pre class="SCREEN">void MainWindow::goToCell() 
{ 
  GoToCellDialog dialog(this); 
  if (dialog.exec()) { 
    QString str = dialog.lineEdit-&gt;text(); 
    spreadsheet-&gt;setCurrentCell(str.mid(1).toInt() - 1, 
                                str[0].upper().unicode() -  'A' ); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">QDialog::exec()</tt> возвращает
<tt class="PARAMETER"><em>true</em></tt>, если результат диалога
принимается пользователем, и <tt class="PARAMETER"><em>false</em></tt>
-- в противном случае. (Помните? В главе 2 мы соединяли сигнал кнопки
OK со слотом <tt class="METHODNAME">accept()</tt>, а сигнал от кнопки
Cancel со слотом <tt class="METHODNAME">reject()</tt>.) Если
пользователь нажмет кнопку OK, то мы выполним переход к заданной
ячейке, если Cancel -- <tt class="METHODNAME">exec()</tt> вернет
<tt class="PARAMETER"><em>false</em></tt> и мы не будем ничего
предпринимать.<br>
          <br>

          <p>Функция <tt class="METHODNAME">QTable::setCurrentCell()</tt> принимает два
          аргумента: номер строки и номер колонки. В нашем приложении,
          адрес A1, например, соответствует ячейке (0, 0) в таблице, а
          адрес B27 -- ячейке (26, 1). Чтобы получить номер строки, из
          <tt class="CLASSNAME">QString</tt>, возвращаемой <tt class="METHODNAME">QLabel::text()</tt>, извлекается ее часть, с
          помощью <tt class="METHODNAME">QString::mid()</tt> и затем
          преобразуется в целое число с помощью <tt class="METHODNAME">QString::toInt()</tt>. После этого, из
          полученного числа вычитается единица (поскольку нумерация
          строк в <tt class="CLASSNAME">QTable</tt> начинается с 0).
          Чтобы получить номер колонки, из кода символа колонки мы
          просто вычитаем код символа "A".</p>

          <p>В отличие от диалога "Find", экземпляр диалога
          "Go-to-Cell" создается на стеке. Это общепринятая
          практика для модальных диалогов, вызываемых из разного рода
          меню, поскольку они становятся не нужны после их
          использования.</p>

          <p>А теперь перейдем к диалогу сортировки. Этот диалог так же
          является модальным и позволяет отсортировать выделенный
          дипазон ячеек по заданным колонкам. На рисунке 3.14 показан
          пример сортировки по колонкам B (первичный ключ) и A
          (вторичный ключ) в порядке возрастания.</p>

          <div class="INFORMALTABLE">
            <a name="AEN1760"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="400" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.14a.png"></p>

                      <div class="CAPTION">
                        <p>(а) До сортировки</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="400" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.14b.png"></p>

                      <div class="CAPTION">
                        <p>(б) После сортировки</p>
                      </div>
                    </div><br>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>Рисунок 3.14. Сортировка выбранного диапазона ячеек.
          <pre class="SCREEN">void MainWindow::sort() 
{ 
  SortDialog dialog(this); 
  QTableSelection sel = spreadsheet-&gt;selection(); 
  dialog.setColumnRange( A  + sel.leftCol(),  A  + sel.rightCol()); 
  
  if (dialog.exec()) { 
    SpreadsheetCompare compare; 
    compare.keys[0] = 
          dialog.primaryColumnCombo-&gt;currentItem(); 
    compare.keys[1] = 
          dialog.secondaryColumnCombo-&gt;currentItem() - 1; 
    compare.keys[2] = 
          dialog.tertiaryColumnCombo-&gt;currentItem() - 1; 
    compare.ascending[0] = 
          (dialog.primaryOrderCombo-&gt;currentItem() == 0); 
    compare.ascending[1] = 
          (dialog.secondaryOrderCombo-&gt;currentItem() == 0); 
    compare.ascending[2] = 
          (dialog.tertiaryOrderCombo-&gt;currentItem() == 0); 
    spreadsheet-&gt;sort(compare); 
  } 
}
      
</pre>Алгоритм функции <tt class="METHODNAME">sort()</tt>:

          <ul>
            <li>
              <p>Диалог создается на стеке и инициализируется.</p>
            </li>

            <li>
              <p>Диалог запускается вызовом <tt class="METHODNAME">exec()</tt></p>
            </li>

            <li>
              <p>Если пользователь нажал кнопку OK, то из виджетов
              диалога извлекается необходимая информация и выполняется
              сортировка.</p>
            </li>
          </ul>Объект <tt class="VARNAME">compare</tt> хранит
          первичный, вторичный и третичный ключи сортировки, а так же
          порядок сортировки по каждому из ключей. (Определение класса
          <tt class="CLASSNAME">SpreadsheetCompare</tt> мы опишем в
          следующей главе.) Этот объект используется функцией
          <tt class="METHODNAME">Spreadsheet::sort()</tt> для сравнения
          двух строк. Массив <tt class="VARNAME">keys</tt> хранит
          номера колонок-ключей. Например, если выбран диапазон ячеек с
          C2 по E5, то колонка C имеет номер 0. Массив <tt class="VARNAME">ascending</tt> хранит порядок сортировки для
          каждого из ключей. Функция <tt class="METHODNAME">QComboBox::currentItem()</tt> возвращает индекс
          текущего выбранного элемента списка, начиная с 0. Для
          вторичного и третичного ключей, из индекса вычитается 1,
          чтобы учесть элемент "None".<br>
          <br>

          <p>Реализация <tt class="METHODNAME">sort()</tt> очень
          чувствительна к дизайну диалога "Sort", точнее --
          эта "чувствительность" связана с выпадающими
          списками и элементами списков "None". Если вы
          измените диалог, то скорее всего вам придется изменить и код
          функции. Пока этот диалог вызывается из одного места в
          программе -- обслуживание его не так трудоемко. Но как только
          вы попытаетесь вызывать диалог из разных точек в программе,
          то обслуживание всех изменений, вносимых в него, может
          превратиться в кошмарный сон.</p>

          <p>Чтобы избежать подобных трудностей, можно порекомендовать
          сделать диалог более "интеллектуальным", который
          сам будет создавать экземпляр класса <tt class="CLASSNAME">SpreadsheetCompare</tt> и передавать его в
          вызывающую функцию. В этом случае функция <tt class="METHODNAME">sort()</tt> могла бы выглядеть так:</p>
          <pre class="SCREEN">void MainWindow::sort() 
{ 
  SortDialog dialog(this); 
  QTableSelection sel = spreadsheet-&gt;selection(); 
  dialog.setColumnRange( 'A' + sel.leftCol(), 'A' + sel.rightCol()); 
  if (dialog.exec()) 
    spreadsheet-&gt;performSort(dialog.comparisonObject()); 
}
      
</pre>Такой подход применяется к слабосвязанным компонентам и
практически всегда оправдан в тех случаях, когда один и тот же диалог
вызывается более чем из одного места в программе.<br>
          <br>

          <p>Более радикальный подход -- передать диалогу указатель на
          <tt class="VARNAME">Spreadsheet</tt> и позволить ему напрямую
          работать с таблицей. Это несколько снижает универсальность
          диалога, так как он теперь будет "привязан" к
          определенному типу виджета, но значительно упрощает код за
          счет отказа от функции <tt class="METHODNAME">SortDialog::setColumnRange()</tt>. В этом
          случае, код функции <tt class="METHODNAME">MainWindow::sort()</tt> приобретает такой
          вид:</p>
          <pre class="SCREEN">void MainWindow::sort() 
{ 
  SortDialog dialog(this); 
  dialog.setSpreadsheet(spreadsheet);      
  
  dialog.exec(); 
}  
      
</pre>Этот подход является полной противоположностью. Теперь уже не
программа должна "знать" архитектуру и алгоритм работы
диалога, а диалог должен "знать" об архитектуре вызывающей
программы. Такой подход может оказаться оправданным, когда диалогу
необходимо предоставить возможность оперативного изменения данных. Но и
в этом случае код программы крайне чувствителен к реализации
диалога.<br>
          <br>

          <p>Некоторые разработчики выбирают один из описанных
          вариантов и применяют только его. В этом есть свои
          преимущества, поскольку все диалоги имеют одинаковое
          строение, хотя при этом могут оказаться не использованными
          преимущества других подходов. В любом случае, решение о том,
          какой из подходов должен использоваться, необходимо принимать
          в каждом конкретном приложении, на основе требований,
          предъявляемых к диалогам.</p>

          <p>В завершение этого раздела мы создадим простенький диалог
          -- окно, содержащее сведения о программе и разработчике.
          Такой диалог можно создать самому, аналогично рассмотренным
          ранее диалогам "Find" или "Sort", но Qt
          предоставляет более простое решение.</p>
          <pre class="SCREEN">void MainWindow::about() 
{ 
  QMessageBox::about(this, tr("About Spreadsheet"), 
          tr("&lt;h2&gt;Spreadsheet 1.0&lt;/h2&gt;" 
          "&lt;p&gt;Copyright &amp;copy; 2003 Software Inc." 
          "&lt;p&gt;Spreadsheet is a small application that " 
          "demonstrates &lt;b&gt;QAction&lt;/b&gt;, &lt;b&gt;QMainWindow&lt;/b&gt;, " 
          "&lt;b&gt;QMenuBar&lt;/b&gt;, &lt;b&gt;QStatusBar&lt;/b&gt;, " 
          "&lt;b&gt;QToolBar&lt;/b&gt;, and many other Qt classes.")); 
}
      
</pre>Вызывается диалог функцией <tt class="METHODNAME">QMessageBox::about()</tt>. Очень похоже на функцию
<tt class="METHODNAME">QMessageBox::warning()</tt>, за одним маленьким
исключением: вместо стандартной иконки "warning",
используется иконка приложения.<br>
          <br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.15.png"></p>

            <div class="CAPTION">
              <p>Рисунок 3.15. Диалог с информацией о программе.</p>
            </div>
          </div><br>

          <p>До сих пор мы использовали ряд, очень удобных в обращении,
          статических функций-членов из классов <tt class="CLASSNAME">QMessageBox</tt> и <tt class="CLASSNAME">QFileDialog</tt>. Эти функции "на лету"
          создают диалоги, инициализируют их и вызывают функцию
          <tt class="METHODNAME">exec()</tt>. Но можно, хотя это и
          менее удобно, самому создать <tt class="CLASSNAME">QMessageBox</tt> или <tt class="CLASSNAME">QFileDialog</tt>, подобно любому другому виджету,
          и явно вызвать <tt class="METHODNAME">exec()</tt> или даже
          <tt class="METHODNAME">show()</tt>.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="STORINGSETTINGS"></a>3.6.
          Сохранение пользовательских настроек приложения.</h1>

          <p>В конструкторе <tt class="CLASSNAME">MainWindow</tt>, для
          загрузки пользовательских настроек, мы вызывали функцию
          <tt class="METHODNAME">readSettings()</tt>. Аналогично, для
          их сохранения, в обработчике <tt class="METHODNAME">closeEvent()</tt>, вызывалась функция <tt class="METHODNAME">writeSettings()</tt>. Пришло время рассмотреть
          реализацию обоих функций, которые являются методами класса
          <tt class="CLASSNAME">MainWindow</tt>.</p>

          <p>Для своего приложения, в качестве хранилища настроек, мы
          выбрали класс <tt class="CLASSNAME">QSettings</tt>. Экземпляр
          этого класса может быть создан и использован в любой момент,
          по мере необходимости.</p>
          <pre class="SCREEN">void MainWindow::writeSettings() 
{ 
  QSettings settings; 
  settings.setPath("software-inc.com", "Spreadsheet"); 
  settings.beginGroup("/Spreadsheet"); 
  settings.writeEntry("/geometry/x", x()); 
  settings.writeEntry("/geometry/y", y()); 
  settings.writeEntry("/geometry/width", width()); 
  settings.writeEntry("/geometry/height", height()); 
  settings.writeEntry("/recentFiles", recentFiles); 
  settings.writeEntry("/showGrid", showGridAct-&gt;isOn()); 
  settings.writeEntry("/autoRecalc", showGridAct-&gt;isOn()); 
  settings.endGroup(); 
}
      
</pre>Функция <tt class="METHODNAME">writeSettings()</tt> сохраняет
геометрию главного окна (положение на экране и размеры), список недавно
использовавшихся файлов и состояние флагов <strong class="COMMAND">
          Show Grid</strong> и <strong class="COMMAND">Auto-recalculate</strong>.<br>
          <br>

          <p>Место, куда <tt class="CLASSNAME">QSettings</tt> сохраняет
          настройки, зависит от используемой платформы. В Windows
          сохранение производится в системный реестр, в Unix -- в
          текстовый файл, в Mac OS X используется Carbon API. Методу
          <tt class="METHODNAME">setPath()</tt> передаются названия
          организации и программного продукта. Эти сведения
          используются для преобразование в платформо-зависимое
          представление места сохранения настроек.</p>

          <p>Настройки хранятся в виде пары: <span class="emphasis"><em class="EMPHASIS">ключ-значение</em></span>.
          Ключ очень похож на строку пути в файловой системе и всегда
          должен начинаться с названия приложения. Например, <tt class="PARAMETER"><em>/Spreadsheet/geometry/x</em></tt> или
          <tt class="PARAMETER"><em>/Spreadsheet/showGrid</em></tt>.
          (Функция <tt class="METHODNAME">beginGroup()</tt>
          "запоминает" префикс ключа - название приложения,
          которое будет автоматически подставляться в начало ключа, что
          позволяет нам сэкономить на своих усилиях.) Значение, той или
          иной настройки, может быть одного из пяти типов: <tt class="CLASSNAME">int, bool, double, QString</tt> или <tt class="CLASSNAME">QStringList</tt>.</p>
          <pre class="SCREEN">void MainWindow::readSettings() 
{ 
  QSettings settings; 
  settings.setPath("software-inc.com", "Spreadsheet"); 
  settings.beginGroup("/Spreadsheet"); 
  int x = settings.readNumEntry("/geometry/x", 200); 
  int y = settings.readNumEntry("/geometry/y", 200);      
  int w = settings.readNumEntry("/geometry/width", 400); 
  int h = settings.readNumEntry("/geometry/height", 400); 
  move(x, y); 
  resize(w, h); 
  
  recentFiles = settings.readListEntry("/recentFiles"); 
  updateRecentFileItems(); 
  
  showGridAct-&gt;setOn( 
          settings.readBoolEntry("/showGrid", true)); 
  autoRecalcAct-&gt;setOn( 
          settings.readBoolEntry("/autoRecalc", true)); 
          
  settings.endGroup(); 
}
      
</pre>Функция <tt class="METHODNAME">readSettings()</tt> загружает
настройки, предварительно сохраненные вызовом <tt class="METHODNAME">
          writeSettings()</tt>. Второй аргумент в
          "read"-функциях -- это значение по-умолчанию,
          возвращаемое в том случае, если запрошенный ключ отсутствует.
          Значения по-умолчанию используются на самом первом запуске
          приложения, когда настройки еще не были сохранены.<br>
          <br>

          <p>На этом мы заканчиваем рассмотрение реализации главного
          окна приложения. В следующих разделах мы покажем, как
          изменить наше приложение, чтобы оно могло работать
          одновременно с несколькими документами, и как добавить к
          приложению показ заставки во время загрузки.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="MULTIPLEDOCUMENTS"></a>3.7.
          Работа с несколькими документами одновременно.</h1>

          <p>Мы готовы приступить к созданию функции <tt class="METHODNAME">main()</tt>:</p>
          <pre class="SCREEN">#include &lt;qapplication.h&gt; 
#include "mainwindow.h" 

int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  MainWindow mainWin; 
  app.setMainWidget(&amp;mainWin); 
  mainWin.show(); 
  return app.exec(); 
}      
      
</pre>Эта функция немного отличается от того, что мы видели до сих пор:
экземпляр <tt class="CLASSNAME">MainWindow</tt> был создан на стеке,
без использования оператора <tt class="METHODNAME">new</tt>. Благодаря
этому, объект класса <tt class="CLASSNAME">MainWindow</tt> будет
уничтожен автоматически, по завершении работы функции.<br>
          <br>

          <p>В данном случае, программа Spreadsheet представляет из
          себя единственное главное окно, и может работать только с
          одним документом в каждый конкретный момент времени. Если нам
          потребуется работать с несколькими документами одновременно,
          мы должны будем запустить несколько экземпляров
          программы.</p>

          <p>Но для пользователя было бы гораздо удобнее, если бы
          программа могла запускать несколько главных окон с различными
          документами, как, например, это делают некоторые
          web-браузеры.</p>

          <p>Попробуем внести дополнительные изменения в нашу
          программу, чтобы она могла одновременно работать с
          несколькими документами. Для этого, прежде всего, необходимо
          немного изменить меню <strong class="COMMAND">File</strong>:</p>

          <div class="INFORMALTABLE">
            <a name="AEN1863"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="50%" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Пункт <strong class="COMMAND">File|New</strong> создает новое
                        главное окно с пустым документом, вместо того,
                        чтобы создавать новый документ в этом же
                        окне.</p>
                      </li>

                      <li>
                        <p>Пункт <strong class="COMMAND">File|Close</strong> закрывает текущее
                        главное окно.</p>
                      </li>

                      <li>
                        <p>Пункт <strong class="COMMAND">File|Exit</strong> закрывает все окна
                        приложения.</p>
                      </li>
                    </ul>
                  </td>

                  <td width="50%" align="left" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.16.png"></p>

                      <div class="CAPTION">
                        <p>Рисунок 3.16. Новое меню <strong class="COMMAND">File</strong>.</p>
                      </div>
                    </div><br>
                  </td>
                </tr>
              </tbody>
            </table>
          </div><br>
          <br>

          <p>В своем первоначальном варианте, меню <strong class="COMMAND">File</strong> не имело пункта <strong class="COMMAND">Close</strong>, поскольку смысл операции закрытия
          окна был равносилен завершению приложения (пункт
          <strong class="COMMAND">Exit</strong>).</p>

          <p>Так выглядит новый вариант функции <tt class="METHODNAME">main()</tt>:</p>
          <pre class="SCREEN">#include &lt;qapplication.h&gt; 
#include "mainwindow.h" 

int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  MainWindow *mainWin = new MainWindow; 
  mainWin-&gt;show(); 
  QObject::connect(&amp;app, SIGNAL(lastWindowClosed()), 
                   &amp;app, SLOT(quit())); 
  return app.exec(); 
}      
      
</pre>Здесь мы связали сигнал <tt class="METHODNAME">lastWindowClosed()</tt> со слотом <tt class="METHODNAME">
          quit()</tt>, который завершает приложение.<br>
          <br>

          <p>В данном варианте, теперь имеет смысл создавать экземпляр
          <tt class="CLASSNAME">MainWindow</tt> оператором <tt class="METHODNAME">new</tt>, поскольку затем, при закрытии окна, он
          будет удаляться оператором <tt class="METHODNAME">delete</tt>. Эта необходимость не возникает в
          случае приложения, которое работает с единственным
          документом.</p>

          <p>Ниже приводится измененный вариант слота <tt class="METHODNAME">MainWindow::newFile()</tt>:</p>
          <pre class="SCREEN">void MainWindow::newFile() 
{ 
  MainWindow *mainWin = new MainWindow; 
  mainWin-&gt;show(); 
}      
      
</pre>Здесь просто создается новый экземпляр <tt class="CLASSNAME">
          MainWindow</tt>. Может показаться странным, что мы нигде не
          запоминаем указатель на вновь созданный объект, но здесь нет
          никакой ошибки -- Qt хранит указатели на все окна сама, без
          нашего участия.<br>
          <br>

          <p>Ниже приводится код, создающий "действия"
          (actions) <strong class="COMMAND">Close</strong> и
          <strong class="COMMAND">Exit</strong>:</p>
          <pre class="SCREEN">  closeAct = new QAction(tr("&amp;Close"), tr("Ctrl+W"), this); 
  connect(closeAct, SIGNAL(activated()), this, SLOT(close())); 
  
  exitAct = new QAction(tr("E&amp;xit"), tr("Ctrl+Q"), this); 
  connect(exitAct, SIGNAL(activated()), qApp, SLOT(closeAllWindows()));      
      
</pre>Слот <tt class="METHODNAME">closeAllWindows()</tt> закрывает все
окна приложения, кроме тех, которые отвергнут событие
          <tt class="PARAMETER"><em>close</em></tt>. Это в точности
          соответствует нашим требованиям. Нам нет нужды беспокоиться о
          несохраненных изменениях, поскольку сохранение выполняется в
          обработчике <tt class="METHODNAME">MainWindow::closeEvent()</tt>, при закрытии
          окна.<br>
          <br>

          <p>Теперь наше приложение в состоянии работать с несколькими
          окнами. К сожалению, на данный момент у нас в программе
          кроется трудноуловимая ошибка. Если пользователь будет
          создавать и закрывать окна приложения, то может наступить
          момент, когда вся доступная память в машине будет исчерпана!
          Это происходит потому, что мы создаем новые окна, выбирая
          пункт меню <strong class="COMMAND">File|New</strong>, но
          нигде не удаляем их из памяти. Когда пользователь закрывает
          очередное окно, то объект класса <tt class="CLASSNAME">MainWindow</tt> не удаляется из памяти, а просто
          делается невидимым.</p>

          <p>Решение этой проблемы заключается в добавлении флага
          <tt class="PARAMETER"><em>WDestructiveClose</em></tt> в
          конструктор:</p>
          <pre class="SCREEN">MainWindow::MainWindow(QWidget *parent, const char *name) 
    : QMainWindow(parent, name, WDestructiveClose) 
{ 
  ...
}
      
</pre>Он вынуждает Qt удалять объект окна при его закрытии. Этот флаг
один из множества, которые могут быть переданы в конструктор наследника
от <tt class="CLASSNAME">QWidget</tt>, но другие флаги используются
довольно редко.<br>
          <br>

          <p>Однако, утечка памяти -- не единственная проблема, с
          которой мы можем столкнуться. Весь наш первоначальный дизайн
          предполагал работу с единственным главным окном. Теперь,
          каждое из окон приложения может иметь свой список недавно
          использовавшихся файлов и свои дополнительные настройки.
          Совершенно очевидно, что список недавно использовавшихся
          файлов должен быть глобальным для всего приложения. Сделать
          это можно довольно легко, достаточно просто объявить
          переменную <tt class="VARNAME">recentFiles</tt> статической.
          Но, теперь везде, где необходимо вызвать <tt class="METHODNAME">updateRecentFileItems()</tt> для обновления меню
          <strong class="COMMAND">File</strong>, мы должны вызвать эту
          функцию для всех главных окон. Ниже приводится код, который
          делает это: <a name="P66"></a></p>
          <pre class="SCREEN">  QWidgetList *list = QApplication::topLevelWidgets(); 
  QWidgetListIt it(*list); 
  QWidget *widget; 
  while ((widget = it.current())) { 
    if (widget-&gt;inherits("MainWindow")) 
      ((MainWindow *)widget)-&gt;updateRecentFileItems(); 
      ++it; 
  } 
  delete list;      
      
</pre>Здесь выполняется перебор всех виджетов верхнего уровня и
вызывается функция <tt class="METHODNAME">updateRecentFileItems()</tt>
во всех экземплярах <tt class="CLASSNAME">MainWindow</tt>. Аналогичный
подход может быть использован для синхронизации флагов
          <tt class="PARAMETER"><em>Show Grid</em></tt> и <tt class="PARAMETER"><em>Auto-recalculate</em></tt>, а так же для
          предотвращения загрузки одного и того же документа дважды.
          Тип <tt class="CLASSNAME">QWidgetList</tt> определен как
          <tt class="CLASSNAME">QPtrList&lt;QWidget&gt;</tt>, который
          будет обсуждаться в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER11">Главе 11
          (Классы-контейнеры)</a>.<br>
          <br>

          <div class="INFORMALTABLE">
            <a name="AEN1932"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="400" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.17a.png"></p>
                    </div>
                  </td>

                  <td width="400" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.17b.png"></p>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>Рисунок 3.17. SDI и MDI.<br>
          <br>

          <p>Когда приложение открывает каждый следующий документ в
          новом окне, то говорят, что приложение относится к классу
          SDI-приложений (от англ. single document interface --
          однодокументный интерфейс). Популярная альтернатива SDI --
          MDI (от англ. multiple document interface -- многодокументный
          интерфейс), в этом случае приложение имеет одно главное окно,
          которое может включать в себя несколько дочерних окон с
          открытыми документами и разделяющими между собой пространство
          главного окна. С помощью Qt можно создавать как SDI, так и
          MDI приложения. На рисунке 3.17 показаны оба варианта
          оформления приложения Spreadsheet. Более подробно MDI будет
          описан в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER6">Главе 6</a>.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SPLASHSCREENS"></a>3.8.
          Экран-заставка.</h1>

          <p>Многие приложения показывают заставку во время запуска.
          Одни разработчики "показывают" заставку, чтобы
          снизить психологическое давление на пользователя, ожидающего
          пока приложение загрузится, другие -- в рекламных целях.
          Добавление экрана-заставки к приложению -- довольно простая
          задача.</p>

          <p>В Qt реализация экрана-заставки выполнена в виде класса
          <tt class="CLASSNAME">QSplashScreen</tt>, который выводит на
          экран окно с изображением до того, как приложение будет
          полностью загружено. Имеется возможность отображать ход
          загрузки на заставке. Код, который выводит заставку на экран,
          как правило размещается в функции <tt class="METHODNAME">main()</tt>, перед вызовом <tt class="METHODNAME">QApplication::exec()</tt>.</p>

          <p>Ниже показан пример функции <tt class="METHODNAME">main()</tt>, использующей <tt class="CLASSNAME">QSplashScreen</tt> для вывода заставки на время
          загрузки дополнительных модулей и установки соединения по
          сети.</p>
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv);  
  QSplashScreen *splash = 
          new QSplashScreen(QPixmap::fromMimeSource("splash.png")); 
  splash-&gt;show(); 
  
  splash-&gt;message(QObject::tr("Setting up the main window..."), 
                  Qt::AlignRight | Qt::AlignTop, Qt::white); 
  MainWindow mainWin; 
  app.setMainWidget(&amp;mainWin); 
  
  splash-&gt;message(QObject::tr("Loading modules..."),
                  Qt::AlignRight | Qt::AlignTop, Qt::white); 
  loadModules(); 
  
  splash-&gt;message(QObject::tr("Establishing connections..."), 
                  Qt::AlignRight | Qt::AlignTop, Qt::white); 
  establishConnections(); 
  
  mainWin.show(); 
  splash-&gt;finish(&amp;mainWin); 
  delete splash; 
  
  return app.exec(); 
}
      
</pre>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig3.18.png"></p>

            <div class="CAPTION">
              <p>Рисунок 3.18. Виджет QSplashScreen.</p>
            </div>
          </div><br>
          На этом мы завершаем разработку пользовательского интерфейса
          приложения Spreadsheet и в следующей главе перейдем к
          реализации основной его функциональности.
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER4"></a>Глава 4. Реализация функциональности
        приложения.</h1>

        <p>В предыдущих двух главах мы описывали процесс создания
        пользовательского интерфейса приложения Spreadsheet. В этой
        главе мы наполним свое приложение необходимой
        функциональностью. Кроме всего прочего, мы рассмотрим -- как
        загружать и сохранять документы, как хранить данные в памяти,
        как реализовать операции с буфером обмена и как добавить
        поддержку формул электронной таблицы в компонент <tt class="CLASSNAME">QTable</tt>.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="THECENTRALWIDGET"></a>4.1.
          Центральный виджет.</h1>

          <p>Центральная область окна приложения может быть занята
          виджетом любого типа. Рассмотрим возможные варианты:</p>

          <ol type="1">
            <li>
              <p><strong class="COMMAND">Стандартный виджет
              Qt.</strong></p>

              <p>В качестве центрального виджета может быть использован
              один из стандартного набора, предлагаемого библиотекой
              Qt, например, <tt class="CLASSNAME">QTable</tt> или
              <tt class="CLASSNAME">QTextEdit</tt>. В этом случае
              функциональность приложения должна быть реализована
              отдельно (например в потомке класса <tt class="CLASSNAME">QMainWindow</tt>).</p>
            </li>

            <li>
              <p><strong class="COMMAND">Виджет, созданный
              разработчиком.</strong></p>

              <p>Для специализированных применений, разработчики
              достаточно часто создают свои собственные виджеты.
              Например, программа редактирования файлов с иконками
              может иметь, в качестве центрального, виджет <tt class="CLASSNAME">IconEditor</tt>. В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER5">Главе
              5</a> мы рассмотрим проблему создания своих виджетов.</p>
            </li>

            <li>
              <p><strong class="COMMAND">Обычный QWidget с менеджером
              размещения.</strong></p>

              <p>Иногда область окна приложения заполняют несколько
              виджетов. В этом случае, в качестве центрального,
              создается виджет <tt class="CLASSNAME">QWidget</tt>,
              который выступает в роли владельца для всех других
              виджетов и использует менеджер размещения для их
              компоновки.</p>
            </li>

            <li>
              <p><strong class="COMMAND">Splitter
              (разделитель)</strong></p>

              <p>Другой способ размещения нескольких виджетов в окне --
              использовать разделитель (QSplitter). <tt class="CLASSNAME">QSplitter</tt> размещает подчиненные виджеты
              по горизонтали, подобно <tt class="CLASSNAME">QHBox</tt>,
              или по вертикали, подобно <tt class="CLASSNAME">QVBox</tt>, с возможностью управления
              размерами виджетов по одной из осей. Разделители могут
              содержать в себе виджеты любого другого типа, в том числе
              и другие разделители.</p>
            </li>

            <li>
              <p><strong class="COMMAND">Рабочее пространство
              MDI</strong></p>

              <p>Если приложение реализует многодокументный интерфейс
              (MDI), то в этом случае всю область окна занимает виджет
              <tt class="CLASSNAME">QWorkspace</tt>, а каждое дочернее
              окно является подчиненным, по отношению к нему.</p>
            </li>
          </ol><br>
          <br>

          <p>Области размещения (layouts), разделители (splitters) и
          рабочие пространства MDI могут комбинироваться как со
          стандартными виджетами Qt, так и с виджетами, разработанными
          вами. В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER6">Главе 6</a> мы рассмотрим эти
          классы поближе.</p>

          <p>В нашем примере, в качестве центрального, используется
          виджет, порожденный от <tt class="CLASSNAME">QTable</tt>.
          Класс <tt class="CLASSNAME">QTable</tt> уже имеет многое из
          того, что нам необходимо, но он не поддерживает формулы,
          например: "=A1+A2+A3", а так же не поддерживает
          операции с буфером обмена. Поэтому мы займемся добавлением
          необходимой функциональности в виде класса <tt class="CLASSNAME">Spreadsheet</tt>, потомка класса <tt class="CLASSNAME">QTable</tt>.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SUBCLASSINGQTABLE"></a>4.2.
          Создание класса-потомка от QTable.</h1>

          <p>Начнем создание нашего класса <tt class="CLASSNAME">Spreadsheet</tt> с оформления файла
          заголовка:</p>
          <pre class="SCREEN">#ifndef SPREADSHEET_H 
#define SPREADSHEET_H 

#include &lt;qstringlist.h&gt; 
#include &lt;qtable.h&gt; 

class Cell; 
class SpreadsheetCompare;      
      
</pre>Заголовочный файл начинается с опережающего описания классов
<tt class="CLASSNAME">Cell</tt> и <tt class="CLASSNAME">SpreadsheetCompare</tt>.<br>
          <br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig4.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 4.1. Дерево наследования классов Spreadsheet и
              Cell.</p>
            </div>
          </div><br>

          <p>Атрибуты ячейки в <tt class="CLASSNAME">QTable</tt>, такие
          как текст и выравнивание, хранятся в элементе <tt class="CLASSNAME">QTableItem</tt>. В отличие от <tt class="CLASSNAME">QTable</tt>, класс <tt class="CLASSNAME">QTableItem</tt> не является виджетом и
          предназначен исключительно для хранения данных. Класс
          <tt class="CLASSNAME">Cell</tt> порожден от <tt class="CLASSNAME">QTableItem</tt>. В дополнение к атрибутам
          родительского класса, он имеет возможность хранить формулу
          вычисления содержимого ячейки.</p>

          <p>Мы подробно обсудим реализацию класса <tt class="CLASSNAME">Cell</tt> в последнем разделе этой главы.</p>
          <pre class="SCREEN">class Spreadsheet : public QTable 
{ 
  Q_OBJECT 
public: 
  Spreadsheet(QWidget *parent = 0, const char *name = 0); 
  
  void clear(); 
  QString currentLocation() const; 
  QString currentFormula() const; 
  bool autoRecalculate() const { return autoRecalc; } 
  bool readFile(const QString &amp;fileName); 
  bool writeFile(const QString &amp;fileName); 
  QTableSelection selection(); 
  void sort(const SpreadsheetCompare &amp;compare);
      
</pre>Класс <tt class="CLASSNAME">Spreadsheet</tt> является потомком
класса <tt class="CLASSNAME">QTable</tt>.<br>
          <br>

          <p>В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">Главе 3</a>, при разработке
          <tt class="CLASSNAME">MainWindow</tt>, мы уже использовали
          некоторые из публичных методов <tt class="CLASSNAME">Spreadsheet</tt>. Например, мы вызывали
          <tt class="METHODNAME">clear()</tt> из <tt class="METHODNAME">MainWindow::newFile()</tt>. Кроме того были
          использованы некоторые функции, унаследованные от <tt class="CLASSNAME">QTable</tt>, например <tt class="METHODNAME">setCurrentCell()</tt> и <tt class="METHODNAME">setShowGrid()</tt>.</p>
          <pre class="SCREEN">public slots: 
  void cut(); 
  void copy(); 
  void paste(); 
  void del(); 
  void selectRow(); 
  void selectColumn(); 
  void selectAll(); 
  void recalculate(); 
  void setAutoRecalculate(bool on); 
  void findNext(const QString &amp;str, bool caseSensitive); 
  void findPrev(const QString &amp;str, bool caseSensitive); 

signals: 
  void modified();      
      
</pre><tt class="CLASSNAME">Spreadsheet</tt> предоставляет несколько
слотов, которые реализуют функциональность пунктов меню
          <strong class="COMMAND">Edit, Tools</strong> и <strong class="COMMAND">Options</strong>.
          <pre class="SCREEN">protected: 
  QWidget *createEditor(int row, int col, bool initFromCell) const; 
  void endEdit(int row, int col, bool accepted, bool wasReplacing);      
      
</pre>Дополнительно он перекрывает реализацию ряда виртуальных функций
<tt class="CLASSNAME">QTable</tt>, которые вызываются, когда
пользователь изменяет значение в ячейке. Это необходимо для поддержки
формул в ячейках.
          <pre class="SCREEN">private: 
  enum { MagicNumber = 0x7F51C882, NumRows = 999, NumCols = 26 }; 
  
  Cell *cell(int row, int col) const; 
  void setFormula(int row, int col, const QString &amp;formula); 
  QString formula(int row, int col) const; 
  void somethingChanged(); 
  
  bool autoRecalc; 
};
      
</pre>В приватной секции мы определили три константы, четыре функции и
одну переменную.
          <pre class="SCREEN">class SpreadsheetCompare 
{ 
public: 
  bool operator()(const QStringList &amp;row1, 
                  const QStringList &amp;row2) const; 
  
  enum { NumKeys = 3 }; 
  int keys[NumKeys]; 
  bool ascending[NumKeys]; 
}; 
#endif      
      
</pre>Заголовочный файл завершается определением класса
          <tt class="CLASSNAME">SpreadsheetCompare</tt>. Мы опишем его,
          когда коснемся реализации метода <tt class="METHODNAME">Spreadsheet::sort()</tt>.<br>
          <br>

          <p>Теперь перейдем к рассмотрению реализации каждой из
          функций:</p>
          <pre class="SCREEN">#include &lt;qapplication.h&gt; 
#include &lt;qclipboard.h&gt; 
#include &lt;qdatastream.h&gt; 
#include &lt;qfile.h&gt; 
#include &lt;qlineedit.h&gt; 
#include &lt;qmessagebox.h&gt; 
#include &lt;qregexp.h&gt; 
#include &lt;qvariant.h&gt; 

#include &lt;algorithm&gt; 
#include &lt;vector&gt; 
using namespace std; 

#include "cell.h" 
#include "spreadsheet.h"      
      
</pre>Мы подключили заголовочные файлы классов, использующихся в
приложении, а так же стандартные заголовки C++: <tt class="FILENAME">
          &lt;algorithm&gt;</tt> и <tt class="FILENAME">&lt;vector&gt;</tt>. Директива <tt class="PARAMETER"><em>using namespace</em></tt> импортирует все
          имена из пространства <tt class="PARAMETER"><em>std</em></tt>
          в глобальное пространство имен, что позволяет использовать
          сокращенную форму записи: <tt class="METHODNAME">stable_sort()</tt> и <tt class="METHODNAME">vector&lt;?&gt;</tt> вместо полной формы:
          <tt class="METHODNAME">std::stable_sort()</tt> и <tt class="METHODNAME">std::vector&lt;?&gt;</tt>.
          <pre class="SCREEN">Spreadsheet::Spreadsheet(QWidget *parent, const char *name) 
    : QTable(parent, name) 
{ 
  autoRecalc = true; 
  setSelectionMode(Single); 
  clear(); 
}
      
</pre>В конструкторе устанавливается режим выборки строк в
          <tt class="CLASSNAME">QTable</tt> -- <tt class="PARAMETER"><em>Single</em></tt>. Это означает, что в таблице
          может существовать только одна выделенная область ячеек, в
          каждый конкретный момент времени.
          <pre class="SCREEN">void Spreadsheet::clear() 
{ 
  setNumRows(0); 
  setNumCols(0); 
  setNumRows(NumRows); 
  setNumCols(NumCols); 
  for (int i = 0; i &lt; NumCols; i++) 
    horizontalHeader()-&gt;setLabel(i, QChar('A' + i)); 
  setCurrentCell(0, 0); 
}
      
</pre>Функция <tt class="METHODNAME">clear()</tt> вызывается для
инициализации таблицы, в конструкторе и в <tt class="METHODNAME">
          MainWindow::newFile()</tt>.<br>
          <br>

          <p>Собственно очистка производится за счет изменения размера
          таблицы до (0 X 0), после чего восстановливается ее
          первоначальный размер (26 X 999). Затем выполняется
          заполнение меток столбцов: "A", "B", ...,
          "Z" (номера столбцов 1, 2, ..., 26, соответственно)
          и перемещение курсора в ячейку A1.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig4.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 4.2. Виджеты, составляющие QTable.</p>
            </div>
          </div><br>
          <tt class="CLASSNAME">QTable</tt> состоит из нескольких
          подчиненных виджетов. В их число входят: горизонтальный
          заголовок -- <tt class="CLASSNAME">QHeader</tt>, находящийся
          в верхней части; вертикальный заголовок -- <tt class="CLASSNAME">QHeader</tt>, находящийся слева; полосы прокрутки
          -- <tt class="CLASSNAME">QScrollBar</tt> справа и снизу.
          Центральную область занимает специальный виджет, который
          называется <tt class="CLASSNAME">viewport</tt>, в котором
          <tt class="CLASSNAME">QTable</tt> рисует сетку с ячейками.
          Доступ к подчиненным виджетам реализуется через функции
          <tt class="CLASSNAME">QTable</tt> и его базового класса
          <tt class="CLASSNAME">QScrollView</tt>. Например, в функции
          <tt class="METHODNAME">clear()</tt> мы обращались к
          горизонтальному заголовку через вызов <tt class="METHODNAME">QTable::horizontalHeader()</tt>.<br>
          <br>

          <div class="INFORMALTABLE">
            <a name="AEN2084"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <thead style="background:black; color:white">
                <tr>
                  <th width="100%" align="center" valign="middle">
                    <pre class="SCREEN">            
</pre>Хранение данных в виде отдельных объектов
                    <pre class="SCREEN">            
</pre>
                  </th>
                </tr>
              </thead>

              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="100%" align="left" valign="top">
                    <p>В приложении Spreadsheet, все не пустые ячейки
                    хранятся в памяти, в виде отдельных объектов
                    <tt class="CLASSNAME">QTableItem</tt>. Этот способ
                    присущ не только <tt class="CLASSNAME">QTable</tt>,
                    такие классы, как <tt class="CLASSNAME">QIconView</tt>, <tt class="CLASSNAME">QListBox</tt> и <tt class="CLASSNAME">QListView</tt> тоже хранят свои данные
                    в виде отдельных элементов (<tt class="CLASSNAME">QIconViewItem</tt>, <tt class="CLASSNAME">QListBoxItem</tt> и <tt class="CLASSNAME">QListViewItem</tt>,
                    соответственно).</p>

                    <p>Классы элементов используются в Qt для хранения
                    данных. Например, <tt class="CLASSNAME">QTableItem</tt> может хранить такие
                    данные, как строка, рисунок и указатель на таблицу
                    <tt class="CLASSNAME">QTable</tt>. Создавая класс,
                    наследник от класса элемента, мы можем расширить
                    его возможности и хранить в нем дополнительные
                    данные, а за счет перекрытия виртуальных функций --
                    управлять этими данными.</p>

                    <p>Некоторые библиотеки, при реализации своих
                    элементов хранения данных, предусматривают в них
                    дополнительный указатель типа <tt class="CLASSNAME">void</tt>, который может использоваться
                    для присоединения к элементу дополнительных данных.
                    Qt не следует этому примеру и не обременяет свои
                    классы лишними указателями, которые могут не
                    использоваться. Вместо этого, она дает
                    программистам свободу создания дочерних классов и
                    возможность подстраивать их под свои нужды. Если
                    вам так необходим дополнительный указатель на
                    внешнюю структуру данных, то вы с легкостью сможете
                    добавить его в дочернем классе.</p>

                    <p>В <tt class="CLASSNAME">QTable</tt> достаточно
                    просто можно "обойти" механизм работы с
                    элементами, путем повторной реализации
                    низкоуровневых функций, таких как <tt class="METHODNAME">paintCell()</tt> и <tt class="METHODNAME">clearCell()</tt>. Если данные,
                    отображаемые в <tt class="CLASSNAME">QTable</tt>,
                    уже находятся в памяти или во внешних структурах,
                    то такой способ поможет избежать ненужного
                    дублирования информации. За подробностями
                    обращайтесь к статье <a href="http://doc.trolltech.com/qq/qq07-big-tables.html" target="_top">"A Model/View Table for Large
                       Datasets"</a>.</p>

                    <p>Ожидается, что Qt 4, в этом отношении, будет
                    проявлять большую гибкость, чем Qt 3. Кроме того,
                    Qt 4 вероятно предложит единственный
                    унифицированный класс элемента данных, используемый
                    всеми классами отображения, допуская показ одного и
                    того же элементами различными способами.</p>
                  </td>
                </tr>
              </tbody>

              <tfoot style="background:black; color:white">
                <tr>
                  <th width="100%" align="center" valign="middle">
                    <pre class="SCREEN">            
</pre>---
                    <pre class="SCREEN">            
</pre>
                  </th>
                </tr>
              </tfoot>
            </table>
          </div>

          <p><tt class="CLASSNAME">QScrollView</tt> -- это единственный
          базовый класс для виджетов, которые могут отображать
          значительные объемы данных. Он предоставляет область
          просмотра и две полосы прокрутки, которые могут быть включены
          и выключены. Подробнее мы остановимся на этом в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER6">Главе 6</a>.</p>
          <pre class="SCREEN">Cell *Spreadsheet::cell(int row, int col) const 
{ 
  return (Cell *)item(row, col); 
}
      
</pre>Приватная функция <tt class="METHODNAME">cell()</tt> возвращает
указатель на объект, находящийся на пересечении заданных строки и
столбца. Это практически то же самое, что и <tt class="METHODNAME">
          QTable::item()</tt>, за исключением того, что она возвращает
          указатель на экземпляр класса <tt class="CLASSNAME">Cell</tt>, а не <tt class="CLASSNAME">QTableItem</tt>.
          <pre class="SCREEN">QString Spreadsheet::formula(int row, int col) const 
{ 
  Cell *c = cell(row, col); 
  if (c) 
    return c-&gt;formula(); 
  else      
    return ""; 
}  
      
</pre>Функция <tt class="METHODNAME">formula()</tt> возвращает формулу
для заданной ячейки. Если <tt class="METHODNAME">cell()</tt> вернет
пустой указатель (ячейка отсутствует, т.е. пустая), то в качестве
формулы возвращается пустая строка.
          <pre class="SCREEN">void Spreadsheet::setFormula(int row, int col, 
                             const QString &amp;formula) 
{ 
  Cell *c = cell(row, col); 
  if (c) { 
    c-&gt;setFormula(formula); 
    updateCell(row, col); 
  } else { 
    setItem(row, col, new Cell(this, formula)); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">setFormula()</tt> устанавливает
формулу вычисления для заданной ячейки. Если объект хранения данных для
ячейки уже существует, то формула записывается в этот объект и затем
вызывается <tt class="METHODNAME">updateCell()</tt>, чтобы сообщить
<tt class="CLASSNAME">QTable</tt> о необходимости перерисовать ячейку
(если она видна на экране). В противном случае создается новый объект
<tt class="CLASSNAME">Cell</tt> и вызывается <tt class="METHODNAME">
          QTable::setItem()</tt>, для вставки объекта в таблицу и
          перерисовки ячейки. Нам нет нужды беспокоиться об уничтожении
          <tt class="CLASSNAME">Cell</tt>, поскольку <tt class="CLASSNAME">QTable</tt> берет владение объектом на себя и
          сама удалит его, когда придет время.
          <pre class="SCREEN">QString Spreadsheet::currentLocation() const 
{ 
  return QChar('A' + currentColumn()) 
         + QString::number(currentRow() + 1); 
}
      
</pre>Функция <tt class="METHODNAME">currentLocation()</tt> возвращает
"адрес" ячейки, в обычном, для электронной таблицы, формате,
где за символом, обозначающим столбец, следует номер строки.
          <tt class="METHODNAME">MainWindow::updateCellIndicators()</tt>
          использует эту функцию для отображения адреса текущей ячейки
          в строке состояния.
          <pre class="SCREEN">QString Spreadsheet::currentFormula() const 
{ 
  return formula(currentRow(), currentColumn()); 
}
      
</pre>Функция <tt class="METHODNAME">currentFormula()</tt> возвращает
формулу для текущей ячейки. Она также вызывается из
          <tt class="METHODNAME">MainWindow::updateCellIndicators()</tt>.
          <pre class="SCREEN">QWidget *Spreadsheet::createEditor(int row, int col, 
                                   bool initFromCell) const 
{ 
  QLineEdit *lineEdit = new QLineEdit(viewport()); 
  lineEdit-&gt;setFrame(false); 
  if (initFromCell) 
    lineEdit-&gt;setText(formula(row, col)); 
  return lineEdit; 
}
      
</pre>Функция <tt class="METHODNAME">createEditor()</tt> перекрывает
реализацию в <tt class="CLASSNAME">QTable</tt>. Она вызывается, когда
пользователь начинает редактирование содержимого ячейки -- либо после
щелчка мышью по ячейке, либо по нажатии на клавишу
          <strong class="COMMAND">F2</strong>, либо когда пользователь
          просто начинает набирать текст. Назначение этой функции
          заключается в создании виджета-редактора, который будет
          отображаться поверх ячейки. Если функция вызывается по щелчку
          мыши или по нажатию на клавишу <strong class="COMMAND">F2</strong>, то <tt class="PARAMETER"><em>initFromCell</em></tt> получает значение
          <tt class="PARAMETER"><em>true</em></tt>, в результате
          производится редактирование существующего содержимого ячейки,
          иначе -- прежние данные игнорируются.<br>
          <br>

          <p><tt class="METHODNAME">createEditor()</tt> создает объект
          класса <tt class="CLASSNAME">QLineEdit</tt> и записывает в
          него содержимое ячейки, если <tt class="PARAMETER"><em>initFromCell</em></tt> содержит значение
          <tt class="PARAMETER"><em>true</em></tt>. Мы выполнили
          повторную реализацию этой функции для того, чтобы показывать
          формулу ячейки вместо ее содержимого.</p>

          <p>Объект <tt class="CLASSNAME">QLineEdit</tt> создается как
          подчиненный области просмотра <tt class="CLASSNAME">QTable</tt>. В свою очередь <tt class="CLASSNAME">QTable</tt> берет на себя обязательство по
          установке размеров и положения <tt class="CLASSNAME">QLineEdit</tt> на экране такими, чтобы они
          полностью совпадали с размерами и положением ячейки. Она так
          же берется автоматически уничтожить объект <tt class="CLASSNAME">QLineEdit</tt>, когда необходимость в нем
          отпадет.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig4.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 4.3. Редактирование ячейки за счет подстановки
              QLineEdit.</p>
            </div>
          </div><br>
          В большинстве случаев, формула и содержимое ячейки -- суть
          одно и то же. Например, формула "Hello"
          превращается в строку "Hello". Таким образом, если
          пользователь напечатает в ячейке слово "Hello" и
          нажмет Enter, то ячейка будет отображать слово
          "Hello". Однако тут есть ряд исключений:

          <ul>
            <li>
              <p>Если формула -- это число, то она будет
              интерпретирована как число. Например, формула
              "1.50" интерпретируется как число 1.5, типа
              <tt class="CLASSNAME">double</tt>, и отображается в
              таблице с выравниванием по правому краю.</p>
            </li>

            <li>
              <p>Если формула начинается с одиночной кавычки, то она
              интерпретируется как текст. Например, формула
              "'12345" будет интерпретирована как строка
              символов "12345".</p>
            </li>

            <li>
              <p>Если формула начинается с символа "=", то
              она будет интерпретирована как арифметическое выражение.
              Например, если ячейка A1 содержит "12", а A2 --
              "6", то формула "=A1+A2" вернет сумму
              "18".</p>
            </li>
          </ul>Действия по преобразованию формулы в значение
          выполняются классом <tt class="CLASSNAME">Cell</tt>. Важное
          примечание: имейте ввиду, что текст, отображаемый в ячейке,
          это результат преобразования формулы, а не сама формула.
          <pre class="SCREEN">void Spreadsheet::endEdit(int row, int col, bool accepted, 
                          bool wasReplacing) 
{ 
  QLineEdit *lineEdit = (QLineEdit *)cellWidget(row, col); 
  if (!lineEdit) 
    return; 
  QString oldFormula = formula(row, col); 
  QString newFormula = lineEdit-&gt;text(); 
  
  QTable::endEdit(row, col, false, wasReplacing); 
  
  if (accepted &amp;&amp; newFormula != oldFormula) { 
    setFormula(row, col, newFormula);
    somethingChanged(); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">endEdit()</tt> перекрывает
аналогичную в <tt class="CLASSNAME">QTable</tt>. Она вызывается, когда
пользователь завершает редактирование ячейки -- либо щелчком мыши по
любой другой ячейке (что подтверждает внесенные изменения), либо
нажатием на клавишу Enter (что так же подтверждает внесенные
изменения), либо нажатием на клавишу Esc (что отвергает внесенные
изменения). Основное назначение функции -- переместить содержимое
компонента редактора в объект <tt class="CLASSNAME">Cell</tt>, если
внесенные изменения подтверждены.<br>
          <br>

          <p>Доступ к редактору выполняется через обращение к
          <tt class="METHODNAME">QTable::cellWidget()</tt>. Мы можем
          без опаски выполнить приведение типа к <tt class="CLASSNAME">QLineEdit</tt>, поскольку создаваемый нами
          компонент редактора -- всегда <tt class="CLASSNAME">QLineEdit</tt>.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig4.4.png"></p>

            <div class="CAPTION">
              <p>Рисунок 4.4. Передача содержимого QLineEdit обратно в
              ячейку.</p>
            </div>
          </div><br>
          В теле функции вызывается, унаследованная от <tt class="CLASSNAME">QTable</tt>, функция <tt class="METHODNAME">endEdit()</tt>, поскольку мы должны известить
          <tt class="CLASSNAME">QTable</tt> об окончании
          редактирования. В качестве третьего аргумента ей передается
          <tt class="PARAMETER"><em>false</em></tt>, для предотвращения
          модификации элемента таблицы, поскольку мы сами выполняем все
          необходимые действия по созданию и модификации элементов.
          Если "новая" формула отличается от
          "старой", то вызывается <tt class="METHODNAME">setFormula()</tt>, для записи формулы в объект
          класса <tt class="CLASSNAME">Cell</tt>. Вслед за этим
          вызывается функция <tt class="METHODNAME">somethingChanged()</tt>.
          <pre class="SCREEN">void Spreadsheet::somethingChanged() 
{ 
  if (autoRecalc) 
    recalculate(); 
  emit modified(); 
}
      
</pre>Она выполняет пересчет всего содержимого таблицы, если установлен
флаг <tt class="PARAMETER"><em>Auto-recalculate</em></tt>, а затем
выдает сигнал <tt class="METHODNAME">modified()</tt>.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="LOADINGANDSAVING"></a>4.3.
          Загрузка и сохранение.</h1>

          <p>Теперь перейдем к реализации загрузки и сохранения файлов
          (в двоичном формате), создаваемых нашей программой. Делать мы
          это будем с помощью <tt class="CLASSNAME">QFile</tt> и
          <tt class="CLASSNAME">QDataStream</tt>, которые предоставляют
          платформо-независимый интерфейс для операций ввода/вывода
          двоичных данных.</p>

          <p>Начнем с функции записи файла на диск: <a name="P77"></a></p>
          <pre class="SCREEN">bool Spreadsheet::writeFile(const QString &amp;fileName) 
{ 
  QFile file(fileName); 
  if (!file.open(IO_WriteOnly)) { 
    QMessageBox::warning(this, tr("Spreadsheet"), 
                         tr("Cannot write file %1:\n%2.") 
                         .arg(file.name()) 
                         .arg(file.errorString())); 
    return false;
  } 
  
  QDataStream out(&amp;file); 
  out.setVersion(5); 
  
  out &lt;&lt; (Q_UINT32)MagicNumber; 
  
  QApplication::setOverrideCursor(waitCursor); 
  for (int row = 0; row &lt; NumRows; ++row) { 
    for (int col = 0; col &lt; NumCols; ++col) { 
      QString str = formula(row, col); 
      if (!str.isEmpty()) 
        out &lt;&lt; (Q_UINT16)row &lt;&lt; (Q_UINT16)col &lt;&lt; str; 
    } 
  } 
  QApplication::restoreOverrideCursor(); 
  return true; 
}
      
</pre>Функция <tt class="METHODNAME">writeFile()</tt> вызывается из
<tt class="METHODNAME">MainWindow::saveFile()</tt>, для записи файла на
диск. В случае успеха возвращает <tt class="PARAMETER"><em>true</em></tt>, иначе -- <tt class="PARAMETER">
          <em>false</em></tt>.<br>
          <br>

          <p>Функция начинается с создания экземпляра <tt class="CLASSNAME">QFile</tt>, с заданным именем файла, после чего
          файл открывается на запись. Затем создается объект <tt class="CLASSNAME">QDataStream</tt>, который, используя <tt class="CLASSNAME">QFile</tt>, записывает данные на диск.
          Непосредственно перед записью данных, мы меняем внешний вид
          курсора мыши, показывая занятость приложения. А после записи
          -- восстанавливаем его. В конце функции файл автоматически
          закрывается деструктором <tt class="CLASSNAME">QFile</tt>.</p>

          <p><tt class="CLASSNAME">QDataStream</tt> поддерживает
          основные типы языка C++, а так же ряд типов, определяемых
          библиотекой Qt. Синтаксис соответствует стандарту классов
          <tt class="FILENAME">&lt;iostream&gt;</tt>. Например,</p>
          <pre class="SCREEN">        out &lt;&lt; x &lt;&lt; y &lt;&lt; z;     
      
</pre>записывает переменные <tt class="VARNAME">x, y</tt> и
          <tt class="VARNAME">z</tt> в поток, а
          <pre class="SCREEN">        in &gt;&gt; x &gt;&gt; y &gt;&gt; z;
      
</pre>читает их из потока.<br>
          <br>

          <p>Поскольку базовые типы языка C++ <tt class="PARAMETER"><em>char, short, int, long</em></tt> и <tt class="PARAMETER"><em>long long</em></tt> могут иметь различный
          размер на разных платформах, в целях безопасности их следует
          приводить к одному из следующих: <tt class="PARAMETER"><em>Q_INT8, Q_UINT8, Q_INT16, Q_UINT16, Q_INT32,
          Q_UINT32, Q_INT64, Q_UINT64</em></tt>, которые гарантированно
          имеют декларируемый, в битах, размер.</p>

          <p><tt class="CLASSNAME">QDataStream</tt> -- довольно
          универсальный класс, он может совместно работать не только с
          <tt class="CLASSNAME">QFile</tt>, но так же и с <tt class="CLASSNAME">QBuffer</tt>, и с <tt class="CLASSNAME">QSocket</tt>, и с <tt class="CLASSNAME">QSocketDevice</tt>. Точно так же <tt class="CLASSNAME">QFile</tt> может использоваться совместно с
          <tt class="CLASSNAME">QTextStream</tt> и как самостоятельное
          средство работы с файлами. В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER10">Главе
          10</a> мы глубже рассмотрим эти классы.</p>

          <p>Формат файлов приложения Spreadsheet очень прост.
          Начинается файл с 32-х битного числа, идентифицирующего
          формат (<tt class="VARNAME">MagicNumber</tt> определена как
          0x7F51C882 в <tt class="FILENAME">spreadsheet.h</tt>). Далее
          следует серия блоков, каждый из которых соответствует одной
          ячейке (номера строки и колонки, и формула). Для экономии мы
          не записываем в файл пустые ячейки.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig4.5.png"></p>

            <div class="CAPTION">
              <p>Рисунок 4.5. Формат файла Spreadsheet.</p>
            </div>
          </div><br>
          Двоичное представление типов данных определяется классом
          <tt class="CLASSNAME">QDataStream</tt>. Например, тип
          <tt class="CLASSNAME">Q_UINT16</tt> представлен двумя
          байтами, следующими в порядке <span class="emphasis"><em class="EMPHASIS">big-endian</em></span> (т.е.
          первым идет старший байт, потом -- младший). Тип <tt class="CLASSNAME">QString</tt> записывается как последовательность
          символов в кодировке Unicode.<br>
          <br>

          <p>Двоичное представление типов, определяемых библиотекой Qt,
          стало осуществляться еще в Qt 1.0 и, вероятно, будет
          развиваться и дальше, чтобы в процессе развития библиотеки
          имелась возможность представлять в двоичном виде вновь
          появляющиеся типы. По-умолчанию, <tt class="CLASSNAME">QDataStream</tt> использует самую современную
          версию двоичного формата (версия 5 в Qt 3.2), но способен
          работать и с более ранними версиями. Воизбежание проблем с
          совместимостью, на тот случай, если наша программа будет
          скомпилирована с более свежим выпуском Qt, мы укажем
          <tt class="CLASSNAME">QDataStream</tt> на то, что необходимо
          использовать 5-ю версию, независимо от того, с какой версией
          Qt была скомпилирована программа.</p>
          <pre class="SCREEN">      
bool Spreadsheet::readFile(const QString &amp;fileName) 
{ 
  QFile file(fileName); 
  if (!file.open(IO_ReadOnly)) { 
    QMessageBox::warning(this, tr("Spreadsheet"), 
                         tr("Cannot read file %1:\n%2.") 
                         .arg(file.name()) 
                         .arg(file.errorString())); 
    return false; 
  } 
  
  QDataStream in(&amp;file); 
  in.setVersion(5); 
  
  Q_UINT32 magic; 
  in &gt;&gt; magic; 
  if (magic != MagicNumber) { 
    QMessageBox::warning(this, tr("Spreadsheet"), 
                         tr("The file is not a " "Spreadsheet file.")); 
    return false; 
  } 
  
  clear(); 
  
  Q_UINT16 row; 
  Q_UINT16 col; 
  QString str; 
  
  QApplication::setOverrideCursor(waitCursor); 
  while (!in.atEnd()) {
    in &gt;&gt; row &gt;&gt; col &gt;&gt; str; 
    setFormula(row, col, str); 
  } 
  QApplication::restoreOverrideCursor(); 
  return true; 
}
      
</pre>Функция <tt class="METHODNAME">readFile()</tt> очень похожа на
<tt class="METHODNAME">writeFile()</tt>. Для работы с файлом опять
используется <tt class="CLASSNAME">QFile</tt>, только на этот раз при
открытии файла устанавливается флаг режима доступа <tt class="PARAMETER"><em>IO_WriteOnly</em></tt>. Далее идет установка версии
формата. При чтении данных в двоичном представлении всегда должна
указываться та же версия, которая использовалась при записи.<br>

          <br>

          <p>Если сигнатура файла (magic number) представлена
          корректным значением, то вызывается <tt class="METHODNAME">clear()</tt>, для очистки таблицы, поскольку в
          файле могут быть представлены не все ячейки.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="IMPLEMENTINGTHEEDITMENU"></a>4.4. Реализация меню Edit.</h1>

          <p>Приступим к созданию слотов, соответствующих пунктам меню
          <strong class="COMMAND">Edit</strong>.</p>
          <pre class="SCREEN">      
void Spreadsheet::cut() 
{ 
  copy(); 
  del(); 
}      
      
</pre>Слот <tt class="METHODNAME">cut()</tt> соответствует пункту меню
<strong class="COMMAND">Edit|Cut</strong>. Реализация слота чрезвычайно
проста, поскольку логика работы соответствует последовательности команд
<strong class="COMMAND">Copy</strong> и <strong class="COMMAND">
          Delete</strong>.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig4.6.png"></p>

            <div class="CAPTION">
              <p>Рисунок 4.6. Меню Edit приложения Spreadsheet.</p>
            </div>
          </div><br>
          <a name="P80"></a>
          <pre class="SCREEN">      
void Spreadsheet::copy() 
{ 
  QTableSelection sel = selection(); 
  QString str; 
  
  for (int i = 0; i &lt; sel.numRows(); ++i) { 
    if (i &gt; 0) 
      str += "\n"; 
    for (int j = 0; j &lt; sel.numCols(); ++j) { 
      if (j &gt; 0) 
        str += "\t"; 
      str += formula(sel.topRow() + i, sel.leftCol() + j); 
    } 
  }
  
  QApplication::clipboard()-&gt;setText(str); 
}
      
</pre>Слот <tt class="METHODNAME">copy()</tt> соответствует пункту меню
<strong class="COMMAND">Edit|Copy</strong>. Здесь осуществляется обход
ячеек в выделенной области. Формула каждой из выбранных ячеек
добавляется к <tt class="CLASSNAME">QString</tt>, где ячейки,
находящиеся в одной строке, разделяются символом табуляции, а строки
отделяются символом перевода строки.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig4.7.png"></p>

            <div class="CAPTION">
              <p>Рисунок 4.7. Копирование выделенной области в буфер
              обмена.</p>
            </div>
          </div><br>
          Доступ к системному буферу обмена в Qt осуществляется через
          статическую функцию <tt class="METHODNAME">QApplication::clipboard()</tt>. Вызовом
          <tt class="METHODNAME">QClipboard::setText()</tt> мы помещаем
          содержимое <tt class="CLASSNAME">QString</tt> в буфер обмена.
          Выбранный нами формат строки, где в качестве разделителя
          ячеек используется символ табуляции, а в качестве разделителя
          строк -- символ перевода строки, могут воспринимать и другие
          приложения, в том числе <strong class="COMMAND">Microsoft
          Excel</strong>.
          <pre class="SCREEN">QTableSelection Spreadsheet::selection() 
{ 
  if (QTable::selection(0).isEmpty()) 
    return QTableSelection(currentRow(), currentColumn(), 
                           currentRow(), currentColumn()); 
  
  return QTable::selection(0); 
}
      
</pre>Функция <tt class="METHODNAME">selection()</tt> возвращает
границы выделенной области. Она обращается к <tt class="METHODNAME">
          QTable::selection()</tt>, которая возвращает выделенную
          область по ее номеру. Поскольку мы ранее установили режим
          выделения <tt class="PARAMETER"><em>Single</em></tt>, то в
          нашем приложении может существовать только одна область
          выделения -- это область с номером 0. Но возможен вариант,
          когда в таблице нет выделенной области. <tt class="CLASSNAME">QTable</tt> не рассматривает текущую ячейку как
          выделенную область. Это вполне разумно, но в данном случае --
          немного неудобно. Поэтому, в случае, когда нет выделенной
          области, функция <tt class="METHODNAME">selection()</tt>
          вернет текущую ячейку. <a name="P81"></a>
          <pre class="SCREEN">void Spreadsheet::paste() 
{ 
  QTableSelection sel = selection(); 
  QString str = QApplication::clipboard()-&gt;text(); 
  QStringList rows = QStringList::split("\n", str, true); 
  int numRows = rows.size(); 
  int numCols = rows.first().contains("\t") + 1; 
  
  if (sel.numRows() * sel.numCols() != 1 
      &amp;&amp; (sel.numRows() != numRows 
          || sel.numCols() != numCols)) { 
      QMessageBox::information(this, tr("Spreadsheet"), 
                               tr("The information cannot be pasted because the " 
                               "copy and paste areas aren't the same size."));     
      return; 
  } 
  
  for (int i = 0; i &lt; numRows; ++i) { 
    QStringList cols = QStringList::split("\t", rows[i], true); 
    for (int j = 0; j &lt; numCols; ++j) { 
      int row = sel.topRow() + i; 
      int col = sel.leftCol() + j; 
      if (row &lt; NumRows &amp;&amp; col &lt; NumCols) 
        setFormula(row, col, cols[j]); 
    } 
  } 
  somethingChanged(); 
}
      
</pre>Слот <tt class="METHODNAME">paste()</tt> соответствует пункту
меню <strong class="COMMAND">Edit|Paste</strong>. Сначала принимается
текст из буфера обмена. Затем он переносится в <tt class="CLASSNAME">
          QStringList</tt>, с разбивкой по строкам, вызовом статической
          функции <tt class="METHODNAME">QStringList::split()</tt>.<br>
          <br>

          <p>Далее определяется размерность области копирования.
          Количество строк в таблице соответствует количеству строк в
          <tt class="CLASSNAME">QStringList</tt>, а количество столбцов
          -- на один больше, чем количество символов табуляции в первой
          строке.</p>

          <p>Если выбрана только одна ячейка, то она используется как
          верхний левый угол области вставки, если имеется выделенная
          область, то вставка осуществляется в нее.</p>

          <p>В процессе вставки, каждая строка разбивается на ячейки,
          вызовом <tt class="METHODNAME">QStringList::split()</tt>, но
          на этот раз в качестве разделителя используется символ
          табуляции. Рисунок 4.8 демонстрирует процесс вставки данных в
          таблицу из буфера обмена.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig4.8.png"></p>

            <div class="CAPTION">
              <p>Рисунок 4.8. Вставка текста из буфера обмена в
              таблицу.</p>
            </div>
          </div><br>
          <pre class="SCREEN">void Spreadsheet::del() 
{ 
  QTableSelection sel = selection(); 
  for (int i = 0; i &lt; sel.numRows(); ++i) { 
    for (int j = 0; j &lt; sel.numCols(); ++j) 
      delete cell(sel.topRow() + i, sel.leftCol() + j); 
    } 
    clearSelection(); 
}
      
</pre>Слот <tt class="METHODNAME">del()</tt> соответствует пункту меню
<strong class="COMMAND">Edit|Delete</strong>. Для того, чтобы очистить
ячейку, достаточно просто удалить объект <tt class="CLASSNAME">
          Cell</tt>. Когда <tt class="CLASSNAME">QTable</tt>
          обнаруживает удаление какого либо из <tt class="CLASSNAME">QTableItem</tt>, то она автоматически
          перерисовывает себя на экране. Если после удаления ячейки
          вызвать <tt class="METHODNAME">cell()</tt>, то она вернет
          пустой указатель.
          <pre class="SCREEN">void Spreadsheet::selectRow() 
{ 
  clearSelection(); 
  QTable::selectRow(currentRow()); 
} 

void Spreadsheet::selectColumn() 
{ 
  clearSelection(); 
  QTable::selectColumn(currentColumn()); 
} 

void Spreadsheet::selectAll() 
{ 
  clearSelection(); 
  selectCells(0, 0, NumRows - 1, NumCols - 1); 
}      
      
</pre>Слоты <tt class="METHODNAME">selectRow(), selectColumn(),
selectAll()</tt> соответствуют пунктам меню <strong class="COMMAND">
          Edit|Select|Row, Edit|Select|Column,
          Edit|Select|All</strong>. функциональность этих слотов
          основана на функциях <tt class="CLASSNAME">QTable</tt>:
          <tt class="METHODNAME">selectRow(), selectColumn(),
          selectCells()</tt>.
          <pre class="SCREEN">void Spreadsheet::findNext(const QString &amp;str, bool caseSensitive) 
{ 
  int row = currentRow(); 
  int col = currentColumn() + 1; 
  
  while (row &lt; NumRows) { 
    while (col &lt; NumCols) { 
      if (text(row, col).contains(str, caseSensitive)) { 
        clearSelection(); 
        setCurrentCell(row, col); 
        setActiveWindow(); 
        return; 
      } 
      ++col; 
    } 
    col = 0; 
    ++row; 
  } 
  qApp-&gt;beep(); 
}
      
</pre>Слот <tt class="METHODNAME">findNext()</tt> начинает поиск с
ячейки, стоящей справа от текущей и двигается вправо до конца строки.
Затем переходит на следующую строку, продолжая поиск с первой ячейки
следующей строки и так далее до тех пор, пока не будет найден искомый
текст или пока не будет достигнут конец таблицы. Например, если текущая
ячейка C27, то поиск начинается с ячейки D27 и далее проверяются ячейки
E27, F27, ..., Z27, затем A28, B28, C28, ..., Z28 и так далее, до
ячейки Z999. Как только искомый текст будет обнаружен -- сбрасывается
выделение, курсор перемещается в ячейку, содержимое которой совпало с
искомым текстом, и активизируется окно с таблицей. Если поиск не
увенчался успехом, то выдается звуковой сигнал, извещающий о том, что
искомый текст не найден.
          <pre class="SCREEN">void Spreadsheet::findPrev(const QString &amp;str, bool caseSensitive) 
{ 
  int row = currentRow(); 
  int col = currentColumn() - 1; 
  
  while (row &gt;= 0) { 
    while (col &gt;= 0) { 
      if (text(row, col).contains(str, caseSensitive)) { 
        clearSelection(); 
        setCurrentCell(row, col); 
        setActiveWindow(); 
        return; 
      } 
      --col; 
    } 
    col = NumCols - 1; 
    --row; 
  } 
  qApp-&gt;beep(); 
}      
      
</pre>Слот <tt class="METHODNAME">findPrev()</tt> очень похож на
<tt class="METHODNAME">findNext()</tt>, только поиск ведется в обратном
направлении и заканчивается по достижении ячейки A1.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="IMPLEMENTINGTHEOTHERMENUS"></a>4.5. Реализация других
          меню.</h1>

          <p>Теперь перейдем к рассмотрению реализации слотов меню
          <strong class="COMMAND">Tools</strong> и <strong class="COMMAND">Options</strong>.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig4.9.png"></p>

            <div class="CAPTION">
              <p>Рисунок 4.9. Меню <strong class="COMMAND">Tools</strong> и <strong class="COMMAND">Options</strong>.</p>
            </div>
          </div><br>
          <pre class="SCREEN">void Spreadsheet::recalculate() 
{ 
  int row; 
  
  for (row = 0; row &lt; NumRows; ++row) { 
    for (int col = 0; col &lt; NumCols; ++col) { 
      if (cell(row, col)) 
        cell(row, col)-&gt;setDirty(); 
      } 
    } 
    for (row = 0; row &lt; NumRows; ++row) {      
      for (int col = 0; col &lt; NumCols; ++col) { 
        if (cell(row, col)) 
          updateCell(row, col); 
      } 
    } 
}   
      
</pre>Слот <tt class="METHODNAME">recalculate()</tt> соответствует
пункту меню <strong class="COMMAND">Tools|Recalculate</strong>. Он,
кроме того, в случае необходимости, вызывается программой
автоматически.<br>
          <br>

          <p>В первой группе циклов все ячейки помечаются, вызовом
          <tt class="METHODNAME">setDirty()</tt>, как требующие
          пересчета. В результате, когда в следующий раз <tt class="CLASSNAME">QTable</tt> вызовет метод <tt class="METHODNAME">text()</tt> ячейки <tt class="CLASSNAME">Cell</tt>, то ее содержимое будет
          пересчитано.</p>

          <p>Вторая группа циклов выполняет <tt class="METHODNAME">updateCell()</tt> каждой ячейки, чтобы
          перерисовать ее. В результате, <tt class="CLASSNAME">QTable</tt> вызовет метод <tt class="METHODNAME">text()</tt> ячейки <tt class="CLASSNAME">Cell</tt>, чтобы получить ее значение, а
          поскольку все ячейки были помечены вызовом <tt class="METHODNAME">setDirty()</tt>, то будет выполнен пересчет.</p>
          <pre class="SCREEN">void Spreadsheet::setAutoRecalculate(bool on) 
{ 
  autoRecalc = on; 
  if (autoRecalc) 
    recalculate(); 
}
      
</pre>Слот <tt class="METHODNAME">setAutoRecalculate()</tt>
соответствует пункту меню <strong class="COMMAND">Options|Auto-recalculate</strong>. Если этот флаг включен, то
как только в таблице появляются какие либо изменения, выполняется
автоматический пересчет всех ячеек таблицы. В этом случае,
          <tt class="METHODNAME">recalculate()</tt> вызывается из
          <tt class="METHODNAME">somethingChanged()</tt>.
          <pre class="SCREEN">void Spreadsheet::sort(const SpreadsheetCompare &amp;compare) 
{ 
  vector&lt;QStringList&gt; rows; 
  QTableSelection sel = selection(); 
  int i; 
  
  for (i = 0; i &lt; sel.numRows(); ++i) { 
    QStringList row; 
    for (int j = 0; j &lt; sel.numCols(); ++j) 
      row.push_back(formula(sel.topRow() + i, 
                    sel.leftCol() + j)); 
    rows.push_back(row); 
  } 
  
  stable_sort(rows.begin(), rows.end(), compare); 
  
  for (i = 0; i &lt; sel.numRows(); ++i) { 
    for (int j = 0; j &lt; sel.numCols(); ++j) 
      setFormula(sel.topRow() + i, sel.leftCol() + j, 
                 rows[i][j]);      
  } 
  clearSelection(); 
  somethingChanged(); 
}
      
</pre>Сортировка выполняется на выделенной области и переупорядочивает
строки в соответствии с заданными ключами и порядком сортировки,
хранящимися в объекте <tt class="VARNAME">compare</tt>. Функция
сортировки представляет каждую строку таблицы в виде
          <tt class="CLASSNAME">QStringList</tt>, а выделенную область
          -- как массив строк. Класс <tt class="CLASSNAME">vector&lt;?&gt;</tt> -- это стандартный класс
          C++, мы подробно опишем его в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER11">Главе
          11</a>. Для простоты будем выполнять сортировку по формулам,
          а не по значениям.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig4.10.png"></p>

            <div class="CAPTION">
              <p>Рисунок 4.10. Сохранение выделенной области в виде
              массива строк.</p>
            </div>
          </div><br>
          Собственно сортировка выполняется стандартной, для C++,
          функцией <tt class="METHODNAME">stable_sort()</tt>. Она
          принимает начальный итератор, конечный итератор и функцию
          сравнения. Функция сравнения -- это такая функция, которая
          принимает два аргумента (два <tt class="CLASSNAME">QStringList</tt>) и возвращает <tt class="PARAMETER"><em>true</em></tt>, если первый аргумент
          "меньше чем" второй и <tt class="PARAMETER"><em>false</em></tt> -- в противном случае. Объект
          <tt class="VARNAME">compare</tt>, который мы передаем в
          <tt class="METHODNAME">stable_sort()</tt>, на самом деле не
          является функцией сравнения, но он может быть использован как
          таковая, а как -- мы вскоре увидим.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig4.11.png"></p>

            <div class="CAPTION">
              <p>Рисунок 4.11. Перемещение отсортированных данных
              обратно в таблицу.</p>
            </div>
          </div><br>
          После того, как <tt class="METHODNAME">stable_sort()</tt>
          отсортирует массив строк, мы перемещаем данные обратно в
          таблицу, сбрасываем выделение и вызываем <tt class="METHODNAME">somethingChanged()</tt>.<br>
          <br>

          <p>В <tt class="FILENAME">spreadsheet.h</tt>, класс
          <tt class="CLASSNAME">SpreadsheetCompare</tt> определен
          как:</p>
          <pre class="SCREEN">class SpreadsheetCompare 
{ 
public: 
  bool operator()(const QStringList &amp;row1, 
                  const QStringList &amp;row2) const; 
                  
  enum { NumKeys = 3 }; 
  int keys[NumKeys];      
  bool ascending[NumKeys]; 
};
      
</pre>Это особый класс, поскольку он реализует оператор
          <tt class="CLASSNAME">()</tt>, что позволяет использовать его
          так, как будто это обычная функция. Такие классы называют
          <span class="emphasis"><em class="EMPHASIS">функторами</em></span> (<span class="emphasis"><em class="EMPHASIS">functor</em></span>). Чтобы
          до конца понять принцип работы функторов, рассмотрим простой
          пример:
          <pre class="SCREEN">class Square 
{ 
public: 
  int operator()(int x) const { return x * x; } 
};      
      
</pre>Класс <tt class="CLASSNAME">Square</tt> реализует единственную
функцию -- <tt class="METHODNAME">operator()(int)</tt>, которая
возвращает квадрат входного аргумента. Такое именование функции, а
скажем не <tt class="METHODNAME">compute(int)</tt>, дает нам
возможность использовать экземпляр класса <tt class="CLASSNAME">
          Square</tt> как обычную функцию:
          <pre class="SCREEN">  Square square; 
  int y = square(5);      
      
</pre>Теперь вернемся к классу <tt class="CLASSNAME">SpreadsheetCompare</tt>:
          <pre class="SCREEN">  QStringList row1, row2; 
  SpreadsheetCompare compare; 
  ...
  if (compare(row1, row2)) { 
    // row1 меньше чем row2 
  }      
      
</pre>Отсюда видно, что объект <tt class="VARNAME">compare</tt> может
использоваться как обычная функция <tt class="METHODNAME">compare()</tt>. Дополнительно, он имеет доступ к
параметрам сортировки, которые хранятся в виде переменных-членов.<br>

          <br>

          <p>Альтернативный подход вынудил бы нас хранить параметры
          сортировки в глобальных переменных и использовать обычную
          функцию сравнения. Это очень неэлегантное решение, которое
          может породить трудноуловимые ошибки. Функторы -- это более
          мощная идиома взаимодействия с шаблонными функциями, такими
          как <tt class="METHODNAME">stable_sort()</tt>. Ниже
          приводится реализация функции, которая сравнивает две строки
          таблицы:</p>
          <pre class="SCREEN">bool SpreadsheetCompare::operator()(const QStringList &amp;row1, 
                                    const QStringList &amp;row2) const 
{ 
  for (int i = 0; i &lt; NumKeys; ++i) { 
    int column = keys[i]; 
    if (column != -1) { 
      if (row1[column] != row2[column]) { 
        if (ascending[i]) 
          return row1[column] &lt; row2[column]; 
        else 
          return row1[column] &gt; row2[column]; 
      }      
    } 
  } 
    return false; 
}       
      
</pre>Она возвращает <tt class="PARAMETER"><em>true</em></tt>, если
первая строка "меньше" чем вторая, и <tt class="PARAMETER">
          <em>false</em></tt> -- в противном случае. Стандартная
          функция <tt class="METHODNAME">stable_sort()</tt> использует
          результат сравнения для выполнения сортировки.<br>
          <br>

          <p>Массивы <tt class="VARNAME">keys</tt> и <tt class="VARNAME">ascending</tt>, заполняются внутри функции
          <tt class="METHODNAME">MainWindow::sort()</tt> (описаной в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER2">Главе 2</a>). Каждый ключ сортировки --
          это индекс столбца или -1 (в случае "None").</p>

          <p>Сравнению подвергаются части строк, соответствующие
          ячейкам, заданным ключами сортировки, с учетом порядка
          сортировки. В зависимости от того были найдены отличия или
          нет -- возвращается значение <tt class="PARAMETER"><em>true</em></tt> или <tt class="PARAMETER"><em>false</em></tt>. Если строки равны, то
          возвращается <tt class="PARAMETER"><em>false</em></tt>.</p>

          <p>На этом мы завершаем рассмотрение класса <tt class="CLASSNAME">Spreadsheet</tt>. В следующем разделе мы обсудим
          класс <tt class="CLASSNAME">Cell</tt>. Он используется для
          хранения формулы и реализует свой метод <tt class="METHODNAME">text()</tt>, который используется для получения
          значения ячейки.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SUBCLASSINGQTABLEITEM"></a>4.6.
          Создание дочернего класса от QTableItem.</h1>

          <p>Класс <tt class="CLASSNAME">Cell</tt> порожден от класса
          <tt class="CLASSNAME">QTableItem</tt>. Он предназначен для
          совместной работы с <tt class="CLASSNAME">Spreadsheet</tt>,
          но никак не зависит от этого класса и теоретически может
          работать с любым экземпляром <tt class="CLASSNAME">QTable</tt>.</p>

          <p>Заголовочный файл:</p>
          <pre class="SCREEN">#ifndef CELL_H 
#define CELL_H 

#include &lt;qtable.h&gt; 
#include &lt;qvariant.h&gt; 

class Cell : public QTableItem 
{ 
public: 
  Cell(QTable *table, const QString &amp;formula); 
  
  void setFormula(const QString &amp;formula); 
  QString formula() const; 
  void setDirty(); 
  QString text() const; 
  int alignment() const; 

private: 
  QVariant value() const;      
  QVariant evalExpression(const QString &amp;str, int &amp;pos) const; 
  QVariant evalTerm(const QString &amp;str, int &amp;pos) const; 
  QVariant evalFactor(const QString &amp;str, int &amp;pos) const; 
  
  QString formulaStr; 
  mutable QVariant cachedValue; 
  mutable bool cacheIsDirty; 
}; 
#endif  
      
</pre>Класс <tt class="CLASSNAME">Cell</tt> расширяет функциональные
возможности своего предка за счет добавления трех приватных переменных:

          <ul>
            <li>
              <p><tt class="VARNAME">formulaStr</tt> -- формула ячейки,
              <tt class="CLASSNAME">QString</tt>.</p>
            </li>

            <li>
              <p><tt class="VARNAME">cachedValue</tt> -- кэш ячейки,
              <tt class="CLASSNAME">QVariant</tt>.</p>
            </li>

            <li>
              <p><tt class="VARNAME">cacheIsDirty</tt> -- <tt class="PARAMETER"><em>true</em></tt>, если значение в кэше
              необходимо обновить.</p>
            </li>
          </ul>Переменные типа <tt class="CLASSNAME">QVariant</tt>
          могут хранить значения самых разнообразных типов языка C++ и
          Qt. Мы используем ее по той простой причине, что ячейки в
          таблице могут хранить как числа типа <tt class="CLASSNAME">double</tt>, так и строки <tt class="CLASSNAME">QString</tt>.<br>
          <br>

          <p>Переменные <tt class="VARNAME">cachedValue</tt> и
          <tt class="VARNAME">cacheIsDirty</tt> объявлены со
          спецификатором <tt class="PARAMETER"><em>mutable</em></tt>.
          Это позволяет модифицировать их из <tt class="PARAMETER"><em>const</em></tt>-функций. В противном случае
          нам пришлось бы пересчитывать значение ячейки всякий раз, при
          вызове функции <tt class="METHODNAME">text()</tt>, но это
          было бы неэффективной тратой времени.</p>

          <p>Примечательно, что в определении класса отсутствует макрос
          <tt class="PARAMETER"><em>Q_OBJECT</em></tt>. Дело в том, что
          <tt class="CLASSNAME">Cell</tt> -- это обычный класс, который
          не имеет ни сигналов, ни слотов. Фактически, <tt class="CLASSNAME">QTableItem</tt> не является наследником класса
          <tt class="CLASSNAME">QObject</tt>, поэтому <tt class="CLASSNAME">Cell</tt> не может иметь своих собственных
          сигналов и слотов. Вообще, классы элементов в Qt не являются
          потомками <tt class="CLASSNAME">QObject</tt>, чтобы свести
          накладные расходы к минимуму. Если вам потребуются сигналы и
          слоты в классах-элементах, то вы можете реализовать свой
          виджет, который будет содержать элемент или, в исключительных
          случаях, воспользоваться возможностью множественного
          наследования, указав в качестве одного из предков класс
          <tt class="CLASSNAME">QObject</tt>.</p>

          <p>Перейдем к файлу <tt class="FILENAME">cell.cpp</tt>:</p>
          <pre class="SCREEN">#include &lt;qlineedit.h&gt; 
#include &lt;qregexp.h&gt; 

#include "cell.h" 

Cell::Cell(QTable *table, const QString &amp;formula) 
    : QTableItem(table, OnTyping) 
{ 
  setFormula(formula); 
}
      
</pre>Конструктор принимает указатель на <tt class="CLASSNAME">
          QTable</tt> и формулу. Указатель на таблицу передается в
          унаследованный конструктор <tt class="METHODNAME">QTableItem</tt> и позднее может быть получен
          вызовом <tt class="METHODNAME">QTableItem::table()</tt>.
          Второй аргумент, передаваемый конструктору базового класса --
          <tt class="VARNAME">OnTyping</tt>, указывает, что
          компонент-редактор должен появляться сразу же, как только
          пользователь начнет вводить символы в текущую ячейку.
          <pre class="SCREEN">void Cell::setFormula(const QString &amp;formula) 
{ 
  formulaStr = formula;     
  cacheIsDirty = true; 
} 
      
</pre>Функция <tt class="METHODNAME">setFormula()</tt> записывает
формулу в ячейку. Она так же устанавливает флаг <tt class="VARNAME">
          cacheIsDirty</tt>, который сигнализирует о том, что
          <tt class="VARNAME">cachedValue</tt> должно быть пересчитано.
          Она вызывается из конструктора <tt class="METHODNAME">Cell</tt> и из <tt class="METHODNAME">Spreadsheet::setFormula()</tt>.
          <pre class="SCREEN">QString Cell::formula() const 
{ 
  return formulaStr; 
}
      
</pre>Функция <tt class="METHODNAME">formula()</tt> вызывается из
<tt class="METHODNAME">Spreadsheet::formula()</tt>.
          <pre class="SCREEN">void Cell::setDirty() 
{ 
  cacheIsDirty = true; 
}
      
</pre>Функция <tt class="METHODNAME">setDirty()</tt> вызывается в
случае, когда необходимо заставить ячейку пересчитать свое значение.
Она просто устанавливает флаг <tt class="VARNAME">cacheIsDirty</tt>.
Пересчет выполняется только тогда, когда это действительно необходимо.
          <pre class="SCREEN">QString Cell::text() const 
{ 
  if (value().isValid()) 
    return value().toString(); 
  else 
    return "####"; 
}
      
</pre>Функция <tt class="METHODNAME">text()</tt> перекрывает метод
<tt class="CLASSNAME">QTableItem</tt>. Она возвращает текст, который
должен быть отображен в таблице. Значение ячейки вычисляется функцией
<tt class="METHODNAME">value()</tt>. Если оно не является допустимым
(скорее всего из-за ошибки в формуле), то возвращается строка
"####".<br>
          <br>

          <p>Функция <tt class="METHODNAME">value()</tt> возвращает
          значение типа <tt class="CLASSNAME">QVariant</tt>. Этот тип
          может хранить значения самых разных типов, таких как
          <tt class="CLASSNAME">double</tt> или <tt class="CLASSNAME">QString</tt> и предоставляет в распоряжение
          программиста ряд методов преобразования вариантного типа в
          другие типы. Например, вызов <tt class="METHODNAME">toString</tt>, для варианта типа <tt class="CLASSNAME">double</tt>, вернет его строковое
          представление.</p>
          <pre class="SCREEN">int Cell::alignment() const 
{ 
  if (value().type() == QVariant::String) 
    return AlignLeft | AlignVCenter; 
  else 
    return AlignRight | AlignVCenter; 
}
      
</pre>Функция <tt class="METHODNAME">alignment()</tt> перекрывает метод
<tt class="CLASSNAME">QTableItem</tt>. Она возвращает значение,
характеризующее выравнивание текста в ячейке. В нашем случае для строк
используется выравнивание по левому краю, для чисел -- по правому. Все
значения, независимо от своего типа, центрируются по вертикали.
          <pre class="SCREEN">const QVariant Invalid; 

QVariant Cell::value() const { 
  if (cacheIsDirty) { 
    cacheIsDirty = false; 
    
    if (formulaStr.startsWith("'")) { 
      cachedValue = formulaStr.mid(1); 
    } else if (formulaStr.startsWith("=")) { 
      cachedValue = Invalid; 
      QString expr = formulaStr.mid(1); 
      expr.replace(" ", ""); 
      int pos = 0; 
      cachedValue = evalExpression(expr, pos); 
      if (pos &lt; (int)expr.length()) 
        cachedValue = Invalid; 
    } else { 
      bool ok; 
      double d = formulaStr.toDouble(&amp;ok); 
      if (ok) 
        cachedValue = d; 
      else 
        cachedValue = formulaStr; 
    } 
  } 
  return cachedValue; 
}
      
</pre>Приватная функция <tt class="METHODNAME">value()</tt> возвращает
значение ячейки. Если установлен флаг <tt class="VARNAME">cacheIsDirty</tt>, то значение ячейки пересчитывается.<br>

          <br>

          <p>Если формула начинается с одиночной кавычки (например,
          "'12345"), то в качестве значения возвращается
          часть строки, начиная с позиции 1 и до конца. (Одиночная
          кавычка занимает позицию 0.)</p>

          <p>Если формула начинается с символа "=", то
          берется часть строки, начиная с позиции 1 и до конца, Из нее
          удаляются все пробелы. Затем производится вычисление по
          формуле, с помощью функции <tt class="METHODNAME">evalExpression()</tt>. Аргумент <tt class="PARAMETER"><em>pos</em></tt>, передаваемый по ссылке,
          указывает -- с какого символа в строке необходимо начинать
          разбор выражения. По окончании работы функции он содержит
          позицию символа, на котором завершился разбор. Если
          <tt class="PARAMETER"><em>pos</em></tt> не соответствует
          позиции последнего символа в строке, то это означает ошибку в
          выражении и в этом случае <tt class="VARNAME">cachedValue</tt> будет содержать значение
          <tt class="PARAMETER"><em>Invalid</em></tt>.</p>

          <p>Если формула начинается не с символа "=" и не с
          одиночной кавычки, то делается попытка преобразовать строку в
          число с плавающей точкой. Если преобразование завершилось
          успешно, то в <tt class="VARNAME">cachedValue</tt>
          записывается число типа <tt class="CLASSNAME">double</tt>, в
          противном случае -- строка с формулой. Например, формула
          "1.50" будет благополучно преобразована в число
          1.5, а формула "World Population" не может быть
          преобразована в число и в этом случае в <tt class="VARNAME">cachedValue</tt> будет записана сама строка
          "World Population".</p>

          <p>Функция <tt class="METHODNAME">value()</tt> -- это
          <tt class="PARAMETER"><em>const</em></tt>-функция. Но
          благодаря тому, что переменные-члены <tt class="VARNAME">cachedValue</tt> и <tt class="VARNAME">cacheIsValid</tt> объявлены как <tt class="PARAMETER"><em>mutable</em></tt>, компилятор позволит нам
          модифицировать их внутри функции. Вам может показаться, что
          достаточно убрать спецификатор <tt class="PARAMETER"><em>const</em></tt> функции <tt class="METHODNAME">value()</tt> и можно будет отказаться от
          спецификатора <tt class="PARAMETER"><em>mutable</em></tt>,
          для переменных <tt class="VARNAME">cachedValue</tt> и
          <tt class="VARNAME">cacheIsValid</tt>, но такой вариант все
          равно породит ошибку времени компиляции, поскольку <tt class="METHODNAME">value()</tt> вызывается из <tt class="PARAMETER"><em>const</em></tt>-функции <tt class="METHODNAME">text()</tt>. Вообще, в мире C++, кэширование и
          <tt class="PARAMETER"><em>mutable</em></tt> идут рядом, рука
          об руку.</p>

          <p>Мы практически закончили рассмотрение приложения
          Spreadsheet. Осталось только разобраться с синтаксическим
          анализом формул. Далее, до конца этого раздела, мы
          сконцентрируемся на <tt class="METHODNAME">evalExpression()</tt> и двух вспомогательных
          функциях <tt class="METHODNAME">evalTerm()</tt> и <tt class="METHODNAME">evalFactor()</tt>. Реализация функций достаточно
          сложна, но они совершенно необходимы для нашего приложения. С
          другой стороны, поскольку эти функции напрямую не связаны с
          разработкой графического интерфейса, вы смело можете
          пропустить оставшуюся часть раздела и сразу перейти к
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER5">Главе 5</a>.</p>

          <p>Функция <tt class="METHODNAME">evalExpression()</tt>
          возвращает результат вычисления выражения. Выражение -- это
          один или более термов (term), отделяемых друг от друга
          операторами '+' или '-', например,
          "2*C5+D6" -- это выражение, состоящее из термов
          "2*C5" и "D6". Термы, в свою очередь,
          могут состоять из одного или более факторов (factor),
          отделяемых друг от друга операторами '*' или
          '/', например, терм "2*C5" состоит из двух
          факторов -- "2" и "C5". И наконец, фактор
          может быть числом ("2"), адресом ячейки
          ("C5") или выражением в скобках с необязательным
          предшествующим знаком '-' (признак отрицательного
          числа). Разложив выражение на термы, а термы на факторы, мы
          получим правильную обработку приоритетов операций.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig4.12.png"></p>

            <div class="CAPTION">
              <p>Рисунок 4.12. Синтаксическая диаграмма выражений в
              электронной таблице.</p>
            </div>
          </div><br>
          Синтаксическая диаграмма выражений приведена на рисунке 4.12.
          Каждому из элементов грамматики (<span class="emphasis"><em class="EMPHASIS">Expression</em></span>,
          <span class="emphasis"><em class="EMPHASIS">Term</em></span>
          и <span class="emphasis"><em class="EMPHASIS">Factor</em></span>) сопоставлена своя функция-член
          класса <tt class="CLASSNAME">Cell</tt>, которая выполняет
          синтаксический анализ этих элементов и чья структура очень
          близко следует грамматике. Синтаксические анализаторы
          подобного типа называются анализаторами рекурсивного
          спуска.<br>
          <br>

          <p>Начнем с функции <tt class="METHODNAME">evalExpression()</tt>, которая отвечает за
          разбор элемента <span class="emphasis"><em class="EMPHASIS">Expression</em></span>:</p>
          <pre class="SCREEN">QVariant Cell::evalExpression(const QString &amp;str, int &amp;pos) const 
{ 
  QVariant result = evalTerm(str, pos); 
  while (pos &lt; (int)str.length()) { 
    QChar op = str[pos]; 
    if (op != '+' &amp;&amp; op != '-') 
      return result; 
    ++pos; 
    
    QVariant term = evalTerm(str, pos); 
    if (result.type() == QVariant::Double 
       &amp;&amp; term.type() == QVariant::Double) { 
      if (op == '+') 
        result = result.toDouble() + term.toDouble(); 
      else 
        result = result.toDouble() - term.toDouble(); 
    } else { 
      result = Invalid;      
    } 
  } 
  return result; 
}
      
</pre>В первой строке, вызовом <tt class="METHODNAME">evalTerm()</tt>,
предпринимается попытка получить значение первого терма. Если за ним
стоит оператор '+' или '-', то <tt class="METHODNAME">
          evalTerm()</tt> вызывается второй раз, в противном случае,
          выражение состоит из единственного терма и мы возвращаем его
          значение как результат выражения. После того, как будут
          получены значения обоих термов -- вычисляется результат
          операции. Если оба терма имеют тип <tt class="CLASSNAME">double</tt>, вычисляется результат этого же типа,
          в противном случае, возвращается результат <tt class="PARAMETER"><em>Invalid</em></tt>.<br>
          <br>

          <p>Так продолжается до тех пор, пока не будут исчерпаны все
          термы. В данной ситуации все работает корректно, благодаря
          тому, что операции сложения и вычитания лево-ассоциативны,
          т.е. выражению "1-2-3" соответствует
          "(1-2)-3", а не "1-(2-3)".</p>
          <pre class="SCREEN">QVariant Cell::evalTerm(const QString &amp;str, int &amp;pos) const 
{ 
  QVariant result = evalFactor(str, pos); 
  while (pos &lt; (int)str.length()) { 
    QChar op = str[pos]; 
    if (op != '*' &amp;&amp; op != '/') 
      return result; 
    ++pos; 
    
    QVariant factor = evalFactor(str, pos); 
    if (result.type() == QVariant::Double 
        &amp;&amp; factor.type() == QVariant::Double) { 
          if (op == '*') { 
            result = result.toDouble() * factor.toDouble(); 
          } else { 
            if (factor.toDouble() == 0.0) 
              result = Invalid; 
            else 
              result = result.toDouble() / factor.toDouble(); 
          } 
    } else { 
      result = Invalid; 
    } 
  } 
  return result; 
}
      
</pre><tt class="METHODNAME">evalTerm()</tt> очень похожа на
          <tt class="METHODNAME">evalExpression()</tt>, за исключением
          того, что она обслуживает операции умножения и деления.
          Единственный тонкий момент -- необходимо избежать выполнения
          деления на ноль. Вообще нецелесообразно проверять на
          равенство значения с плавающей точкой, поскольку могут
          возникнуть ошибки, связанные с погрешностью округления, хотя
          в данном случае, выполнять такую проверку вполне допустимо.
          <pre class="SCREEN">QVariant Cell::evalFactor(const QString &amp;фьзжstr, int &amp;фьзжpos) const 
{ 
  QVariant result; 
  bool negative = false;      

  if (str[pos] == '-') { 
    negative = true; 
    ++pos; 
  } 
  
  if (str[pos] == '(') { 
    ++pos; 
    result = evalExpression(str, pos); 
    if (str[pos] != ')') 
      result = Invalid; 
    ++pos; 
  } else { 
    QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}"); 
    QString token; 
    
    while (str[pos].isLetterOrNumber() || str[pos] == '.') { 
      token += str[pos]; 
      ++pos; 
    } 
    
    if (regExp.exactMatch(token)) { 
      int col = token[0].upper().unicode() - 'A'; 
      int row = token.mid(1).toInt() - 1; 
      
      Cell *c = (Cell *)table()-&gt;item(row, col); 
      if (c) 
        result = c-&gt;value(); 
      else 
        result = 0.0; 
    } else { 
      bool ok; 
      result = token.toDouble(&amp;ok); 
      if (!ok) 
        result = Invalid; 
    } 
  } 
  
  if (negative) { 
    if (result.type() == QVariant::Double) 
      result = -result.toDouble(); 
    else 
      result = Invalid; 
  } 
  return result; 
}  
      
</pre>Функция <tt class="METHODNAME">evalFactor()</tt> гораздо сложнее,
чем <tt class="METHODNAME">evalExpression()</tt> и <tt class="METHODNAME">evalTerm()</tt>. Начинается она с проверки -- не
инвертирован ли фактор (наличие унарного минуса). Затем проверяется --
не начинается ли он с открывающей скобки. Если да, то содержимое скобок
вычисляется как выражение, вызовом <tt class="METHODNAME">evalExpression()</tt>. Это то самое место, где возникает
рекурсия -- <tt class="METHODNAME">evalExpression()</tt> вызывает
<tt class="METHODNAME">evalTerm()</tt>, которая вызывает
          <tt class="METHODNAME">evalFactor()</tt>, которая опять
          вызывает <tt class="METHODNAME">evalExpression()</tt>.<br>
          <br>

          <p>Если фактор не является выражением в скобках, то
          извлекается лексема, которая может оказаться адресом ячейки
          или числом. Если лексема соответствует регулярному выражению
          <tt class="CLASSNAME">QRegExp</tt>, то она воспринимается как
          адрес ячейки и вызывается <tt class="METHODNAME">value()</tt>
          для данной ячейки. Ячейка может находиться в любом месте
          электронной таблицы, а ее значение может так же вычисляться
          на основе других ячеек. Подобные зависимости не являются
          проблемой для нас, просто это может потребовать некоторого
          дополнительного времени для рассчета значений тех ячеек, у
          которых установлен флаг <tt class="VARNAME">cacheIsDirty</tt>. Если лексема не является адресом
          ячейки, то она считается числом.</p>

          <p>Что произойдет, если значение ячейки A1 вычисляется по
          формуле "=A1"? Или если ячейка A1 вычисляется по
          формуле "=A2", а ячейка A2 -- по формуле
          "=A1"? Хотя мы и не предусмотрели проверки
          циклических зависимостей, тем не менее наш анализатор
          довольно изящно решает эту проблему, возвращая ошибочный
          <tt class="CLASSNAME">QVariant</tt>. Это происходит потому,
          что в функции <tt class="METHODNAME">value()</tt>
          сбрасывается флаг <tt class="VARNAME">cacheIsDirty</tt>, а в
          <tt class="VARNAME">cachedValue</tt> записывается <tt class="PARAMETER"><em>Invalid</em></tt> до того, как будет вызвана
          функция <tt class="METHODNAME">evalExpression()</tt>. Если
          <tt class="METHODNAME">evalExpression()</tt> рекурсивно
          вызывает <tt class="METHODNAME">value()</tt> своей
          собственной ячейки, то ей сразу же возвращается значение
          <tt class="PARAMETER"><em>Invalid</em></tt>, которое
          становится результатом всего выражения.</p>

          <p>На этом мы завершаем обсуждение синтаксического
          анализатора формул. Он может быть расширен за счет введения
          обработки предопределенных функций электронной таблицы, таких
          как "sum()" и "avg()", в синтаксическом
          элементе <span class="emphasis"><em class="EMPHASIS">фактор</em></span>. Довольно просто в него можно
          добавить операцию конкатенации ("+") строк.</p>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER5"></a>Глава 5. Создание собственных
        виджетов.</h1>

        <p>В этой главе мы расскажем -- как создаются визуальные
        компоненты (виджеты) в Qt. Визуальные компоненты могут
        создаваться путем наследования существующих виджетов Qt или
        напрямую -- от <tt class="CLASSNAME">QWidget</tt>. Мы
        продемонстрируем оба варианта, а так же рассмотрим -- как можно
        интегрировать свои компоненты в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>. И в
        завершение главы представим компонент, который использует прием
        двойной буферизации для устранения эффекта мерцания во время
        перерисовки.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="CUSTOMIZINGQTWIDGETS"></a>5.1.
          Переделка существующих виджетов Qt.</h1>

          <p>Иногда возникает необходимость в расширении функциональных
          возможностей стандартных виджетов. Самое простое решение --
          это создать класс потомок от соответствующего виджета Qt и
          наделить его необходимыми свойствами.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.1. Виджет HexSpinBox.</p>
            </div>
          </div><br>
          В этом разделе мы продемонстрируем виджет шестнадцатиричного
          счетчика. Стандартный виджет <tt class="CLASSNAME">QSpinBox</tt> поддерживает только десятичный
          формат представления чисел, но, за счет создания дочернего
          класса, его можно "заставить" принимать и
          обрабатывать шестнадцатиричный формат.
          <pre class="SCREEN">#ifndef HEXSPINBOX_H 
#define HEXSPINBOX_H 

#include &lt;qspinbox.h&gt; 

class HexSpinBox : public QSpinBox {      
public: 
  HexSpinBox(QWidget *parent, const char *name = 0); 
  
protected: 
  QString mapValueToText(int value); 
  int mapTextToValue(bool *ok); 
}; 
#endif
      
</pre>Большую часть своих функциональных возможнойстей, виджет
<tt class="CLASSNAME">HexSpinBox</tt> наследует от <tt class="CLASSNAME">QSpinBox</tt>. Он имеет типичный конструктор и перекрывает
две виртуальные функции своего предка. Поскольку класс
          <tt class="CLASSNAME">HexSpinBox</tt> не определяет своих
          собственных сигналов и слотов, то он не нуждается в
          макроопределении <tt class="PARAMETER"><em>Q_OBJECT</em></tt>.
          <pre class="SCREEN">#include &lt;qvalidator.h&gt; 

#include "hexspinbox.h" 

HexSpinBox::HexSpinBox(QWidget *parent, const char *name) 
    : QSpinBox(parent, name) 
{ 
  QRegExp regExp("[0-9A-Fa-f]+"); 
  setValidator(new QRegExpValidator(regExp, this)); 
  setRange(0, 255); 
}      
      
</pre>Пользователь может изменять значение счетчика либо щелкая по
кнопкам со стрелками, либо вводя числа в окошко редактора. В последнем
случае мы должны ограничить набор допустимых символов
шестнадцатиричными цифрами. Для этого используется <tt class="CLASSNAME">QRegExpValidator</tt>, который пропускает только символы из
диапазонов (0..9), (A..F) и (a..f). Дополнительно задается диапазон
изменения чисел -- от 0 по 255 (от 0x00 по 0xFF), который больше
подходит для шестнадцатиричных чисел, чем диапазон (0..99),
устанавливаемый <tt class="CLASSNAME">QSpinBox</tt> по-умолчанию .
          <pre class="SCREEN">QString HexSpinBox::mapValueToText(int value) 
{ 
  return QString::number(value, 16).upper(); 
}      
      
</pre>Функция <tt class="METHODNAME">mapValueToText()</tt> преобразует
число в строку. Она используется для обновления окошка редактора, когда
пользователь изменяет число нажатием на кнопки "вверх" и
"вниз". Собственно преобразование выполняется функцией
<tt class="METHODNAME">QString::number()</tt>, которой вторым
аргументом передается число 16 -- основание системы счисления. Она
возвращает шестнадцатиричное представление числа с символами в нижнем
регистре, а вызов <tt class="METHODNAME">QString::upper()</tt>
переводит их в верхний регистр.
          <pre class="SCREEN">int HexSpinBox::mapTextToValue(bool *ok) 
{ 
  return text().toInt(ok, 16); 
}      
      
</pre>Функция <tt class="METHODNAME">mapTextToValue()</tt> выполняет
обратное преобразование -- из строки в число. Она вызывается, когда
пользователь вводит число с клавиатуры и завершает его нажатием на
клавишу Enter. Собственно преобразование выполняется функцией
          <tt class="METHODNAME">QString::toInt()</tt>, которая
          принимает строку (возвращаемую вызовом <tt class="METHODNAME">QString::toInt()</tt>) и число 16 -- основание
          системы счисления.<br>
          <br>

          <p>Если преобразование было выполнено успешно, то <tt class="METHODNAME">QString::toInt()</tt> запишет в аргумент
          <tt class="PARAMETER"><em>*ok</em></tt> значение <tt class="PARAMETER"><em>true</em></tt> и <tt class="PARAMETER"><em>false</em></tt> -- в противном случае. Это
          полностью соответствует тому, чего ожидает <tt class="CLASSNAME">QSpinBox</tt>.</p>

          <p>Это собственно все, что мы хотели рассказать о <tt class="CLASSNAME">HexSpinBox</tt>. Расширение возможностей других
          виджетов Qt выполняется аналогичным образом: выбирается
          необходимый виджет, создается класс-потомок и перекрываются
          некоторые виртуальные функции, изменяющие поведение
          класса-предка. Это общепринятая в Qt техника
          программирования. Фактически мы с ней уже сталкивались в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER4">Главе 4</a>, когда создавали
          класс-потомок от <tt class="CLASSNAME">QTable</tt> и
          перекрывали методы <tt class="METHODNAME">createEditor()</tt>
          и <tt class="METHODNAME">endEdit()</tt>.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SUBCLASSINGQWIDGET"></a>5.2.
          Создание класса-потомка от QWidget.</h1>

          <p>В большинстве своем, нестандартные виджеты образуются за
          счет комбинирования существующих компонентов, как встроенных
          виджетов Qt, так и других нестандартных виджетов, таких как
          <tt class="CLASSNAME">HexSpinBox</tt>. Нестандартные
          визуальные компоненты, которые состоят из существующих
          виджетов, как правило могут разрабатываться в среде
          <span class="emphasis"><em class="EMPHASIS">Qt
          Designer</em></span>. Для этого:</p>

          <ul>
            <li>
              <p>Создается новая форма, по шаблону
              "Widget".</p>
            </li>

            <li>
              <p>На форму добавляются необходимые виджеты.</p>
            </li>

            <li>
              <p>Устанавливаются соединения между сигналами и слотами и
              добавляется необходимый код (либо в файл <tt class="FILENAME">.ui.h</tt>, либо в класс реализации).</p>
            </li>
          </ul>Есстественно, все это может быть сделано и вручную. Но
          какой бы подход вы ни выбрали, в конечном итоге новый класс
          является наследником <tt class="CLASSNAME">QWidget</tt>.<br>
          <br>

          <p>Если виджет не имеет собственных сигналов и слотов, и не
          перекрывает методов родителя, то возможна простая сборка
          виджета путем аггрегирования существующих виджетов, без
          создания класса-потомка. Такой подход использовался нами в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER1">Главе 1</a>, при создании приложения
          "Age", когда мы просто "собрали" его из
          трех компонентов: <tt class="CLASSNAME">QHBox</tt>,
          <tt class="CLASSNAME">QSpinBox</tt> и <tt class="CLASSNAME">QSlider</tt>. Но даже в этом случае можно было бы
          породить дочерний класс от <tt class="CLASSNAME">QHBox</tt> и
          в его конструкторе создать виджеты <tt class="CLASSNAME">QSpinBox</tt> и <tt class="CLASSNAME">QSlider</tt>.</p>

          <p>Если среди виджетов Qt нет ни одного, подходящего под
          имеющуюся задачу, и при этом нет таких виджетов, с помощью
          которых можно было бы собрать свой компонент, то у нас
          остается единственная возможность -- создать класс-потомок от
          <tt class="CLASSNAME">QWidget</tt> и реализовать в нем
          необходимые обработчики событий и функции отрисовки. Этот
          подход дает нам абсолютную свободу в определении внешнего
          вида и поведения нового компонента. Многие виджеты Qt,
          например: <tt class="CLASSNAME">QLabel</tt>, <tt class="CLASSNAME">QPushButton</tt> и <tt class="CLASSNAME">QTable</tt> реализованы именно таким
          способом.</p>

          <p>С целью демонстрации этого подхода, мы создадим свой
          виджет <tt class="CLASSNAME">IconEditor</tt>, который может
          использоваться в программе редактирования иконок.</p>

          <p>Как обычно, начнем с файла заголовка: <a name="P100"></a></p>
          <pre class="SCREEN">#ifndef ICONEDITOR_H 
#define ICONEDITOR_H 

#include &lt;qimage.h&gt; 
#include &lt;qwidget.h&gt; 

class IconEditor : public QWidget 
{ 
  Q_OBJECT 
  Q_PROPERTY(QColor penColor READ penColor WRITE setPenColor) 
  Q_PROPERTY(QImage iconImage READ iconImage WRITE setIconImage) 
  Q_PROPERTY(int zoomFactor READ zoomFactor WRITE setZoomFactor) 
  
public: 
  IconEditor(QWidget *parent = 0, const char *name = 0); 
  void setPenColor(const QColor &amp;newColor); 
  QColor penColor() const { return curColor; } 
  void setZoomFactor(int newZoom); 
  int zoomFactor() const { return zoom; } 
  void setIconImage(const QImage &amp;newImage); const 
  QImage &amp;iconImage() const { return image; } 
  QSize sizeHint() const;      
      
</pre>Класс <tt class="CLASSNAME">IconEditor</tt> использует макрос
<tt class="PARAMETER"><em>Q_PROPERTY</em></tt>, для объявления свойств
<tt class="PARAMETER"><em>penColor</em></tt>, <tt class="PARAMETER">
          <em>iconImage</em></tt> и <tt class="PARAMETER"><em>zoomFactor</em></tt>. Каждое из свойств имеет
          свой тип и функции "чтения" и "записи"
          ("read" и "write"). Например, свойство
          <tt class="PARAMETER"><em>penColor</em></tt> имеет тип
          <tt class="CLASSNAME">QColor</tt> и функции
          "чтения"/"записи" -- <tt class="METHODNAME">penColor()</tt> и <tt class="METHODNAME">setPenColor()</tt>, соответственно.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.2. Виджет IconEditor.</p>
            </div>
          </div><br>
          Когда мы будем работать с виджетом в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>, то
          эти свойства появятся в инспекторе свойств, сразу же после
          свойств, унаследованных от <tt class="CLASSNAME">QWidget</tt>. Свойства могут иметь любой тип,
          который поддерживает <tt class="CLASSNAME">QVariant</tt>.
          Макроопределение <tt class="PARAMETER"><em>Q_PROPERTY</em></tt> необходимо вставлять в
          классы, которые определяют свойства.
          <pre class="SCREEN">protected: 
  void mousePressEvent(QMouseEvent *event); 
  void mouseMoveEvent(QMouseEvent *event); 
  void paintEvent(QPaintEvent *event);      

private: 
  void drawImagePixel(QPainter *painter, int i, int j); 
  void setImagePixel(const QPoint &amp;pos, bool opaque); 
  
  QColor curColor; 
  QImage image; 
  int zoom; 
}; 
#endif 
      
</pre>Наш виджет перекрывает три защищенные функции своего предка и
добавляет несколько приватных функций и переменных. Эти три приватные
переменные хранят значения трех свойств, которые были определены чуть
выше.<br>
          <br>

          <p>Файл реализации начинается с директив подключения
          заголовочных файлов и конструктора класса <tt class="CLASSNAME">IconEditor</tt>:</p>
          <pre class="SCREEN">#include &lt;qpainter.h&gt; 

#include "iconeditor.h" 

IconEditor::IconEditor(QWidget *parent, const char *name) 
    : QWidget(parent, name, WStaticContents) 
{ 
  setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Minimum); 
  curColor = black; 
  zoom = 8; 
  image.create(16, 16, 32); 
  image.fill(qRgba(0, 0, 0, 0)); 
  image.setAlphaBuffer(true); 
}
      
</pre>В конструкторе имеется ряд моментов, такие как -- вызов
          <tt class="METHODNAME">setSizePolicy()</tt> и передача флага
          <tt class="PARAMETER"><em>WStaticContents</em></tt>
          унаследованному конструктору, к которым мы вскоре
          вернемся.<br>
          <br>

          <p>В переменную <tt class="PARAMETER"><em>zoom</em></tt>
          записывается число 8. Это означает, что каждый пиксель иконки
          будет отображаться в виде квадрата 8 X 8. Устанавливается
          черный цвет "чернил", символ <tt class="VARNAME">black</tt> -- это предопределенная константа в Qt.
          Сама иконка хранится в переменной <tt class="VARNAME">image</tt>, доступ к которой осуществлен
          посредством функций <tt class="METHODNAME">setIconImage()</tt> и <tt class="METHODNAME">iconImage()</tt>. Программа-редактор должна
          вызывать <tt class="METHODNAME">setIconImage()</tt>, когда
          пользователь открывает файл с иконкой, и <tt class="METHODNAME">iconImage()</tt> -- когда пользователь сохраняет
          иконку в файл.</p>

          <p>Переменная <tt class="VARNAME">image</tt> имеет тип
          <tt class="CLASSNAME">QImage</tt>. При инициализации мы
          задаем ей размер 16 X 16 и глубину цвета -- 32 бита, затем
          очищаем ее и разрешаем альфа-буфер.</p>

          <p>Класс <tt class="CLASSNAME">QImage</tt> хранит изображения
          в платформо-независимом виде. Глубина цвета может быть
          выбрана одной из следующих: 1 бит, 8 бит или 32 бита.
          Изображения с 32-х битной глубиной цвета используют по 8 бит
          на каждый цветовой канал -- красный, зеленый и синий, для
          каждого пикселя. Оставшиеся 8 бит определяют значение
          альфа-составляющей пикселя -- степень прозрачности. Например,
          пиксель чистого красного цвета должен иметь значения цветовых
          (красный, зеленый, синий) и альфа каналов -- 255, 0, 0, 255.
          В Qt этот цвет может быть задан как:</p>
          <pre class="SCREEN">QRgb red = qRgba(255, 0, 0, 255);      
      
</pre>или как:
          <pre class="SCREEN">QRgb red = qRgb(255, 0, 0);      
      
</pre>Тип <tt class="CLASSNAME">QRgb</tt> определен как
          <tt class="CLASSNAME">unsigned int</tt>, а <tt class="METHODNAME">QRgb()</tt> и <tt class="METHODNAME">QRgba()</tt> -- это inline-функции, которые
          составляют 32-х битное значение цвета из своих аргументов.
          Допустимо определять цвет таким образом:
          <pre class="SCREEN">QRgb red = 0xFFFF0000;      
      
</pre>где первая пара символов FF соответствует альфа-составляющей, а
вторая пара FF -- красной составляющей цвета. В конструкторе
          <tt class="METHODNAME">IconEditor</tt> мы заполнили
          <tt class="CLASSNAME">QImage</tt> прозрачным цветом, т.е. в
          качестве значения альфа-составляющей указали число 0.<br>
          <br>

          <p>В Qt имеется два типа для хранения значения цвета --
          <tt class="CLASSNAME">QRgb</tt> и <tt class="CLASSNAME">QColor</tt>. <tt class="CLASSNAME">QRgb</tt> --
          это лишь тип, определенный через typedef, который
          используется <tt class="CLASSNAME">QImage</tt> для хранения
          значения цвета, а <tt class="CLASSNAME">QColor</tt> -- это
          полноценный класс, со множеством полезных функций, который
          широко используется в Qt. В нашем случае, мы будем
          использовать <tt class="CLASSNAME">QRgb</tt>, когда будем
          иметь дело с <tt class="CLASSNAME">QImage</tt> и <tt class="CLASSNAME">QColor</tt> во всех остальных случаях, включая
          свойство <tt class="VARNAME">penColor</tt>.</p>
          <pre class="SCREEN">QSize IconEditor::sizeHint() const 
{ 
  QSize size = zoom * image.size(); 
  if (zoom &gt;= 3) 
    size += QSize(1, 1); 
  return size; 
}
      
</pre>Функция <tt class="METHODNAME">sizeHint()</tt> перекрывает метод
класса-родителя и возвращает "идеальный" размер виджета. Она
умножает размер изображения на масштабный коэффициент (zoom). Если
масштабный коэффициент больше 3, то добавляется по одному пикселу, в
каждой из координатных осей, чтобы имелась возможность разместить
координатную сетку (Сетка не отображается, если коэффициент равен 2 или
1).<br>
          <br>

          <p>Идеальный размер виджета главным образом используется в
          целях размещения компонента на форме. Менеджеры размещения в
          Qt всегда пытаются выделить виджету тот объем площади на
          форме, который наиболее близко соответствует идельному
          размеру виджета.</p>

          <p>В дополнение к идеальному размеру, виджет имеет политику
          изменения размера, которая сообщает менеджеру размещения --
          может ли виджет растягиваться или сжиматься. Вызовом
          <tt class="METHODNAME">setSizePolicy()</tt> мы указали
          политику изменения размеров в обоих направлениях, как
          <tt class="PARAMETER"><em>QSizePolicy::Minimum</em></tt>. Тем
          самым, виджет сообщает менеджерам размещения о том, что
          идеальный размер является минимально возможным или, говоря
          другими словами, виджет может быть растянут, но никогда не
          должен сжиматься меньше идеальных размеров. Это поведение
          может быть изменено в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>, установкой свойства
          <tt class="VARNAME">sizePolicy</tt> виджета. Смысл и
          назначение различных политик управления размерами будут
          обсуждаться в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER6">Главе 6</a>.</p>
          <pre class="SCREEN">void IconEditor::setPenColor(const QColor &amp;newColor) 
{ 
  curColor = newColor; 
}
      
</pre>Функция <tt class="METHODNAME">setPenColor()</tt> устанавливает
текущий цвет "чернил", который используется для
"закрашивания" пикселей.
          <pre class="SCREEN">void IconEditor::setIconImage(const QImage &amp;newImage) 
{ 
  if (newImage != image) { 
    image = newImage.convertDepth(32); 
    image.detach(); 
    update(); 
    updateGeometry(); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">setIconImage()</tt> подготавливает
новое изображение к редактированию. Вызов <tt class="METHODNAME">
          convertDepth()</tt> устанвливает глубину цвета равной 32-м
          битам, поскольку мы везде исходим из предположения, что
          изображение имеет 32-х битную глубину цвета.<br>
          <br>

          <p>Затем вызывется <tt class="METHODNAME">detach()</tt>, для
          получения полной копии изображения. Это совершенно
          необходимо, поскольку <tt class="CLASSNAME">QImage</tt>
          пытается сэкономить память и время, копируя изображение
          только в том случае, когда его явно попросят об этом. Такая
          оптимизация называется <span class="emphasis"><em class="EMPHASIS">явное совместное использование</em></span>. Она
          будет подробно обсуждаться в разделе <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#POINTERBASEDCONTAINERS">Контейнеры указателей</a>, <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER11">Главы 11</a> .</p>

          <p>После того, как изображение будет скопировано, мы вызываем
          <tt class="METHODNAME">QWidget::update()</tt>, чтобы
          перерисовать виджет. Затем вызывается <tt class="METHODNAME">QWidget::updateGeometry()</tt>, чтобы сообщить
          менеджеру размещения о том, что идеальный размер виджета
          изменился. После чего будет выполнена автоматическая
          перекомпоновка виджетов, с учетом нового идеального
          размера.</p>
          <pre class="SCREEN">void IconEditor::setZoomFactor(int newZoom) 
{ 
  if (newZoom &lt; 1) 
    newZoom = 1; 
  if (newZoom != zoom) { 
    zoom = newZoom; 
    update(); 
    updateGeometry(); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">setZoomFactor()</tt> устанавливает
масштабный коэффициент изображения. Для предотвращения деления на ноль,
все значения меньше 1 корректируются. Если масштабный коэффициент
действительно изменился, то вызываются <tt class="METHODNAME">
          update()</tt> и <tt class="METHODNAME">updateGeometry()</tt>,
          чтобы перерисовать виджет и известить менеджеров размещения
          об изменении идеального размера.<br>
          <br>

          <p>Функции <tt class="METHODNAME">penColor()</tt>, <tt class="METHODNAME">iconImage()</tt> и <tt class="METHODNAME">zoomFactor()</tt> реализованы в виде
          inline-функций в файле заголовка.</p>

          <p>Теперь перейдем к функции <tt class="METHODNAME">paintEvent()</tt>. Это самая важная функция. Она
          вызывается, когда необходимо перерисовать виджет. Ее
          реализация в <tt class="CLASSNAME">QWidget</tt> фактически
          ничего не делает, оставляя на месте виджета пустое
          пространство.</p>

          <p>Аналогично функциям <tt class="METHODNAME">contextMenuEvent()</tt> и <tt class="METHODNAME">closeEvent()</tt>, с которыми мы сталкивались в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">Главе 3</a>, функция <tt class="METHODNAME">paintEvent()</tt> является обработчиком события.
          В Qt, для обработки любого вида события, предусматривается
          своя функция-обработчик. Обработка событий более подробно
          будет обсуждаться в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER7">Главе 7</a>.</p>

          <p>Существует несколько ситуаций, когда возникает событие
          paint и вызывается <tt class="METHODNAME">paintEvent()</tt>:</p>

          <ul>
            <li>
              <p>Когда виджет выводится на экране самый первый раз,
              система автоматически генерирует событие paint, чтобы
              заставить виджет нарисовать себя.</p>
            </li>

            <li>
              <p>При изменении размера виджета система так же
              генерирует это событие.</p>
            </li>

            <li>
              <p>Если виджет был закрыт другим окном, а затем опять
              открылся, то генерируется событие paint для той области,
              которая была скрыта (если оконная система не сохранила
              эту область).</p>
            </li>
          </ul>Событие так же порождается в результате вызова
          <tt class="METHODNAME">QWidget::update()</tt> или <tt class="METHODNAME">QWidget::repaint()</tt>. Отличия между ними
          заключаются в том, что <tt class="METHODNAME">repaint()</tt>
          вызывает немедленную перерисовку, а <tt class="METHODNAME">update()</tt> просто ставит событие paint в
          очередь, которая обрабатывается библиотекой Qt. (Обе функции
          ничего не делают, если виджет невидим на экране.) Если
          <tt class="METHODNAME">update()</tt> вызывается несколько
          раз, то Qt помещает в очередь только одно событие paint. В
          виджете <tt class="CLASSNAME">IconEditor</tt> мы всегда будем
          использовать только функцию <tt class="METHODNAME">update()</tt>.
          <pre class="SCREEN">void IconEditor::paintEvent(QPaintEvent *) 
{ 
  QPainter painter(this); 
  
  if (zoom &gt;= 3) { 
    painter.setPen(colorGroup().foreground()); 
    for (int i = 0; i &lt;= image.width(); ++i) 
      painter.drawLine(zoom * i, 0, 
                       zoom * i, zoom * image.height()); 
    for (int j = 0; j &lt;= image.height(); ++j) 
      painter.drawLine(0, zoom * j, 
                       zoom * image.width(), zoom * j); 
  } 
  
  for (int i = 0; i &lt; image.width(); ++i) { 
    for (int j = 0; j &lt; image.height(); ++j) 
      drawImagePixel(&amp;painter, i, j); 
  } 
}      
      
</pre>Обработка события начинается с создания объекта
          <tt class="CLASSNAME">QPainter</tt>. Если масштабный
          коэффициент больше 2, то рисуются вертикальная и
          горизонтальная линии, формирующие сетку, с помощью функции
          <tt class="METHODNAME">QPainter::drawLine()</tt>.<br>
          <br>

          <p>Функция <tt class="METHODNAME">QPainter::drawLine()</tt>
          имеет следующий синтаксис вызова:</p>
          <pre class="SCREEN">painter.drawLine(x1, y1, x2, y2);     
      
</pre>где <tt class="PARAMETER"><em>(x1, y1)</em></tt> -- это
координаты начала, а <tt class="PARAMETER"><em>(x2, y2)</em></tt> --
координаты конца линии. Имеется перегруженная версия этой функции,
которая принимает координаты в виде двух <tt class="CLASSNAME">
          QPoint</tt>.<br>
          <br>

          <p>Верхний левый пиксель виджета, в Qt, имеет координаты (0,
          0), правый нижний пиксель -- (<tt class="METHODNAME">width()</tt>-1, <tt class="METHODNAME">height</tt>-1). То есть, по сути, обычная
          Декартова система координат, с небольшим отличием -- ось OY
          направлена вниз, что имеет определенный смысл при
          программировании графического интерфейса. Система координат в
          <tt class="CLASSNAME">QPainter</tt> может быть подвергнута
          таким трансформациям, как трансляция, масштабирование,
          вращение и сдвиг. Более подробно мы обсудим эту тему в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER8">Главе 8</a>.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.3. Пример рисования линии с помощью
              QPainter.</p>
            </div>
          </div><br>
          Прежде чем нарисовать линию, устанавливается цвет
          "чернил", вызовом <tt class="METHODNAME">setPen()</tt>. Можно было бы жестко
          "зашить" цвет в исходном коде, например <tt class="VARNAME">black</tt> или <tt class="VARNAME">gray</tt>, но
          лучше использовать палитру виджета.<br>
          <br>

          <p>Любой виджет снабжается своей собственной палитрой цветов,
          которая определяет -- какой цвет для каких целей
          используется. Например, в палитре есть запись, которая
          определяет цвет фона (обычно светло-серый), есть запись,
          которая определяет цвет текста (обычно черный). Как правило,
          палитра содержит цвета, соответствующие системной цветовой
          схеме. Используя палитру виджета, можно быть уверенным, что
          учитываются цветовые предпочтения пользователя.</p>

          <p>Палитра содержит в себе три основные группы цветов:
          активные, неактивные и запрещенные. Решение о том, какую
          группу цветов использовать, зависит от текущего состояния
          виджета:</p>

          <ul>
            <li>
              <p>Группа активных цветов используется, когда окно, на
              котором размещается виджет, активно.</p>
            </li>

            <li>
              <p>Группа неактивных цветов используется, когда окно, на
              котором размещается виджет, неактивно.</p>
            </li>

            <li>
              <p>Группа запрещенных цветов используется, когда доступ к
              виджету запрещен.</p>
            </li>
          </ul>Функция <tt class="METHODNAME">QWidget::palette()</tt>
          возвращает палитру виджета в виде экземпляра класса
          <tt class="CLASSNAME">QPalette</tt>. Доступ к отдельным
          цветовым группам, имеющим тип <tt class="CLASSNAME">QColorGroup</tt>, осуществляется через функции
          <tt class="METHODNAME">active()</tt>, <tt class="METHODNAME">inactive()</tt> и <tt class="METHODNAME">disabled()</tt>. Для удобства, в класс
          <tt class="CLASSNAME">QWidget</tt> была введена функция
          <tt class="METHODNAME">colorGroup()</tt>, которая возвращает
          ту или иную цветовую группу, в зависимости от состояния
          виджета, благодаря этому, вам довольно редко придется
          напрямую обращаться к палитре.<br>
          <br>

          <p>Функция <tt class="METHODNAME">paintEvent()</tt>
          завершается перерисовкой самого изображения, вызовом
          <tt class="METHODNAME">IconEditor::drawImagePixel()</tt>,
          которая отрисовывает каждый пиксель иконки в виде
          закрашенного квадрата. <a name="P106"></a></p>
          <pre class="SCREEN">void IconEditor::drawImagePixel(QPainter *painter, int i, int j) 
{ 
  QColor color; 
  QRgb rgb = image.pixel(i, j); 
  
  if (qAlpha(rgb) == 0) 
    color = colorGroup().base(); 
  else 
    color.setRgb(rgb); 
  
  if (zoom &gt;= 3) { 
    painter-&gt;fillRect(zoom * i + 1, zoom * j + 1, 
                      zoom - 1, zoom - 1, color); 
  } else { 
    painter-&gt;fillRect(zoom * i, zoom * j, 
                      zoom, zoom, color); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">drawImagePixel()</tt> рисует
пиксели средствами <tt class="CLASSNAME">QPainter</tt>, с учетом
масштабного коэффициента. Параметры <tt class="VARNAME">i</tt> и
<tt class="VARNAME">j</tt> -- это координаты пикселя в системе
координат <tt class="CLASSNAME">QImage</tt>, но не в системе координат
виджета (если масштабный коэффициент равен 1, то эти две системы
координат полностью совпадают). Если пиксель прозрачен
(альфа-составляющая равна 0), то для рисования пикселя используется
цвет "base" текущей группы (обычно -- белый). В противном
случае -- используется цвет пикселя в <tt class="CLASSNAME">QImage</tt>. Затем вызывается <tt class="METHODNAME">
          QPainter::fillRect()</tt>, которая рисует закрашенный
          квадрат. Если поверх изображения рисуется координатная сетка,
          то размер квадрата уменьшается на 1 по обеим осям.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.4.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.4. Пример рисования прямоугольника с помощью
              QPainter.</p>
            </div>
          </div><br>
          Функция <tt class="METHODNAME">QPainter::fillRect()</tt>
          имеет следующий синтаксис:
          <pre class="SCREEN">painter-&gt;fillRect(x, y, w, h, brush);      
      
</pre>где <tt class="VARNAME">(x, y)</tt> -- координаты левого верхнего
угла прямоугольника, <tt class="VARNAME">w x h</tt> -- его размеры, а
<tt class="VARNAME">brush</tt> задает цвет заполнения и шаблон
заполнения. Передавая <tt class="CLASSNAME">QColor</tt>, в качестве
аргумента <tt class="VARNAME">brush</tt>, мы задаем сплошной режим
закрашивания.
          <pre class="SCREEN">void IconEditor::mousePressEvent(QMouseEvent *event) 
{ 
  if (event-&gt;button() == LeftButton) 
    setImagePixel(event-&gt;pos(), true); 
  else if (event-&gt;button() == RightButton)
    setImagePixel(event-&gt;pos(), false); 
}
      
</pre>Когда пользователь нажимает кнопку мыши, система генерирует
событие "mouse press". За счет перекрытия метода родителя
<tt class="METHODNAME">QWidget::mousePressEvent()</tt>, мы получаем
возможность перехватывать и обрабатывать это событие, закрашивая или
очищая пиксель в изображении, находящийся под указателем мыши.<br>

          <br>

          <p>Когда пользователь щелкает левой кнопкой мыши, вызывается
          приватная функция <tt class="METHODNAME">setImagePixel()</tt>
          с аргументом <tt class="PARAMETER"><em>true</em></tt>,
          сообщая о том, что пиксель должен быть закрашен текущим
          цветом "чернил". Если пользователь щелкает правой
          кнопкой мыши, то в функцию <tt class="METHODNAME">setImagePixel()</tt> передается аргумент
          <tt class="PARAMETER"><em>false</em></tt> и пиксель
          очищается.</p>
          <pre class="SCREEN">void IconEditor::mouseMoveEvent(QMouseEvent *event) 
{ 
  if (event-&gt;state() &amp; LeftButton) 
    setImagePixel(event-&gt;pos(), true); 
  else if (event-&gt;state() &amp; RightButton) 
    setImagePixel(event-&gt;pos(), false); 
}
      
</pre>Функция <tt class="METHODNAME">mouseMoveEvent()</tt> обрабатывает
событие "mouse move" (перемещение указателя мыши).
По-умолчанию это событие возникает только в том случае, когда
пользователь перемещает указатель мыши при нажатой, и удерживаемой в
нажатом состоянии, кнопке. Но имеется возможность изменить это
поведение, вызовом <tt class="METHODNAME">QWidget::setMouseTracking()</tt>, однако в данном примере
нам этого не требуется. Аналогично предыдущему обработчику, в
зависимости от того, какая кнопка мыши нажата, пиксели либо
закрашиваются, либо очищаются. Поскольку возможна ситуация, когда
пользователь нажал и удерживает сразу две кнопки -- значение,
возвращаемое <tt class="METHODNAME">QMouseEvent::state()</tt>,
представляет собой битовую карту, в которой каждой из кнопок мыши
соответствует свой бит (в этой карте так же есть биты, определяющие
состояние клавиш Shift и Ctrl на клавиатуре). Проверка факта нажатия на
ту или иную клавишу, выполняется с помощью оператора &amp;. Если
клавиша нажата, то вызывается <tt class="METHODNAME">setImagePixel().</tt>.
          <pre class="SCREEN">void IconEditor::setImagePixel(const QPoint &amp;pos, bool opaque) 
{ 
  int i = pos.x() / zoom; 
  int j = pos.y() / zoom; 
  
  if (image.rect().contains(i, j)) { 
    if (opaque) 
      image.setPixel(i, j, penColor().rgb()); 
    else 
      image.setPixel(i, j, qRgba(0, 0, 0, 0)); 
    
    QPainter painter(this); 
    drawImagePixel(&amp;painter, i, j); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">setImagePixel()</tt> вызывается из
обработчиков <tt class="METHODNAME">mousePressEvent()</tt> и
          <tt class="METHODNAME">mouseMoveEvent()</tt> для закрашивания
          или очистки пикселя. Параметр <tt class="PARAMETER"><em>pos</em></tt> определяет позицию указателя
          мыши в системе координат виджета.<br>
          <br>

          <p>На первом этапе выполняется переход от системы координат
          виджета к системе координат изображения. Переход
          осуществляется делением координат указателя мыши <tt class="VARNAME">x</tt> и <tt class="VARNAME">y</tt> на коэффициент
          масштабирования. Затем проверяется -- находятся ли координаты
          точки в допустимом диапазоне. Проверка выполняется с помощью
          <tt class="METHODNAME">QImage::rect()</tt> и <tt class="METHODNAME">QRect::contains()</tt>, которые проверяют
          попадание <tt class="VARNAME">i</tt> в диапазон 0..<tt class="VARNAME">image.width()</tt>-1 и попадание <tt class="VARNAME">j</tt> в диапазон 0..<tt class="VARNAME">image.height()</tt>-1.</p>

          <p>В зависимости от параметра <tt class="PARAMETER"><em>opaque</em></tt>, пиксель в изображении либо
          окрашивается в заданный цвет, либо очищается.
          "Очистка" пикселя заключается в том, что он
          делается прозрачным. В конце вызывается <tt class="METHODNAME">drawImagePixel()</tt> для перерисовки
          пикселя.</p>

          <p>Теперь мы вернемся к флагу <tt class="PARAMETER"><em>WStaticContents</em></tt>, который мы
          передавали родительскому конструктору. Этот флаг сообщает Qt,
          что содержимое виджета не изменяется, при увеличении размеров
          виджета, и всегда находится в верхнем левом углу. Qt
          использует эту информацию, чтобы избежать напрасной
          перерисовки областей, которые уже видны, при увеличении
          размеров виджета.</p>

          <p>Когда размеры виджета изменяются, Qt обычно генерирует
          событие paint для всей видимой области виджета. Но, если
          виджет был создан с флагом <tt class="PARAMETER"><em>WStaticContents</em></tt>, то действие
          события ограничивается пикселями, которые ранее не были
          показаны. Если же размеры виджета уменьшаются, то событие
          paint вообще не возникает.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.5.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.5. Изменение размеров виджета, созданного с
              флагом WStaticContents.</p>
            </div>
          </div><br>
          На этом, работу по созданию виджета <tt class="CLASSNAME">IconEditor</tt> можно считать законченной.
          Используя знания, полученные в первых главах книги, вы без
          труда напишете код, который будет использовать <tt class="CLASSNAME">IconEditor</tt> в качестве центрального виджета в
          <tt class="CLASSNAME">QMainWindow</tt>, как подчиненный
          виджет внутри области компоновки или внутри <tt class="CLASSNAME">QScrollView</tt>. В следующем разделе мы покажем,
          как интегрировать его в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="INTEGRATINGCUSTOMWIDGETSWITHQTDESIGNER"></a>5.3. Интеграция
          виджета в Qt Designer.</h1>

          <p>Прежде, чем мы сможем использовать наш виджет в
          <span class="emphasis"><em class="EMPHASIS">Qt
          Designer</em></span>, мы должны известить его об этом.
          Существует два подхода: подключение как "простого
          виджета" и как плагина.</p>

          <p>Методика "простого виджета" заключается в
          заполнении полей диалога <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>. После этого виджет может
          вставляться в формы, разрабатываемые в среде <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>, но
          отображаться на форме, во время редактирования и
          предварительного просмотра, он будет в виде черного
          прямоугольника. Ниже приводится последовательность действий
          по интеграции <tt class="CLASSNAME">HexSpinBox</tt> таким
          способом:</p>

          <ol type="1">
            <li>
              <p>Выберите пункт меню <strong class="COMMAND">Tools|Custom|Edit Custom Widget</strong>. Перед
              вами появится диалоговое окно "Edit Custom
              Widgets".</p>
            </li>

            <li>
              <p>Щелкните по кнопке "New Widget".</p>
            </li>

            <li>
              <p>Измените имя класса <tt class="CLASSNAME">MyCustomWidget</tt> на <tt class="CLASSNAME">HexSpinBox</tt> и имя заголовочного файла
              <tt class="FILENAME">mycustomwidget.h</tt> на <tt class="FILENAME">hexspinbox.h</tt>.</p>
            </li>

            <li>
              <p>Измените "Size Hint" на (60, 20).</p>
            </li>

            <li>
              <p>Измените "Size Policy" на (Minimum,
              Fixed).</p>
            </li>
          </ol>После этого виджет появится в секции "Custom
          Widgets" в палитре компонентов <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.6.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.6. Диалог "Edit Custom
              Widgets".</p>
            </div>
          </div><br>
          Подключение виджета в виде плагина требует создания отдельной
          библиотеки, которую <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span> мог бы загружать во время
          своей работы и создавать с ее помощью экземпляры виджета. При
          таком подходе на форме, во время ее редактирования и
          предварительного просмотра, будет отображаться настоящий
          виджет. Продемонстрируем подключение виджета к <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>, в
          виде плагина, на примере <tt class="CLASSNAME">IconEditor</tt>.<br>
          <br>

          <p>Прежде всего, необходимо создать класс-потомок от
          <tt class="CLASSNAME">QWidgetPlugin</tt> и перекрыть
          некоторые виртуальные функции. Весь код можно разместить в
          тех же самых файлах с исходными текстами, но мы создадим
          файлы плагина отдельно. Допустим, что файлы, с исходным кодом
          плагина, находятся в каталоге <tt class="FILENAME">iconeditorplugin</tt>, а с исходным кодом самого
          компонента -- в параллельном каталоге <tt class="FILENAME">iconeditor</tt>.</p>

          <p>Заголовочный файл плагина:</p>
          <pre class="SCREEN">#include &lt;qwidgetplugin.h&gt; 

#include "../iconeditor/iconeditor.h" 

class IconEditorPlugin : public QWidgetPlugin 
{ 
public: 
  QStringList keys() const; 
  QWidget *create(const QString &amp;key, QWidget *parent, 
                  const char *name);      
  QString includeFile(const QString &amp;key) const; 
  QString group(const QString &amp;key) const; 
  QIconSet iconSet(const QString &amp;key) const; 
  QString toolTip(const QString &amp;key) const; 
  QString whatsThis(const QString &amp;key) const; 
  bool isContainer(const QString &amp;key) const; 
};                  
      
</pre>Класс <tt class="CLASSNAME">IconEditorPlugin</tt> является своего
рода "фабрикой", которая изготавливает и выпускает экземпляры
виджета <tt class="CLASSNAME">IconEditor</tt>. Функции плагина
используются средой <span class="emphasis"><em class="EMPHASIS">
          Qt Designer</em></span> для создания экземпляров класса и
          получения необходимой информации.
          <pre class="SCREEN">QStringList IconEditorPlugin::keys() const 
{ 
  return QStringList() &lt;&lt; "IconEditor"; 
}      
      
</pre>Функция <tt class="METHODNAME">keys()</tt> возвращает список
виджетов, "выпускаемых" плагином-фабрикой. Наш плагин
"выпускает" только один виджет -- <tt class="CLASSNAME">
          IconEditor</tt>.
          <pre class="SCREEN">QWidget *IconEditorPlugin::create(const QString &amp;, QWidget *parent, 
                                  const char *name) 
{ 
  return new IconEditor(parent, name); 
}      
      
</pre>Функцию <tt class="METHODNAME">create()</tt> вызывает
          <span class="emphasis"><em class="EMPHASIS">Qt
          Designer</em></span>, когда необходимо создать экземпляр
          виджета. Первый аргумент -- имя класса виджета. В данном
          примере мы можем игнорировать его, поскольку наш плагин
          обслуживает только один класс. Все остальные функции так же
          получают имя класса в первом аргументе.
          <pre class="SCREEN">QString IconEditorPlugin::includeFile(const QString &amp;) const 
{ 
  return "iconeditor.h"; 
}      
      
</pre>Функция <tt class="METHODNAME">includeFile()</tt> возвращает имя
заголовочного файла виджета, который представляет плагин. Имя файла
заголовка подключается к коду, создаваемому утилитой
          <tt class="USERINPUT"><strong>uic</strong></tt>.
          <pre class="SCREEN">bool IconEditorPlugin::isContainer(const QString &amp;) const 
{ 
  return false; 
}      
      
</pre>Функция <tt class="METHODNAME">isContainer()</tt> возвращает
<tt class="PARAMETER"><em>true</em></tt>, если виджет может содержать в
себе другие виджеты, иначе -- <tt class="PARAMETER"><em>false</em></tt>. Например, <tt class="CLASSNAME">
          QFrame</tt> может содержать в себе другие виджеты. В нашем
          случае возвращается <tt class="PARAMETER"><em>false</em></tt>, поскольку нет смысла делать
          из <tt class="CLASSNAME">IconEditor</tt> контейнер для других
          виджетов. Строго говоря, любой виджет может быть площадкой
          для размещения других виджетов, но <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>
          отвергает такую возможность, если <tt class="METHODNAME">isContainer()</tt> возвращает <tt class="PARAMETER"><em>false</em></tt>.
          <pre class="SCREEN">QString IconEditorPlugin::group(const QString &amp;) const 
{ 
  return "Plugin Widgets"; 
}      
      
</pre>Функция <tt class="METHODNAME">group()</tt> возвращает имя секции
палитры компонентов, в которой будет размещен виджет. Если такой секции
пока нет, она будет создана автоматически.
          <pre class="SCREEN">QIconSet IconEditorPlugin::iconSet(const QString &amp;) const 
{ 
  return QIconSet(QPixmap::fromMimeSource("iconeditor.png")); 
}      
      
</pre>Функция <tt class="METHODNAME">iconSet()</tt> возвращает иконку
для палитры компонентов.
          <pre class="SCREEN">QString IconEditorPlugin::toolTip(const QString &amp;) const 
{ 
  return "Icon Editor"; 
}      
      
</pre>Функция <tt class="METHODNAME">toolTip()</tt> возвращает текст
подсказки, которая появляется при наведении указателя мыши на иконку
виджета в палитре компонентов.
          <pre class="SCREEN">QString IconEditorPlugin::whatsThis(const QString &amp;) const 
{ 
  return "Widget for creating and editing icons"; 
}
      
</pre>Функция <tt class="METHODNAME">whatsThis()</tt> возвращает текст,
который появляется по запросу "What's This?"
          <span class="emphasis"><em class="EMPHASIS">Qt
          Designer</em></span>-а.
          <pre class="SCREEN">Q_EXPORT_PLUGIN(IconEditorPlugin)      
      
</pre>Файл с исходным текстом плагина должен завершаться вызовом
макроса <tt class="PARAMETER"><em>Q_EXPORT_PLUGIN()</em></tt>.<br>

          <br>

          <p>Файл <tt class="FILENAME">.pro</tt> для сборки плагина
          выглядит примерно так:</p>
          <pre class="SCREEN">TEMPLATE   = lib 
CONFIG    += plugin 
HEADERS    = ../iconeditor/iconeditor.h 
SOURCES    = iconeditorplugin.cpp \ 
             ../iconeditor/iconeditor.cpp 
IMAGES     = images/iconeditor.png 
DESTDIR    = $(QTDIR)/plugins/designer      
      
</pre>Предполагается, что переменная окружения <tt class="VARNAME">
          QTDIR</tt> содержит путь к каталогу, куда была установлена
          библиотека Qt. Когда вы собираете плагин командой <tt class="USERINPUT"><strong>make</strong></tt> или <tt class="USERINPUT"><strong>nmake</strong></tt>, он автоматически
          устанавливается в каталог <tt class="FILENAME">plugins</tt>
          <span class="emphasis"><em class="EMPHASIS">Qt
          Designer</em></span>-а.<br>
          <br>

          <p>После сборки плагина вы можете использовать <tt class="CLASSNAME">IconEditor</tt> в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span> точно
          так же, как встроенные виджеты Qt.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="DOUBLEBUFFERING"></a>5.4.
          Двойная буферизация.</h1>

          <p>Двойная буферизация применяется для создания
          быстроменяющегося интерфейса и устранения эффекта мерцания.
          Мерцание возникает, когда те же самые пиксели
          перерисовываются несколько раз подряд, в различные цвета и в
          течение очень короткого отрезка времени. Если это происходит
          с одним пикселем, то эффект мерцания практически не заметен
          из-за незначительных размеров одного пикселя, но если это
          происходит с большой группой пикселей, эффект становится
          заметным и может вызывать у пользователя чувство
          раздражения.</p>

          <p>Когда Qt генерирует событие paint, виджет сначала
          "стирается" -- т.е. все пиксели окрашиваются цветом
          фона. Затем, в функции <tt class="METHODNAME">paintEvent()</tt> виджету остается окрасить
          только те пиксели, цвет которых отличается от цвета фона.
          Такой двухшаговый алгоритм довольно удобен, поскольку мы
          перерисовываем только то что нужно, нимало не беспокоясь о
          других писелях.</p>

          <p>К сожалению, этот алгоритм является основной причиной
          возникновения мерцания. Например, если пользователь изменяет
          размеры виджета, область окна под виджетом сначала полностью
          очищается, а затем выполняется рисование виджета. Особенно
          ярко эффект мерцания проявляется, когда оконная система
          отображает содержимое окна при изменении его размеров,
          поскольку в этом случае виджеты многократно рисуются и
          стираются.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.7.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.7. Порядок перерисовки виджета, при
              изменении размеров.</p>
            </div>
          </div><br>
          Флаг <tt class="PARAMETER"><em>WStaticContents</em></tt>, с
          которым мы создавали виджет <tt class="CLASSNAME">IconEditor</tt>, может рассматриваться как одно
          из возможных решений проблемы мерцания, но оно применимо
          только к виджетам, содержимое которых не зависит от их
          размера. Такие виджеты -- довольно редкое явление. В
          большинстве своем они стремятся растягивать свое содержимое,
          чтобы полностью занять отводимое им пространство. Они требуют
          полной перерисовки, при изменении размеров. В этом случае
          тоже можно устранить эффект мерцания, но решение проблемы
          немного сложнее.<br>
          <br>

          <p>Первое правило, на пути к устранению мерцания --
          конструировать виджет с флагом <tt class="PARAMETER"><em>WNoAutoErase</em></tt>. Этот флаг
          предотвращает стирание виджета перед передачей событие
          paint.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.8.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.8. Порядок перерисовки виджета, созданного с
              флагом <tt class="PARAMETER"><em>WNoAutoErase</em></tt>.</p>
            </div>
          </div><br>
          При использовании флага <tt class="PARAMETER"><em>WNoAutoErase</em></tt> очень важно, чтобы
          обработчик события paint явно окрашивал все пиксели виджета.
          Любой из пикселей, которые явно не были окрашены нужным
          цветом, сохранит свой прежний цвет, причем этот цвет не
          обязательно будет цветом фона.<br>
          <br>

          <p>Правило второе -- окрашивать каждый из пикселей только
          один раз. Самый простой способ выполнить это требование --
          рисовать виджет сначала в памяти, а затем копировать
          полученный рисунок. При таком подходе уже не важно -- сколько
          раз окрашивался тот или иной пиксель, поскольку рисование
          проходит не на экране. Этот прием называется <span class="emphasis"><em class="EMPHASIS">двойной
          буферизацией</em></span>.</p>

          <p>Процесс добавления двойной буферизации в виджет не очень
          сложен. Предположим, что оригинальный обработчик события
          paint выглядит примерно так:</p>
          <pre class="SCREEN">void MyWidget::paintEvent(QPaintEvent *) 
{ 
  QPainter painter(this); 
  drawMyStuff(&amp;painter); 
}      
      
</pre>Тогда версия обработчика, использующего технику двойной
буферизации, могла бы выглядеть как то так:
          <pre class="SCREEN">void MyWidget::paintEvent(QPaintEvent *event) 
{ 
  static QPixmap pixmap; 
  QRect rect = event-&gt;rect(); 
  
  QSize newSize = rect.size().expandedTo(pixmap.size()); 
  pixmap.resize(newSize); 
  pixmap.fill(this, rect.topLeft()); 
  
  QPainter painter(&amp;pixmap, this); 
  painter.translate(-rect.x(), -rect.y()); 
  drawMyStuff(&amp;painter); 
  bitBlt(this, rect.x(), rect.y(), &amp;pixmap, 0, 0, 
         rect.width(), rect.height()); 
}
      
</pre>Сначала устанавливаются размеры <tt class="CLASSNAME">QPixmap</tt> такими, чтобы они были не меньше размеров
прямоугольника, описывающего область перерисовки. (Чаще всего область
перерисовки имеет прямоугольную или Г-образную форму, но может иметь и
более сложный вид.) Экземпляр <tt class="CLASSNAME">QPixmap</tt>
объявлен статическим, чтобы избежать постоянных операций по его
созданию/удалению. По тем же причинам мы никогда не уменьшаем его
размер -- вызовы <tt class="METHODNAME">QSize::expandedTo()</tt> и
<tt class="METHODNAME">QPixmap::resize()</tt> приводят к тому, что в
течение всей своей "жизни" <tt class="CLASSNAME">QPixmap</tt>
будет только расти. Далее, <tt class="CLASSNAME">QPixmap</tt>
заполняется цветом фона виджета. Второй аргумент функции
          <tt class="METHODNAME">fill()</tt> указывает -- в какой
          позиции виджета будет находиться верхний левый угол
          <tt class="CLASSNAME">QPixmap</tt>. (Это важно в том случае,
          когда виджет имеет фоновое изображение и процесс
          "стирания" заключается не в заполнении виджета
          однородным цветом, а в рисовании фонового изображения.)<br>
          <br>

          <p>Класс <tt class="CLASSNAME">QPixmap</tt> очень напоминает
          <tt class="CLASSNAME">QImage</tt> и <tt class="CLASSNAME">QWidget</tt>. Подобно <tt class="CLASSNAME">QImage</tt>, он хранит изображение, но глубина
          цвета и цветовая палитра зависят от настроек дисплея, подобно
          <tt class="CLASSNAME">QWidget</tt>. Если оконная система
          работает с 8-ми битным цветом, все <tt class="CLASSNAME">QWidget</tt> и <tt class="CLASSNAME">QPixmap</tt>
          ограничиваются 256-ю цветами, а Qt автоматически переводит
          24-х битный цвет в 8-ми битное представление.</p>

          <p>Затем создается <tt class="CLASSNAME">QPainter</tt>.
          Передавая указатель <tt class="PARAMETER"><em>this</em></tt>
          конструктору, мы заставляем <tt class="CLASSNAME">QPainter</tt> взять некоторые настройки, например
          шрифт, из виджета. Вызовом <tt class="METHODNAME">translate()</tt> осуществляется переход к
          системе координат виджета.</p>

          <p>В завершение, изображение копируется в виджет с помощью
          глобальной функции <tt class="METHODNAME">bitBlt()</tt> (от
          англ. "bit-block transfer" -- "перемещение
          битового блока").</p>

          <p>Двойная буферизация бывает полезной не только для
          устранения эффекта мерцания. Выгода от ее использования
          особенно заметна в тех случаях, когда формирование
          изображения -- довольно сложный процесс, и оно должно
          периодически обновляться на экране. Такие изображения могут
          сохраняться в памяти, вместе с виджетом, и копироваться в
          виджет при наступлении события paint. Это особенно полезно,
          когда необходимо внести в рисунок лишь незначительные
          изменения, например -- нарисовать границы прямоугольника
          выделения.</p>

          <p>В завершение этой главы мы рассмотрим создание виджета
          <tt class="CLASSNAME">Plotter</tt>. Он использует двойную
          буферизацию, а так же демонстрирует некоторые аспекты
          программирования в Qt, включая обработку событий от
          клавиатуры и системы координат.</p>

          <p>Виджет <tt class="CLASSNAME">Plotter</tt> отображает одну
          или несколько кривых, каждая из которых задается массивом
          координат. Пользователь может выделить мышью некоторую
          область на графике, а <tt class="CLASSNAME">Plotter</tt>
          изменит масштаб отображения по осям так, что выделенная
          область целиком займет пространство виджета.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.9.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.9. Изменение масштаба в компоненте
              <tt class="CLASSNAME">Plotter</tt>.</p>
            </div>
          </div><br>
          Пользователь может неоднократно изменять масштаб таким
          образом. Откат на шаг назад выполняется нажатием на кнопку
          "Zoom Out", а возврат, после выполнения отката --
          кнопкой "Zoom In". Эти кнопки видны только тогда,
          когда пользователь хотя бы раз изменял масштаб
          отображения.<br>
          <br>

          <p>Компонент может хранить данные любого числа кривых. Он так
          же имеет стек из экземпляров класса <tt class="VARNAME">PlotSettings</tt>, на котором хранится история
          изменения масштаба пользователем.</p>

          <p>Начнем с файла заголовка:</p>
          <pre class="SCREEN">#ifndef PLOTTER_H 
#define PLOTTER_H 

#include &lt;qpixmap.h&gt; 
#include &lt;qwidget.h&gt; 

#include &lt;map&gt; 
#include &lt;vector&gt; 

class QToolButton; 
class PlotSettings; 

typedef std::vector&lt;double&gt; CurveData;      
      
</pre>Мы подключили стандартные заголовки <tt class="FILENAME">
          &lt;map&gt;</tt> и <tt class="FILENAME">&lt;vector&gt;</tt>.
          Мы не импортировали символы из пространства имен <tt class="PARAMETER"><em>std</em></tt> -- для заголовочных файлов это
          считается дурным тоном.<br>
          <br>

          <p>Мы определили <tt class="CLASSNAME">CurveData</tt>, как
          синоним <tt class="CLASSNAME">std::vector&lt;double&gt;</tt>.
          Координаты точек, определяющих кривую на графике,
          предполагается хранить в виде массива пар координат
          <tt class="VARNAME">x</tt> и <tt class="VARNAME">y</tt>.
          Например, кривая задана тремя точками, с координатами (0,
          24), (1, 44), (2, 89), что соответствует массиву значений [0,
          24, 1, 44, 2, 89].</p>
          <pre class="SCREEN">class Plotter : public QWidget 
{ 
  Q_OBJECT 
  
public: 
  Plotter(QWidget *parent = 0, const char *name = 0, 
          WFlags flags = 0); 
  void setPlotSettings(const PlotSettings &amp;settings); 
  void setCurveData(int id, const CurveData &amp;data); 
  void clearCurve(int id); 
  QSize minimumSizeHint() const; 
  QSize sizeHint() const; 
  
public slots: 
  void zoomIn(); 
  void zoomOut();      
      
</pre>Компонент имеет три публичных метода для его настройки, и два
публичных слота изменяющих масштаб отображения. Кроме того, перекрыты
методы предка <tt class="METHODNAME">minimumSizeHint()</tt> и
          <tt class="METHODNAME">sizeHint()</tt>.
          <pre class="SCREEN">protected: 
  void paintEvent(QPaintEvent *event); 
  void resizeEvent(QResizeEvent *event); 
  void mousePressEvent(QMouseEvent *event); 
  void mouseMoveEvent(QMouseEvent *event); 
  void mouseReleaseEvent(QMouseEvent *event); 
  void keyPressEvent(QKeyEvent *event); 
  void wheelEvent(QWheelEvent *event);      
      
</pre>В защищенной секции класса объявлены функции-обработчики событий,
которые мы должны реализовать.
          <pre class="SCREEN">private: 
  void updateRubberBandRegion(); 
  void refreshPixmap(); 
  void drawGrid(QPainter *painter); 
  void drawCurves(QPainter *painter); 
  
  enum { Margin = 40 }; 
  
  QToolButton *zoomInButton; 
  QToolButton *zoomOutButton; 
  std::map&lt;int, CurveData&gt; curveMap; 
  std::vector&lt;PlotSettings&gt; zoomStack; 
  int curZoom; 
  bool rubberBandIsShown; 
  QRect rubberBandRect; 
  QPixmap pixmap; 
};
      
</pre>В приватной секции объявлены константа, несколько функций,
связанных с рисованием, и несколько переменных-членов. Константа
<tt class="VARNAME">Margin</tt> определяет ширину пустого пространства
вокруг графика. Среди переменных присутствует <tt class="CLASSNAME">
          QPixmap</tt>, которая хранит копию изображения виджета,
          идентичного тому, что отображается на экране. График с
          кривыми всегда сначала рисуется в этой переменной, а затем
          копируется в виджет.
          <pre class="SCREEN">class PlotSettings 
{ 
public: 
  PlotSettings();
  
  void scroll(int dx, int dy); 
  void adjust(); 
  double spanX() const { return maxX - minX; } 
  double spanY() const { return maxY - minY; } 
  
  double minX; 
  double maxX; 
  int numXTicks; 
  double minY; 
  double maxY; 
  int numYTicks; 
  
private: 
  void adjustAxis(double &amp;min, double &amp;max, int &amp;numTicks); 
}; 
#endif      
      
</pre>Класс <tt class="CLASSNAME">PlotSettings</tt> определяет дипазоны
изменения аргументов по осям <tt class="VARNAME">x</tt> и
          <tt class="VARNAME">y</tt>, а так же количество рисок,
          отображаемых на каждой из осей. На рисунке 5.10 показано
          соответствие между объектом <tt class="CLASSNAME">PlotSettings</tt> и масштабом отображения виджета
          <tt class="CLASSNAME">Plotter</tt>.<br>
          <br>

          <p>Строго говоря, переменные <tt class="VARNAME">numXTicks</tt> и <tt class="VARNAME">numYTicks</tt>
          хранят не число рисок, а число интервалов между рисками, т.е.
          если, например, в переменной <tt class="VARNAME">numXTicks</tt> хранится число 5, то фактически, на
          оси x будет нарисовано 6 рисок. Такой подход упрощает
          расчеты, которые мы будем рассматривать чуть ниже.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.10.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.10. Переменные-члены класса
              PlotSettings.</p>
            </div>
          </div><br>
          Перейдем к файлу ревлизации:
          <pre class="SCREEN">#include &lt;qpainter.h&gt; 
#include &lt;qstyle.h&gt; 
#include &lt;qtoolbutton.h&gt; 

#include &lt;cmath&gt; 
using namespace std; 

#include "plotter.h"      
      
</pre>Мы подключили все необходимые заголовочные файлы и импортировали
все имена из пространства имен <tt class="VARNAME">std</tt>.
          <pre class="SCREEN">Plotter::Plotter(QWidget *parent, const char *name, WFlags flags) 
    : QWidget(parent, name, flags | WNoAutoErase) 
{ 
  setBackgroundMode(PaletteDark); 
  setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); 
  setFocusPolicy(StrongFocus); 
  rubberBandIsShown = false; 
  
  zoomInButton = new QToolButton(this); 
  zoomInButton-&gt;setIconSet(QPixmap::fromMimeSource("zoomin.png")); 
  zoomInButton-&gt;adjustSize(); 
  connect(zoomInButton, SIGNAL(clicked()), this, SLOT(zoomIn())); 
  
  zoomOutButton = new QToolButton(this); 
  zoomOutButton-&gt;setIconSet( QPixmap::fromMimeSource("zoomout.png")); 
  zoomOutButton-&gt;adjustSize(); 
  connect(zoomOutButton, SIGNAL(clicked()), this, SLOT(zoomOut()));
  
  setPlotSettings(PlotSettings()); 
}
      
</pre>Третьим аргументом, конструктор <tt class="CLASSNAME">Plotter</tt> принимает набор флагов. Этот аргумент просто
передается родительскому конструктору, правда, при этом попутно
включается флаг <tt class="PARAMETER"><em>WNoAutoErase</em></tt>. Этот
параметр имеет особое значение для виджетов, которые могут
использоваться как автономные окна, поскольку позволяет пользователю
класса сконфигурировать рамку окна и полосу заголовка.<br>
          <br>

          <p>Вызов <tt class="METHODNAME">setBackgroundMode()</tt>
          устанавливает в качестве фонового, вместо элемента палитры
          "background", элемент палитры -- "dark"
          (темный). Хотя в конструктор базового класса и передается
          флаг <tt class="PARAMETER"><em>WNoAutoErase</em></tt>, тем не
          менее, по-прежнему необходимо иметь какой нибудь цвет в
          качестве фонового, которым будут закрашиваться пиксели,
          появляющиеся при увеличении размеров виджета, до того, как
          сработает обработчик <tt class="METHODNAME">paintEvent()</tt>. Поскольку фон виджета
          <tt class="CLASSNAME">Plotter</tt> будет темным, то
          определенно имеет смысл окрашивать новые пиксели именно в
          темный цвет.</p>

          <p>Затем, вызовом <tt class="METHODNAME">setSizePolicy()</tt>, устанавливается политика
          изменения размеров виджета. В данном случае, виджет может
          свободно изменять свои размеры по обеим осям. Такая политика
          изменения размеров характерна для виджетов, которые могут
          занимать значительную часть площади экрана. По-умолчанию,
          политика изменения размеров, для обеих осей, имеет значение
          <tt class="PARAMETER"><em>QSizePolicy::Preferred</em></tt>,
          т.е. -- виджет "предпочитает" иметь размеры, равные
          "идеальным" значениям, но допускает и сжатие до
          минимально возможного размера (<tt class="METHODNAME">minimumSizeHint()</tt>), и растягивание до
          неопределенного предела.</p>

          <p>Вызов <tt class="METHODNAME">setFocusPolicy()</tt>
          указывает виджету, что он может принимать фокус по щелчку
          мыши или по клавише Tab. Когда <tt class="CLASSNAME">Plotter</tt> владеет фокусом, он может принимать
          и обрабатывать события от клавиатуры. Он реагирует на нажатия
          клавиш: "+" -- увеличить изображение, "-"
          -- уменьшить изображение и клавиши со стрелками -- для
          перемещения графика вверх, вниз, влево и вправо.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.11.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.11. Перемещение графика клавишами управления
              курсором.</p>
            </div>
          </div><br>
          Остальной код конструктора создает две кнопки <tt class="CLASSNAME">QToolButton</tt> с иконками. С помощью этих
          кнопок пользователь сможет перемещаться, взад и вперед, по
          стеку истории изменения масштаба. Иконки для кнопок хранятся
          в коллекции изображений, поэтому в файл <tt class="FILENAME">.pro</tt> мы добавили следующие строки:
          <pre class="SCREEN">IMAGES += images/zoomin.png \ 
          images/zoomout.png      
      
</pre>Вызовы методов <tt class="METHODNAME">adjustSize()</tt> кнопок,
устанавливают размеры кнопок равные их "идеальным"
размерам.<br>
          <br>

          <p>И, наконец, вызов <tt class="METHODNAME">setPlotSettings()</tt> завершает инициализацию
          виджета.</p>
          <pre class="SCREEN">void Plotter::setPlotSettings(const PlotSettings &amp;settings) 
{ 
  zoomStack.resize(1); 
  zoomStack[0] = settings;
  curZoom = 0; 
  zoomInButton-&gt;hide(); 
  zoomOutButton-&gt;hide(); 
  refreshPixmap(); 
}
      
</pre>Функция <tt class="METHODNAME">setPlotSettings()</tt>
используется для того, чтобы указать <tt class="CLASSNAME">PlotSettings</tt>, который должен использоваться для
отображения графика. Она вызывается из конструктора и может вызываться
пользователем класса. Каждый раз, когда пользователь изменяет масштаб
отображения, создается новый экземпляр <tt class="CLASSNAME">PlotSettings</tt> и помещается на стек истории изменения
масштаба.<br>
          <br>

          <p>Стек представляют две переменные:</p>

          <ul>
            <li>
              <p><tt class="VARNAME">zoomStack</tt> -- хранит
              экземпляры <tt class="CLASSNAME">PlotSettings</tt> в виде
              одномерного массива <tt class="VARNAME">vector&lt;PlotSettings&gt;</tt>.</p>
            </li>

            <li>
              <p><tt class="VARNAME">curZoom</tt> -- индекс экземпляра
              <tt class="CLASSNAME">PlotSettings</tt> (в массиве
              <tt class="VARNAME">zoomStack</tt>), который представляет
              текущие настройки.</p>
            </li>
          </ul>После вызова <tt class="METHODNAME">setPlotSettings()</tt>, стек содержит только
          одну запись и обе кнопки, <strong class="COMMAND">Zoom
          In</strong> и <strong class="COMMAND">Zoom Out</strong>,
          скрыты. Они останутся невидимыми до тех пор, пока мы не
          вызовем их методы <tt class="METHODNAME">show()</tt> в слотах
          <tt class="METHODNAME">zoomIn()</tt> и <tt class="METHODNAME">zoomOut()</tt>. (Обычно, для того, чтобы сделать
          подчиненные виджеты видимыми, достаточно вызвать метод
          <tt class="METHODNAME">show()</tt> владельца, но в данном
          случае, мы явно вызывали <tt class="METHODNAME">hide()</tt> у
          подчиненных виджетов, поэтому они останутся скрытыми до тех
          пор, пока мы явно не вызовем методы <tt class="METHODNAME">show()</tt>.)<br>
          <br>

          <p>Вызов <tt class="METHODNAME">refreshPixmap()</tt>
          обновляет изображение. Как правило, в таких случаях, мы
          вызываем <tt class="METHODNAME">update()</tt>, но в данной
          ситуации все делается несколько иначе, поскольку необходимо,
          чтобы <tt class="CLASSNAME">QPixmap</tt> хранил самую
          последнюю версию картинки, отображаемой на экране. После
          регенерации картинки, <tt class="METHODNAME">refreshPixmap()</tt> вызывает <tt class="METHODNAME">update()</tt>, чтобы скопировать полученное
          изображение в виджет.</p>
          <pre class="SCREEN">void Plotter::zoomOut() 
{ 
  if (curZoom &gt; 0) { 
    --curZoom; 
    zoomOutButton-&gt;setEnabled(curZoom &gt; 0); 
    zoomInButton-&gt;setEnabled(true); 
    zoomInButton-&gt;show(); 
    refreshPixmap(); 
  } 
}
      
</pre>Слот <tt class="METHODNAME">zoomOut()</tt> уменьшает изображение,
если оно перед этим было увеличено. Индекс текущего элемента на стеке
уменьшается, и разрешается или запрещается кнопка
          <strong class="COMMAND">Zoom Out</strong>, в зависимости от
          того -- возможно ли дальнейшее перемещение к началу истории.
          Кнопка <strong class="COMMAND">Zoom In</strong> разрешается и
          делается видимой. В конце, изображение обновляется вызовом
          <tt class="METHODNAME">refreshPixmap()</tt>.
          <pre class="SCREEN">void Plotter::zoomIn() 
{ 
  if (curZoom &lt; (int)zoomStack.size() - 1) { 
    ++curZoom; 
    zoomInButton-&gt;setEnabled( curZoom &lt; (int)zoomStack.size() - 1); 
    zoomOutButton-&gt;setEnabled(true); 
    zoomOutButton-&gt;show(); 
    refreshPixmap();
  } 
}
      
</pre>Если пользователь сначала увеличил изображение, а затем опять
уменьшил, <tt class="CLASSNAME">PlotSettings</tt> положит предыдущее
значение масштаба на стек и мы сможем опять увеличить изображение
нажатием на кнопку. (По прежнему остается возможность увеличить размер
изображения, выделив мышью требуемый участок графика)<br>
          <br>

          <p>Слот увеличивает значение переменной <tt class="VARNAME">curZoom</tt>, для перемещения на очередной уровень
          в стеке масштабов. Разрешает или запрещает кнопку
          <strong class="COMMAND">Zoom In</strong> в зависимости от
          того -- достигнуто ли дно стека. И разрешает кнопку
          <strong class="COMMAND">Zoom Out</strong>. Напоследок
          вызывается <tt class="METHODNAME">refreshPixmap()</tt>, чтобы
          обновить изображение на экране.</p>
          <pre class="SCREEN">void Plotter::setCurveData(int id, const CurveData &amp;data) 
{ 
  curveMap[id] = data; 
  refreshPixmap(); 
}
      
</pre>Функция <tt class="METHODNAME">setCurveData()</tt> заносит массив
координат для заданной кривой. Если кривая с таким ID уже существует,
то она заменяется новыми данными, в противном случае в график
вставляется новая кривая. Координаты точек кривых хранятся в переменной
<tt class="VARNAME">curveMap</tt>, имеющей тип <tt class="CLASSNAME">
          map&lt;int, CurveData&gt;</tt>.<br>
          <br>

          <p>И опять же, для обновления отображения на экране, вместо
          <tt class="METHODNAME">update()</tt>, вызывается <tt class="METHODNAME">refreshPixmap()</tt>.</p>
          <pre class="SCREEN">void Plotter::clearCurve(int id) 
{ 
  curveMap.erase(id); 
  refreshPixmap(); 
}
      
</pre>Функция <tt class="METHODNAME">clearCurve()</tt> удаляет кривую
из <tt class="VARNAME">curveMap</tt>.
          <pre class="SCREEN">QSize Plotter::minimumSizeHint() const 
{ 
  return QSize(4 * Margin, 4 * Margin); 
}      
      
</pre>Функция <tt class="METHODNAME">minimumSizeHint()</tt> очень
похожа на <tt class="METHODNAME">sizeHint()</tt>, с тем лишь отличием,
что последняя возвращает "идеальные" размеры виджета, а
<tt class="METHODNAME">minimumSizeHint()</tt> -- минимальные
"идеальные" размеры. Менеджеры размещения никогда не будут
пытаться уменьшить размеры виджета меньше этих пределов.<br>
          <br>

          <p>В данном случае функция возвращает размер 160 X 160,
          который учитывает размер рамки вокруг графика и некоторое
          пространство для рисования самого графика. Ниже этого размера
          график будет получаться слишком маленьким.</p>
          <pre class="SCREEN">QSize Plotter::sizeHint() const 
{ 
  return QSize(8 * Margin, 6 * Margin); 
}
      
</pre>Функция <tt class="METHODNAME">sizeHint()</tt> возвращет
"идеальные" размеры виджета, устанавливая его пропорции как
4:3.<br>
          <br>

          <p>На этом мы завершаем обзор публичных методов и слотов
          класса <tt class="CLASSNAME">Plotter</tt> и переходим к
          защищенным обработчикам событий.</p>
          <pre class="SCREEN">void Plotter::paintEvent(QPaintEvent *event) 
{ 
  QMemArray&lt;QRect&gt; rects = event-&gt;region().rects(); 
  for (int i = 0; i &lt; (int)rects.size(); ++i) 
    bitBlt(this, rects[i].topLeft(), &amp;pixmap, rects[i]); 
  
  QPainter painter(this); 
  
  if (rubberBandIsShown) { 
    painter.setPen(colorGroup().light()); 
    painter.drawRect(rubberBandRect.normalize()); 
  } 
  if (hasFocus()) { 
    style().drawPrimitive(QStyle::PE_FocusRect, &amp;painter, 
                          rect(), colorGroup(), QStyle::Style_FocusAtBorder, 
                          colorGroup().dark()); 
  } 
}
      
</pre>Как правило, в <tt class="METHODNAME">paintEvent()</tt>
сосредотачивается весь код, который отвечает за рисование виджета на
экране. Но в нашем случае, рисование выполняет функция
          <tt class="METHODNAME">refreshPixmap()</tt>, поэтому здесь мы
          просто переносим буфер с рисунком в виджет.<br>
          <br>

          <p>Вызов <tt class="METHODNAME">QRegion::rect()</tt>
          возвращает массив из <tt class="CLASSNAME">QRect</tt>,
          который задает область перерисовки. Для копирования каждой
          подобласти, из буфера с изображением в виджет, используется
          функция <tt class="METHODNAME">bitBlt()</tt>. Это функция с
          глобальной областью видимости. Она имеет следующий
          синтаксис:</p>
          <pre class="SCREEN">bitBlt(dest, destPos, source, sourceRect);      
      
</pre>где <tt class="PARAMETER"><em>source</em></tt> -- это
виджет-источник (в нашем случае -- буфер с картинкой),
          <tt class="PARAMETER"><em>dest</em></tt> -- виджет-приемник
          (или pixmap) и <tt class="PARAMETER"><em>destPos</em></tt> --
          координаты верхнего левого угла области в приемнике, в
          которую будет выполняться копирование.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.12.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.12. Копирование некоторой прямоугольной
              области из буфера в виджет.</p>
            </div>
          </div><br>
          В принципе, функция <tt class="METHODNAME">bitBlt()</tt>
          могла бы быть вызвана всего один раз, для отрисовки
          ограниченного прямоугольника. Однако, поскольку у нас
          <tt class="METHODNAME">update()</tt> вызывается в цикле из
          обработчика событий от мыши, для стирания и перерисовки
          границ области выделения, то мы получаем дополнительно еще
          четыре области перерисовки, в которых размещается рамка
          выделения (два вертикальных и два горизонтальных
          прямоугольника, шириной в 1 пиксель). Поэтому мы вынуждены
          вызывать <tt class="METHODNAME">bitBlt()</tt> для переноса
          каждой из подобластей.<br>
          <br>

          <p>Как только перенос картинки из буфера будет завершен, мы
          приступаем к рисованию границ области выделения. Рамка
          рисуется цветом группы "light", чтобы обеспечить
          приемлемую контрастность рамки и фона. Обратите внимание:
          рамка рисуется прямо на виджете, оставляя буфер с рисунком в
          неприкосновенности. Собственно рисование выполняется функцией
          <tt class="METHODNAME">drawPrimitive()</tt>.</p>

          <p>Функция <tt class="METHODNAME">QWidget::style()</tt>
          возвращает стиль рисования виджета. В Qt стиль рисования
          виджета -- это подкласс <tt class="CLASSNAME">QStyle</tt>. В
          список встроенных стилей входят <tt class="CLASSNAME">QWindowsStyle, QWindowsXPStyle, QMotifStyle</tt>
          и <tt class="CLASSNAME">QMacStyle.</tt>. Каждый из них
          предоставляет свою реализации виртуальных методов. Функция
          <tt class="METHODNAME">drawPrimitive()</tt> -- одна из них.
          Она рисует графические примитивы, такие как панели, кнопки и
          границы областей выделения, в соответствии с выбранным
          стилем. Как правило, для всех виджетов приложения
          устанавливается единый стиль отображения (<tt class="METHODNAME">QApplication::style()</tt>), но он может быть
          изменен для каждого из виджетов, вызовом <tt class="METHODNAME">QWidget::setStyle()</tt>.</p>

          <p>Создавая дочерние классы от <tt class="CLASSNAME">QStyle</tt>, вы можете опредлять свои собственные
          стили отображения. Делается это обычно для того, чтобы
          подчеркнуть индивидуальность приложения (или группы
          приложений). Тем не менее, считается хорошим тоном соблюдать
          единый стиль отображения, выбранный пользователем при
          настройке рабочего окружения.</p>

          <p>Стандартные виджеты Qt, практически всегда отрисовывают
          себя, основываясь на <tt class="CLASSNAME">QStyle</tt>.
          Именно по этой причине они похожи на "родные"
          графические элементы самой операционной системы. Свои виджеты
          вы можете отрисовывать либо используя <tt class="CLASSNAME">QStyle</tt>, либо собирая их из стандартных
          виджетов Qt. В случае с <tt class="CLASSNAME">Plotter</tt> мы
          использовали оба подхода: прямоугольная рамка выделения
          рисуется с помощью <tt class="CLASSNAME">QStyle</tt>, а
          кнопки <strong class="COMMAND">Zoom In</strong> и
          <strong class="COMMAND">Zoom Out</strong> -- это стандартные
          виджеты.</p>
          <pre class="SCREEN">void Plotter::resizeEvent(QResizeEvent *) 
{ 
  int x = width() - (zoomInButton-&gt;width() 
          + zoomOutButton-&gt;width() + 10); 
  zoomInButton-&gt;move(x, 5); 
  zoomOutButton-&gt;move(x + zoomInButton-&gt;width() + 5, 5); 
  refreshPixmap(); 
}
      
</pre>Когда необходимо изменить размеры <tt class="CLASSNAME">
          Plotter</tt>, Qt генерирует событие "resize". Здесь
          мы реализуем обработку этого события. Кнопки <strong class="COMMAND">Zoom In</strong> и <strong class="COMMAND">Zoom
          Out</strong> размещаются в правом верхнем углу виджета, с
          небольшим (5 пикселей) промежутком между ними.<br>
          <br>

          <p>Если бы кнопки размещались в левом верхнем углу виджета,
          то мы могли бы просто установить их на место в конструкторе
          <tt class="CLASSNAME">Plotter</tt>. Но мы выбрали правый
          верхний угол, поэтому необходимо постоянно следить за
          размерами виджета и перемещать кнопки в нужное место всякий
          раз, когда изменяются его размеры.</p>

          <p>Нам не нужно изначально устанавливать кнопки в
          конструкторе, поскольку перед тем как виджет впервые появится
          на экране, Qt сгенерирует событие "resize".</p>

          <p>В качестве альтернативы, можно было бы вставить в наш
          виджет менеджер размещения (например <tt class="CLASSNAME">QGridLayout</tt>), который управлял бы
          расположением кнопок. Однако, это усложнило бы реализацию
          виджета и он стал бы более ресурсоемким. Когда виджет
          создается "с нуля", как в данном лучае, то
          правильнее будет отказаться от услуг менеджеров размещения и
          устанавливать все подчиненные компоненты вручную.</p>

          <p>В конце обработчика, для перерисовки графика с новыми
          размерами, вызывается <tt class="METHODNAME">refreshPixmap()</tt>.</p>
          <pre class="SCREEN">void Plotter::mousePressEvent(QMouseEvent *event) 
{ 
  if (event-&gt;button() == LeftButton) { 
    rubberBandIsShown = true; 
    rubberBandRect.setTopLeft(event-&gt;pos()); 
    rubberBandRect.setBottomRight(event-&gt;pos()); 
    updateRubberBandRegion(); 
    setCursor(crossCursor); 
  } 
}
      
</pre>Когда пользователь нажимает левую кнопку мыши, мы начинаем
показывать рамку выделяемой области. Для этого, в переменную
          <tt class="VARNAME">rubberBandIsShown</tt>, записывается
          значение <tt class="PARAMETER"><em>true</em></tt>, переменная
          <tt class="VARNAME">rubberBandRect</tt> инициализируется
          текущими координатами указателя мыши, затем планируются
          события "paint", для отрисовки рамки, и наконец
          изменяется вид указателя мыши -- теперь он представляется в
          виде крестика.<br>
          <br>

          <p>Qt предоставляет два основных механизма управления внешним
          видом указателя мыши:</p>

          <ul>
            <li>
              <p><tt class="METHODNAME">QWidget::setCursor()</tt> --
              устанавливает внешний вид курсора для конкретного
              виджета. По-умолчанию используется внешний вид курсора,
              установленный для владельца виджета или в виде стрелки
              (если в иерархии владельцев ни у кого не задан вид
              курсора мыши).</p>
            </li>

            <li>
              <p><tt class="METHODNAME">QApplication::setOverrideCursor()</tt> --
              устанавливает вид курсора для всего приложения в целом.
              Она отменяет действие <tt class="METHODNAME">QWidget::setCursor()</tt> всех виджетов,
              пока не будет вызвана <tt class="METHODNAME">restoreOverrideCursor()</tt>.</p>
            </li>
          </ul>В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER4">Главе 4</a> мы уже пользовались
          функцией <tt class="METHODNAME">QApplication::setOverrideCursor()</tt>, с
          аргументом <tt class="PARAMETER"><em>waitCursor</em></tt>,
          чтобы показать занятость приложения.
          <pre class="SCREEN">void Plotter::mouseMoveEvent(QMouseEvent *event) 
{ 
  if (event-&gt;state() &amp; LeftButton) { 
    updateRubberBandRegion(); 
    rubberBandRect.setBottomRight(event-&gt;pos()); 
    updateRubberBandRegion(); 
  } 
}
      
</pre>Когда пользователь перемещает указатель мыши, удерживая при этом
левую кнопку в нажатом состоянии, вызывается <tt class="METHODNAME">
          updateRubberBandRegion()</tt>. Она ставит в очередь
          планировщика событие "paint", чтобы перерисовать
          области, где находилась рамка области выделения, затем
          записывает новые координаты в <tt class="VARNAME">rubberBandRect</tt> и вторично выполняет
          перерисовку рамки выделения. В результате прежняя рамка
          стирается и рисуется новая, в соответствии с изменившимися
          координатами указателя мыши.<br>
          <br>

          <p>Переменная <tt class="VARNAME">rubberBandRect</tt> имеет
          тип <tt class="CLASSNAME">QRect</tt>. Экземпляры этого класса
          могут поставлять значения в виде (<tt class="VARNAME">x, y,
          w, h</tt>), где <tt class="VARNAME">(x, y)</tt> --это
          координаты левого верхнего угла, а <tt class="VARNAME">w,
          h</tt> -- ширина и высота прямоугольника либо в виде пар
          координат верхнего левого и правого нижнего углов. В нашем
          случае мы используем представление в виде пар координат. В
          качестве координат верхнего левого угла устанавливаются
          координаты указателя мыши в момент нажатия на кнопку, а
          текущее положение курсора мыши принимается за правый нижний
          угол рамки выделения.</p>

          <p>Если пользователь переместит указатель влево или вверх, то
          может получиться ситуация, когда то, что мы считаем правым
          нижним углом, окажется левее и/или выше левого верхнего угла.
          В этом случае <tt class="CLASSNAME">QRect</tt> будет
          представлять высоту и ширину прямоугольника отрицательными
          числами. Чтобы избежать сложностей с отрицательными числами,
          в <tt class="CLASSNAME">QRect</tt> предусмотрена функция
          <tt class="METHODNAME">normalize()</tt>, которая возвращает
          нормализованные координаты прямоугольника.</p>
          <pre class="SCREEN">void Plotter::mouseReleaseEvent(QMouseEvent *event) 
{ 
  if (event-&gt;button() == LeftButton) { 
    rubberBandIsShown = false; 
    updateRubberBandRegion(); 
    unsetCursor(); 
    
    QRect rect = rubberBandRect.normalize(); 
    if (rect.width() &lt; 4 || rect.height() &lt; 4) 
      return; 
    rect.moveBy(-Margin, -Margin); 
    
    PlotSettings prevSettings = zoomStack[curZoom]; 
    PlotSettings settings; 
    double dx = prevSettings.spanX() / (width() - 2 * Margin); 
    double dy = prevSettings.spanY() / (height() - 2 * Margin); 
    settings.minX = prevSettings.minX + dx * rect.left(); 
    settings.maxX = prevSettings.minX + dx * rect.right(); 
    settings.minY = prevSettings.maxY - dy * rect.bottom(); 
    settings.maxY = prevSettings.maxY - dy * rect.top(); 
    settings.adjust(); 
    
    zoomStack.resize(curZoom + 1); 
    zoomStack.push_back(settings); 
    zoomIn(); 
  } 
}
      
</pre>Когда левая кнопка мыши отпускается, производится стирание рамки
области выделения и восстанавливается прежний вид указателя мыши. Если
размер выделенной области не менее, чем 4 X 4, выполняется изменение
масштаба отображения графика. Если меньше -- скорее всего пользователь
щелкнул по виджету по ошибке или хотел передать ему фокус. В этом
случае ничего не делается.<br>
          <br>

          <p>Процесс изменения масштаба осложнен тем обстоятельством,
          что нам приходится работать одновременно с двумя системами
          координат -- системой координат виджета и системой координат
          самого графика. Большая часть работы заключается в переходе
          от одной системы координат к другой.</p>

          <p>После выполнения преобразований, вызывается <tt class="METHODNAME">PlotSettings::adjust()</tt>, которая округляет
          размеры и находит наиболее разумные значения для рисок,
          наносимых на оси графика.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.13.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.13. Преобразование координат рамки выделения
              из системы координат виджета, в систему координат
              графика.</p>
            </div>
          </div><br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig5.14.png"></p>

            <div class="CAPTION">
              <p>Рисунок 5.14. Округление и переход к новому масштабу
              отображения.</p>
            </div>
          </div><br>
          Затем выполняется масштабирование. Сначала на стек
          добавляется новый экземпляр <tt class="CLASSNAME">PlotSettings</tt>, а затем вызывается <tt class="METHODNAME">zoomIn()</tt>.
          <pre class="SCREEN">void Plotter::keyPressEvent(QKeyEvent *event) 
{ 
  switch (event-&gt;key()) { 
    case Key_Plus: 
        zoomIn(); 
        break; 
    case Key_Minus: 
        zoomOut(); 
        break; 
    case Key_Left: 
        zoomStack[curZoom].scroll(-1, 0); 
        refreshPixmap();      
        break; 
    case Key_Right: 
        zoomStack[curZoom].scroll(+1, 0); 
        refreshPixmap(); 
        break; 
    case Key_Down: 
        zoomStack[curZoom].scroll(0, -1); 
        refreshPixmap(); 
        break; 
    case Key_Up: 
        zoomStack[curZoom].scroll(0, +1); 
        refreshPixmap(); 
        break; 
    default: 
        QWidget::keyPressEvent(event); 
  } 
}
      
</pre>Когда виджет <tt class="CLASSNAME">Plotter</tt> владеет фокусом
ввода, нажатие клавиш на клавиатуре приводит к вызову функции
          <tt class="METHODNAME">keyPressEvent()</tt>. Наша реализация
          обработчика обслуживает шесть клавиш: "+",
          "-" и клавиши управления курсором
          ("вверх", "вниз", "влево" и
          "вправо"). Если нажата клавиша, которую мы не
          обрабатываем, вызывается обработчик класса-предка. Для
          простоты мы игнорируем состояние клавиш-модификаторв: Ctrl,
          Shift и Alt. Состояние этих клавиш может быть получено через
          <tt class="METHODNAME">QKeyEvent::state()</tt>.
          <pre class="SCREEN">void Plotter::wheelEvent(QWheelEvent *event) 
{ 
  int numDegrees = event-&gt;delta() / 8; 
  int numTicks = numDegrees / 15; 
  
  if (event-&gt;orientation() == Horizontal) 
    zoomStack[curZoom].scroll(numTicks, 0); 
  else 
    zoomStack[curZoom].scroll(0, numTicks); 
  
  refreshPixmap(); 
}
      
</pre>Событие "wheel" возникает, когда выполняется вращение
колесика мыши. Чаще всего встречаются мыши, имеющие только одно
колесико -- колесико вертикальной прокрутки, но есть и такие, которые
имеют дополнительное колесико горизонтальной прокрутки. Qt поддерживает
оба типа колесиков. Событие "wheel" передается виджету, если
он владеет фокусом ввода. Функция <tt class="METHODNAME">delta()</tt>
возвращает угол поворота колесика в восьмых долях градуса. В
большинстве случаев, один "шаг" колесика мыши равен 15
градусам.<br>
          <br>

          <p>На этом мы завершаем обзор обработчиков событий и
          переходим к приватным функциям:</p>
          <pre class="SCREEN">void Plotter::updateRubberBandRegion() 
{ 
  QRect rect = rubberBandRect.normalize(); 
  
  update(rect.left(), rect.top(), rect.width(), 1); 
  update(rect.left(), rect.top(), 1, rect.height()); 
  update(rect.left(), rect.bottom(), rect.width(), 1); 
  update(rect.right(), rect.top(), 1, rect.height()); 
}
      
</pre>Функция <tt class="METHODNAME">updateRubberBand()</tt> вызывается
из обработчиков событий <tt class="METHODNAME">mousePressEvent()</tt>,
<tt class="METHODNAME">mouseMoveEvent()</tt> и <tt class="METHODNAME">
          mouseReleaseEvent()</tt>, чтобы стереть и вновь нарисовать
          рамку области выделения. Она содержит четыре вызова
          <tt class="METHODNAME">update()</tt>, которые ставят в
          очередь события "paint" для четырех небольших
          прямоугольников, в которых отображаются стороны рамки.<br>
          <br>

          <div class="INFORMALTABLE">
            <a name="AEN3241"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <thead style="background:black; color:white">
                <tr>
                  <th width="100%" align="center" valign="middle">
                    <pre class="SCREEN">            
</pre>Использование логической операции NOT (НЕ), при рисовании рамки
выделенной области
                    <pre class="SCREEN">            
</pre>
                  </th>
                </tr>
              </thead>

              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="100%" align="left" valign="top">
                    <p>Один из самых распространенных способов
                    рисование рамки области выделения состоит в
                    использовании логической операции NOT (или XOR),
                    которая замещает значение цвета каждого пикселя
                    рамки на обратное. Ниже приводится альтернативная
                    версия <tt class="METHODNAME">updateRubberBandRegion()</tt>, которая
                    использует такую методику рисования:</p>
                    <pre class="SCREEN">void Plotter::updateRubberBandRegion() 
{ 
  QPainter painter(this); 
  painter.setRasterOp(NotROP); 
  painter.drawRect(rubberBandRect.normalize()); 
}
              
</pre>Вызовом <tt class="METHODNAME">setRasterOp()</tt> задается
операция наложения <tt class="PARAMETER"><em>NotROP</em></tt>. В
оригинальной версии используется значение по-умолчанию --
                    <tt class="PARAMETER"><em>CopyROP</em></tt>,
                    которая означает простое копирование нового
                    изображения поверх имеющегося.<br>
                    <br>

                    <p>Кода функция <tt class="METHODNAME">updateRubberBandRegion()</tt>
                    вызывается вторично, для тех же самых координат, то
                    восстанавливается начальное значение цвета
                    пикселей, поскольку вторая логическая операция NOT
                    отменяет действие первой.</p>

                    <p>Преимущество такого подхода заключается в
                    отсутствии необходимости сохранять копию
                    закрашиваемой области. Но область его применения
                    крайне ограничена. Например, если вместо рамки
                    попробовать нарисовать таким образом текст, то он
                    будет очень трудно читаться. К тому же он не всегда
                    гарантирует высокую контрастность, например, серый
                    цвет средней интенсивности таковым и останется. И в
                    довершение всех бед -- на платформе Mac OS X эта
                    возможность не поддерживается вообще.</p>

                    <p>Еще один из подходов к рисованию рамок --
                    создание анимированных пунктирных линий. Он часто
                    используется в программах, занимающихся обработкой
                    изображений, поскольку дает хороший контраст не
                    зависимо от начального цвета пикселей, по которым
                    проходит рамка. Для того, чтобы создать
                    анимированную рамку в Qt, вам придется перекрыть
                    обработчик события <tt class="METHODNAME">QObject::timerEvent()</tt>, в котором
                    надо будет стирать рамку и опять рисовать ее, при
                    этом всякий раз начинать рисование точек пунктира с
                    новой позиции, что создаст иллюзию движения точек
                    по линии.</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
          <pre class="SCREEN">void Plotter::refreshPixmap() 
{ 
  pixmap.resize(size()); 
  pixmap.fill(this, 0, 0); 
  QPainter painter(&amp;pixmap, this); 
  
  drawGrid(&amp;painter); 
  drawCurves(&amp;painter); 
  update(); 
}
      
</pre>Функция <tt class="METHODNAME">refreshPixmap()</tt>
перерисовывает кривые графиков нв буфере и затем обновляет изображение
на экране. Сначала устанавливается размер буфера, чтобы он
соответствовал размерам виджета. Затем он заполняется цветом фона,
который был установлен в конструкторе, вызовом <tt class="METHODNAME">
          setBackgroundMode()</tt>.<br>
          <br>

          <p>Далее создается <tt class="CLASSNAME">QPainter</tt> и с
          его помощью в буфере рисуются координатная сетка и кривые. В
          заключение вызывается <tt class="METHODNAME">update()</tt>,
          которая планирует событие "paint" для всего виджета
          в целом. Буфер будет скопирован в виджет -- в обработчике
          события <tt class="METHODNAME">paintEvent()</tt>.</p>
          <pre class="SCREEN">void Plotter::drawGrid(QPainter *painter) 
{ 
  QRect rect(Margin, Margin, 
             width() - 2 * Margin, height() - 2 * Margin); 
  PlotSettings settings = zoomStack[curZoom]; 
  QPen quiteDark = colorGroup().dark().light(); 
  QPen light = colorGroup().light(); 
  
  for (int i = 0; i &lt;= settings.numXTicks; ++i) { 
    int x = rect.left() + (i * (rect.width() - 1) 
                             / settings.numXTicks); 
    double label = settings.minX + (i * settings.spanX() 
                                      / settings.numXTicks); 
    painter-&gt;setPen(quiteDark); 
    painter-&gt;drawLine(x, rect.top(), x, rect.bottom()); 
    painter-&gt;setPen(light); 
    painter-&gt;drawLine(x, rect.bottom(), x, rect.bottom() + 5); 
    painter-&gt;drawText(x - 50, rect.bottom() + 5, 100, 15, 
                      AlignHCenter | AlignTop, 
                      QString::number(label)); 
  } 
  
  for (int j = 0; j &lt;= settings.numYTicks; ++j) { 
    int y = rect.bottom() - (j * (rect.height() - 1) 
                               / settings.numYTicks); 
    double label = settings.minY + (j * settings.spanY() 
                                      / settings.numYTicks); 
    painter-&gt;setPen(quiteDark); 
    painter-&gt;drawLine(rect.left(), y, rect.right(), y); 
    painter-&gt;setPen(light); 
    painter-&gt;drawLine(rect.left() - 5, y, rect.left(), y); 
    painter-&gt;drawText(rect.left() - Margin, y - 10, 
                      Margin - 5, 20, 
                      AlignRight | AlignVCenter, 
                      QString::number(label)); 
  } 
  painter-&gt;drawRect(rect); 
}
      
</pre>Функция <tt class="METHODNAME">drawGrid()</tt> рисует
координатную сетку, на фоне которой будут отображаться графики. Первый
цикл <tt class="METHODNAME">for</tt> рисует вертикальные линии сетки и
риски на оси OX. Второй -- горизонтальные линии сетки и риски на оси
OY. Для рисования числовых значений, напротив рисок, и обозначений осей
-- вызывается функция <tt class="METHODNAME">drawText()</tt>.<br>

          <br>

          <p>Функция <tt class="METHODNAME">drawText()</tt> имеет
          следующий синтаксис:</p>
          <pre class="SCREEN">painter.drawText(x, y, w, h, alignment, text);      
      
</pre>где <tt class="PARAMETER"><em>(x, y, w, h)</em></tt> задают
область рисования, <tt class="PARAMETER"><em>alignment</em></tt> --
выравнивание текста внутри этой области, <tt class="PARAMETER">
          <em>text</em></tt> -- собственно текст.
          <pre class="SCREEN">void Plotter::drawCurves(QPainter *painter) 
{ 
  static const QColor colorForIds[6] = { 
    red, green, blue, cyan, magenta, yellow 
  }; 
  PlotSettings settings = zoomStack[curZoom]; 
  QRect rect(Margin, Margin, 
             width() - 2 * Margin, height() - 2 * Margin); 
  painter-&gt;setClipRect(rect.x() + 1, rect.y() + 1, 
                       rect.width() - 2, rect.height() - 2); 
  map&lt;int, CurveData&gt;::const_iterator it = curveMap.begin(); 
  while (it != curveMap.end()) { 
    int id = (*it).first; 
    const CurveData &amp;data = (*it).second; 
    int numPoints = 0; 
    int maxPoints = data.size() / 2; 
    QPointArray points(maxPoints); 
    
    for (int i = 0; i &lt; maxPoints; ++i) { 
      double dx = data[2 * i] - settings.minX; 
      double dy = data[2 * i + 1] - settings.minY; 
      double x = rect.left() + (dx * (rect.width() - 1) 
                                   / settings.spanX()); 
      double y = rect.bottom() - (dy * (rect.height() - 1) 
                                     / settings.spanY()); 
      if (fabs(x) &lt; 32768 &amp;&amp; fabs(y) &lt; 32768) { 
        points[numPoints] = QPoint((int)x, (int)y); 
        ++numPoints; 
      } 
    } 
    points.truncate(numPoints); 
    painter-&gt;setPen(colorForIds[(uint)id % 6]); 
    painter-&gt;drawPolyline(points); 
    ++it; 
  } 
}      
      
</pre>Функция <tt class="METHODNAME">drawCurves()</tt> рисует кривые
графиков поверх координатной сетки. Начинается она с ограничения
области рисования, вызовом <tt class="METHODNAME">setClipRect()</tt>.
<tt class="CLASSNAME">QPainter</tt> будет игнорировать попытки
рисования за ее пределами.<br>
          <br>

          <p>Затем выполняется проход по всем кривым графика и для
          каждой из них -- по парам координат <tt class="PARAMETER"><em>(x, y)</em></tt>. Элемент итератора
          <tt class="PARAMETER"><em>first</em></tt> дает нам ID
          (идентификатор) кривой, а <tt class="PARAMETER"><em>second</em></tt> -- массив координат точек
          кривой.</p>

          <p>Вложенный цикл <tt class="PARAMETER"><em>for</em></tt>
          выполняет преобразование из системы координат графика в
          систему координат виджета и сохраняет результат в массив
          <tt class="VARNAME">points</tt>, при условии, что они
          находятся в разумных пределах.</p>

          <p>По окончании выполнения преобразований координат для всех
          точек кривой, устанавливается цвет "чернил"
          (используя один из предопределенных цветов) и вызывается
          <tt class="METHODNAME">drawPolyline()</tt>, которая рисует
          ломаную линию, проходящую через заданные точки.</p>

          <p>На этом завершается реализация класса <tt class="CLASSNAME">Plotter</tt>. И нам остается рассмотреть еще ряд
          функций-членов класса <tt class="CLASSNAME">PlotSettings</tt>.</p>
          <pre class="SCREEN">PlotSettings::PlotSettings() 
{ 
  minX = 0.0; 
  maxX = 10.0; 
  numXTicks = 5; 
  minY = 0.0; 
  maxY = 10.0; 
  numYTicks = 5; 
}
      
</pre>Конструктор инициализирует оси координат, с диапазоном измерения
от 0 до 10 по каждой из них, и задает количество рисок на каждой из
осей, равное 5.
          <pre class="SCREEN">void PlotSettings::scroll(int dx, int dy) 
{ 
  double stepX = spanX() / numXTicks; 
  minX += dx * stepX; 
  maxX += dx * stepX; 
  double stepY = spanY() / numYTicks; 
  minY += dy * stepY; 
  maxY += dy * stepY; 
}
      
</pre>Функция <tt class="METHODNAME">scroll()</tt> увеличивает (или
уменьшает) значения переменных <tt class="VARNAME">minX, maxX,
minY</tt> и <tt class="VARNAME">maxY</tt>. Она реализует поддержку
скроллинга и вызывается из <tt class="METHODNAME">Plotter::keyPressEvent()</tt>.
          <pre class="SCREEN">void PlotSettings::adjust() 
{ 
  adjustAxis(minX, maxX, numXTicks); 
  adjustAxis(minY, maxY, numYTicks); 
}
      
</pre>Функция <tt class="METHODNAME">adjust()</tt> вызывается из
<tt class="METHODNAME">mouseReleaseEvent()</tt>. Она округляет значения
переменных <tt class="VARNAME">minX, maxX, minY</tt> и
          <tt class="VARNAME">maxY</tt> до "наилучших" и
          определяет значения рисок по каждой из осей. Обработка
          конкретной оси координат выполняется функцией <tt class="METHODNAME">adjustAxis()</tt>.
          <pre class="SCREEN">void PlotSettings::adjustAxis(double &amp;min, double &amp;max, int &amp;numTicks) 
{ 
  const int MinTicks = 4; 
  double grossStep = (max - min) / MinTicks; 
  double step = pow(10, floor(log10(grossStep))); 
  
  if (5 * step &lt; grossStep) 
    step *= 5; 
  else if (2 * step &lt; grossStep) 
    step *= 2; 
  
  numTicks = (int)(ceil(max / step) - floor(min / step)); 
  min = floor(min / step) * step; 
  max = ceil(max / step) * step; 
}
      
</pre>Она округляет аргументы <tt class="PARAMETER"><em>min</em></tt> и
<tt class="PARAMETER"><em>max</em></tt> до "наилучших"
значений и определяет число рисок (<tt class="PARAMETER"><em>numTicks</em></tt>) на оси, исходя из диапазона
[<tt class="PARAMETER"><em>min</em></tt>..<tt class="PARAMETER">
          <em>max</em></tt>]. Функция должна изменять фактические
          параметры (<tt class="PARAMETER"><em>minX</em></tt>,
          <tt class="PARAMETER"><em>maxX</em></tt>, <tt class="PARAMETER"><em>numXTicks</em></tt>, и т.д.), поэтому они
          передаются по ссылке, а не по значению.<br>
          <br>

          <p>Большая часть кода функции служит для определения наиболее
          подходящего "расстояния" между соседними рисками
          ("шаг"). К выбору шага нужно подходить очень
          осторожно. Дробные значения шага, например 3.8, сложнее
          воспринимаются людьми, чем круглые. Для осей, которые имеют
          метки, записываемые в десятичной нотации,
          "наилучшими" значениями будут числа 10^n, 2*10^n
          или 5*10^n.</p>

          <p>Поиск начинается с "большого шага", своего рода
          максимального значения для шага. Затем находится число,
          ближайшее (меньше или равно) к значению "большого
          шага", которое можно записать в форме 10^n: берется
          десятичный логарифм от "большого шага", округляется
          вниз до ближайшего целого и затем вычисляется степень 10-ти,
          с найденым числом в качестве показателя. Например, пусть
          "большой шаг" равен числу 236, в результате
          получаем: log 236 = 2.37291; округление дает число 2, а 10^2
          = 100 -- кандидат для размера "наилучшего"
          шага.</p>

          <p>Как только мы получили значение первого
          "кандидата" для шага оси, необходимо рассчитать еще
          два значения -- 2*10^n и 5*10^n. Для примера выше, два других
          кандидата -- это числа 200 и 500. Но число 500 значительно
          больше установленного нами максимума (236), а 200 -- меньше,
          поэтому в качестве шага оси принимается число 200.</p>

          <p>Теперь, основываясь на значении шага, очень легко
          вычислить <tt class="PARAMETER"><em>min</em></tt>, <tt class="PARAMETER"><em>max</em></tt> и <tt class="PARAMETER"><em>numTicks</em></tt>. Значение <tt class="PARAMETER"><em>min</em></tt> получается за счет округления
          вниз начального <tt class="PARAMETER"><em>min</em></tt>, до
          ближайшего множителя шага, а значение <tt class="PARAMETER"><em>max</em></tt> -- за счет округления вверх, до
          ближайшего множителя шага. Величина <tt class="PARAMETER"><em>numTicks</em></tt> -- это количество шагов,
          укладывающихся в интервал, между <tt class="PARAMETER"><em>min</em></tt> и <tt class="PARAMETER"><em>max</em></tt>. Например, если начальные
          значения <tt class="PARAMETER"><em>min</em></tt> = 240,
          <tt class="PARAMETER"><em>max</em></tt> = 1184, то новый
          диапазон значений оси будет составлять [200..1200], с 5
          интервалами-шагами.</p>

          <p>Этот алгоритм не всегда дает оптимальные значения. Более
          изощренный алгоритм вы найдете в статье Пауля Хекберта (Paul
          S. Heckbert) -- <span class="emphasis"><em class="EMPHASIS">"Nice Numbers for Graph
          Labels"</em></span>, опубликованной в <span class="emphasis"><em class="EMPHASIS">Graphics Gems</em></span>
          (ISBN 0-12-286166-3). Кроме того, в ежеквартальнике
          <span class="emphasis"><em class="EMPHASIS">Qt
          Quarterly</em></span> имеется статья <span class="emphasis"><em class="EMPHASIS">"Fast and
          Flicker-Free"</em></span> ( <a href="http://doc.trolltech.com/qq/qq06-flicker-free.html" target="_top">http://doc.trolltech.com/qq/qq06-flicker-free.html</a>),
             которая рассматривает некоторые идеи по устранению эффекта
             мерцания.</p>

          <p>Эта глава завершает первую часть книги. Здесь мы
          рассказали как настроить стандартные виджеты Qt и как создать
          свой виджет, используя в качестве базового класса <tt class="CLASSNAME">QWidget</tt>. В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER2">Главе 2</a>
          мы видели, как можно "собрать" виджет из других
          виджетов, эта тема будет рассматриваться глубже в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER6">Главе 6</a>.</p>

          <p>К настоящему моменту, вы получили достаточно знаний, чтобы
          написать законченное приложение с графическим интерфейсом
          пользователя. Во второй части книги, мы перейдем к более
          глубокому изучению Qt, что позволит нам использовать всю мощь
          этой замечательной библиотеки.</p>
        </div>
      </div>
    </div>

    <div class="PART">
      <a name="AEN3344"></a>

      <div class="TITLEPAGE">
        <h1 class="TITLE">Часть II. Углубленные сведения</h1>

        <div class="TOC">
          <dl>
            <dt><strong>Содержание</strong></dt>

            <dt>6. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER6">Управление размещением
            виджетов.</a></dt>

            <dd>
              <dl>
                <dt>6.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#BASICLAYOUTS">Основы компоновки
                виджетов.</a></dt>

                <dt>6.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SPLITTERS">Разделители.</a></dt>

                <dt>6.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#WIDGETSTACKS">Многостраничные
                виджеты.</a></dt>

                <dt>6.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SCROLLVIEWS">Области просмотра с
                прокруткой.</a></dt>

                <dt>6.5. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#DOCKWINDOWS">Стыкуемые
                окна.</a></dt>

                <dt>6.6. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#MULTIPLEDOCUMENTINTERFACE">Многодокументный
                интерфейс.</a></dt>
              </dl>
            </dd>

            <dt>7. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER7">Обработка событий.</a></dt>

            <dd>
              <dl>
                <dt>7.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#REIMPLEMENTINGEVENTHANDLERS">Обработчики
                событий.</a></dt>

                <dt>7.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#INSTALLINGEVENTFILTERS">Установка
                фильтров событий.</a></dt>

                <dt>7.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#STAYINGRESPONSIVEDURINGINTENSIVEPROCESSING">Сокращение
                времени отклика при длительной обработке
                данных.</a></dt>
              </dl>
            </dd>

            <dt>8. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER8">Двух- и трехмерная
            графика.</a></dt>

            <dd>
              <dl>
                <dt>8.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#PAINTINGWITHQPAINTER">Рисование
                средствами QPainter.</a></dt>

                <dt>8.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#GRAPHICSWITHQCANVAS">Рисование
                средствами QCanvas.</a></dt>

                <dt>8.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#PRINTING">Вывод на печать.</a></dt>

                <dt>8.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#GRAPHICSWITHOPENGL">Графика
                OpenGL.</a></dt>
              </dl>
            </dd>

            <dt>9. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER9">Drag and Drop.</a></dt>

            <dd>
              <dl>
                <dt>9.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#ENABLINGDRAGANDDROP">Реализация
                механизма 'drag and drop' в
                приложениях.</a></dt>

                <dt>9.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SUPPORTINGCUSTOMDRAGTYPES">Поддержка
                нестандартных типов данных при перетаскивании.</a></dt>

                <dt>9.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#ADVANCEDCLIPBOARDHANDLING">Расширенные возможности
                буфера обмена.</a></dt>
              </dl>
            </dd>

            <dt>10. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER10">Ввод/вывод.</a></dt>

            <dd>
              <dl>
                <dt>10.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#READINGANDWRITINGBINARYDATA">Чтение
                и запись двоичных данных.</a></dt>

                <dt>10.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#READINGANDWRITINGTEXT">Чтение и
                запись текста.</a></dt>

                <dt>10.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#HANDLINGFILESANDDIRECTORIES">Работа
                с файлами и каталогами.</a></dt>

                <dt>10.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#INTERPROCESSCOMMUNICATION">Взаимодействия между
                процессами.</a></dt>
              </dl>
            </dd>

            <dt>11. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER11">Контейнерные классы.</a></dt>

            <dd>
              <dl>
                <dt>11.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#VECTORS">Векторы.</a></dt>

                <dt>11.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#LISTS">Списки.</a></dt>

                <dt>11.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#MAPS">Словари (map).</a></dt>

                <dt>11.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#POINTERBASEDCONTAINERS">Контейнеры
                указателей.</a></dt>

                <dt>11.5. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#QSTRINGANDQVARIANT">Классы QString
                и QVariant.</a></dt>
              </dl>
            </dd>

            <dt>12. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER12">Базы данных.</a></dt>

            <dd>
              <dl>
                <dt>12.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CONNECTINGANDQUERYING">Установление
                соединения и выполнение запроса.</a></dt>

                <dt>12.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#PRESENTINGDATAINTABULARFORM">Представление данных в
                табличной форме.</a></dt>

                <dt>12.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CREATINGDATAAWAREFORMS">Разработка
                форм, ориентированных на работу с базами
                данных.</a></dt>
              </dl>
            </dd>

            <dt>13. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER13">Работа с сетью.</a></dt>

            <dd>
              <dl>
                <dt>13.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGQFTP">Класс QFtp.</a></dt>

                <dt>13.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGQHTTP">Класс QHttp.</a></dt>

                <dt>13.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#TCPNETWORKINGWITHQSOCKET">Класс
                QSocket.</a></dt>

                <dt>13.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#UDPNETWORKINGWITHQSOCKETDEVICE">Протокол UDP и класс
                QSocketDevice.</a></dt>
              </dl>
            </dd>

            <dt>14. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER14">XML</a></dt>

            <dd>
              <dl>
                <dt>14.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#READINGXMLWITHSAX">Чтение
                XML-документов с помощью SAX.</a></dt>

                <dt>14.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#READINGXMLWITHDOM">Чтение
                XML-документов с помощью DOM.</a></dt>

                <dt>14.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#WRITINGXML">Запись в
                XML-документы.</a></dt>
              </dl>
            </dd>

            <dt>15. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER15">Интернационализация</a></dt>

            <dd>
              <dl>
                <dt>15.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#WORKINGWITHUNICODE">Unicode.</a></dt>

                <dt>15.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#MAKINGAPPLICATIONSTRANSLATIONAWARE">Разработка
                приложений, подготовленных к переводу.</a></dt>

                <dt>15.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#DYNAMICLANGUAGESWITCHING">Динамическое переключение
                языков.</a></dt>

                <dt>15.4. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#TRANSLATINGAPPLICATIONS">Перевод
                существующих приложений.</a></dt>
              </dl>
            </dd>

            <dt>16. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER16">Разработка справочной системы
            приложения.</a></dt>

            <dd>
              <dl>
                <dt>16.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#TOOLTIPSSTATUSTIPSANDWHATSTHISHELP">Всплывающие
                подсказки и справка "What's
                This?".</a></dt>

                <dt>16.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGQTEXTBROWSERASASIMPLEHELPENGINE">Использование
                QTextBrowser для отображения текста справки.</a></dt>

                <dt>16.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGQTASSISTANTFORPOWERFULONLINEHELP">Использование
                Qt Assistant для отображения текста справки.</a></dt>
              </dl>
            </dd>

            <dt>17. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER17">Многопоточность.</a></dt>

            <dd>
              <dl>
                <dt>17.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#WORKINGWITHTHREADS">Потоки.</a></dt>

                <dt>17.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#COMMUNICATINGWITHTHEGUITHREAD">Взаимодействие с
                главным потоком приложения.</a></dt>

                <dt>17.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGQTSCLASSESINNONGUITHREADS">Работа с классами Qt
                вне главного потока.</a></dt>
              </dl>
            </dd>

            <dt>18. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER18">Платформо-зависимые
            особенности.</a></dt>

            <dd>
              <dl>
                <dt>18.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#INTERFACINGWITHNATIVEAPIS">Взаимодействие с API
                операционной системы.</a></dt>

                <dt>18.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#USINGACTIVEX">ActiveX.</a></dt>

                <dt>18.3. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#SESSIONMANAGEMENT">Управление
                сеансами.</a></dt>
              </dl>
            </dd>

            <dt>19. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#ABOUTTHEAUTHORS">Об авторах.</a></dt>

            <dd>
              <dl>
                <dt>19.1. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN8505">Jasmin Blanchette</a></dt>

                <dt>19.2. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN8510">Mark Summerfield</a></dt>
              </dl>
            </dd>
          </dl>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER6"></a>Глава 6. Управление размещением
        виджетов.</h1>

        <p>Каждый из виджетов, помещаемый на форму, должен быть
        размещен в нужном месте и с соответствующими размерами.
        Виджеты, размеры которых превышают размер формы, могут
        снабжаться полосами прокрутки, чтобы пользователь мог
        просмотреть все его содержимое. В этой главе мы рассмотрим
        различные способы размещения виджетов на форме и покажем, как
        реализовать отстыковываемые (dockable) окна и многодокументный
        интерфейс (MDI).</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="BASICLAYOUTS"></a>6.1. Основы
          компоновки виджетов.</h1>

          <p>Qt предоставляет три основных способа управления
          размещением подчиненных виджетов на форме: абсолютное
          позиционирование, ручное управление размещением и менеджеры
          компоновки. Мы рассмотрим каждый из них, на примере диалога
          "Find File", показанный на рисунке 6.1.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.1. Диалог "Find File".</p>
            </div>
          </div><br>
          Абсолютное позиционирование -- это самый
          "неблагодарный" способ размещения виджетов. При
          таком подходе положение и размеры виджетов жестко зашиваются
          в программу, что, как правило, влечет за собой фиксированные
          размеры самой формы. Взглянем на конструктор диалога
          <tt class="CLASSNAME">FindFileDialog</tt>, который строится
          по принципу абсолютного позиционирования:
          <pre class="SCREEN">FindFileDialog::FindFileDialog(QWidget *parent, const char *name) 
    : QDialog(parent, name) 
{ 
  ... 
  namedLabel-&gt;setGeometry(10, 10, 50, 20); 
  namedLineEdit-&gt;setGeometry(70, 10, 200, 20); 
  lookInLabel-&gt;setGeometry(10, 35, 50, 20); 
  lookInLineEdit-&gt;setGeometry(70, 35, 200, 20); 
  subfoldersCheckBox-&gt;setGeometry(10, 60, 260, 20); 
  listView-&gt;setGeometry(10, 85, 260, 100); 
  messageLabel-&gt;setGeometry(10, 190, 260, 20); 
  findButton-&gt;setGeometry(275, 10, 80, 25); 
  stopButton-&gt;setGeometry(275, 40, 80, 25); 
  closeButton-&gt;setGeometry(275, 70, 80, 25); 
  helpButton-&gt;setGeometry(275, 185, 80, 25); 
  setFixedSize(365, 220); 
}
      
</pre>Абсолютное позиционирование имеет массу недостатков. Самый
главный недостаток -- невозможность изменить размеры окна. Другой
недостаток: текст меток может не умещаться в заданные размеры, если
пользователь выбрал большой размер шрифта или, если интерфейс
приложения был переведен на другой язык. Кроме того, этот подход
требует от нас выполнения кропотливой работы по вычислению положения и
размеров виджетов.<br>
          <br>

          <p>При ручном управлении размещением виджетов, мы по прежнему
          должны задавать положение компонентов на форме, но их размеры
          устанавливаются пропорционально размерам окна. Добиться этого
          можно за счет перекрытия обработчика события <tt class="METHODNAME">resizeEvent()</tt> формы, в котором можно
          пересчитывать и задавать новые размеры подчиненных
          виджетов:</p>
          <pre class="SCREEN">FindFileDialog::FindFileDialog(QWidget *parent, const char *name) 
    : QDialog(parent, name) 
{ 
  ... 
  setMinimumSize(215, 170); 
  resize(365, 220); 
} 

void FindFileDialog::resizeEvent(QResizeEvent *) 
{ 
  int extraWidth = width() - minimumWidth(); 
  int extraHeight = height() - minimumHeight(); 
  
  namedLabel-&gt;setGeometry(10, 10, 50, 20); 
  namedLineEdit-&gt;setGeometry(70, 10, 50 + extraWidth, 20); 
  lookInLabel-&gt;setGeometry(10, 35, 50, 20); 
  lookInLineEdit-&gt;setGeometry(70, 35, 50 + extraWidth, 20); 
  subfoldersCheckBox-&gt;setGeometry(10, 60, 110 + extraWidth, 20);      
  listView-&gt;setGeometry(10, 85, 
                        110 + extraWidth, 50 + extraHeight); 
  messageLabel-&gt;setGeometry(10, 140 + extraHeight, 
                            110 + extraWidth, 20); 
  findButton-&gt;setGeometry(125 + extraWidth, 10, 80, 25); 
  stopButton-&gt;setGeometry(125 + extraWidth, 40, 80, 25); 
  closeButton-&gt;setGeometry(125 + extraWidth, 70, 80, 25); 
  helpButton-&gt;setGeometry(125 + extraWidth, 135 + extraHeight, 
                          80, 25); 
}
      
</pre>В конструкторе мы установили минимальные размеры формы 215 X 170
и начальный размер 365 X 220. В обработчике <tt class="METHODNAME">
          resizeEvent()</tt> устанавливаются новые размеры виджетов при
          изменении размеров окна.<br>
          <br>

          <p>Как и в случае с абсолютным позиционированием, ручное
          управление размещением требует от программиста
          предварительного вычисления некоторых констант, которые потом
          жестко зашиваются в код программы. Написание таких программ
          очень утомительное занятие, особенно если потом потребуется
          внести изменения в дизайн формы. По прежнему сохраняется риск
          того, что какие-то надписи на форме не поместятся в
          отведенное им пространство. Избежать этого можно, если
          учитывать "идеальные" размеры виджетов, но это еще
          больше усложнит код.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.2. Диалог "Find File" с
              изменяемыми размерами.</p>
            </div>
          </div><br>
          Наилучшим решением размещения виджетов на форме считается
          использование менеджеров компоновки Qt. Они обеспечивают
          разумные размеры по-умолчанию для каждого типа виджетов и
          учитывают "идеальные" размеры каждого из них,
          которые, в свою очередь, зависят от выбранного размера
          шрифта, стиля отображения и объема содержимого. Кроме того,
          менеджеры компоновки учитываю минимальные и максимальные
          размеры, и автоматически корректируют расположение виджетов,
          в ответ на изменение шрифта, содержимого или размеров
          окна.<br>
          <br>

          <p>В Qt имеется три вида менеджеров компоновки: <tt class="CLASSNAME">QHBoxLayout</tt>, <tt class="CLASSNAME">QVBoxLayout</tt> и <tt class="CLASSNAME">QGridLayout</tt>. Это классы-потомки от
          <tt class="CLASSNAME">QLayout</tt>, который реализует
          основные методы управления размещением. Все три класса
          полностью поддерживаются <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>-ом, а так же могут
          использоваться при написании кода вручную. Оба варианта
          использования были рассмотрены в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER2">Главе
          2</a>.</p>

          <p>Ниже приводится конструктор <tt class="CLASSNAME">FindFileDialog</tt>, в котором используются
          менеджеры размещения:</p>
          <pre class="SCREEN">FindFileDialog::FindFileDialog(QWidget *parent, const char *name) 
    : QDialog(parent, name) 
{
  ...
  QGridLayout *leftLayout = new QGridLayout; 
  leftLayout-&gt;addWidget(namedLabel, 0, 0); 
  leftLayout-&gt;addWidget(namedLineEdit, 0, 1); 
  leftLayout-&gt;addWidget(lookInLabel, 1, 0); 
  leftLayout-&gt;addWidget(lookInLineEdit, 1, 1); 
  leftLayout-&gt;addMultiCellWidget(subfoldersCheckBox, 2, 2, 0, 1); 
  leftLayout-&gt;addMultiCellWidget(listView, 3, 3, 0, 1); 
  leftLayout-&gt;addMultiCellWidget(messageLabel, 4, 4, 0, 1); 
  
  QVBoxLayout *rightLayout = new QVBoxLayout; 
  rightLayout-&gt;addWidget(findButton); 
  rightLayout-&gt;addWidget(stopButton); 
  rightLayout-&gt;addWidget(closeButton); 
  rightLayout-&gt;addStretch(1); 
  rightLayout-&gt;addWidget(helpButton); 
  
  QHBoxLayout *mainLayout = new QHBoxLayout(this); 
  mainLayout-&gt;setMargin(11); 
  mainLayout-&gt;setSpacing(6); 
  mainLayout-&gt;addLayout(leftLayout); 
  mainLayout-&gt;addLayout(rightLayout); 
}
      
</pre>Размещением компонентов на форме управляют один
          <tt class="CLASSNAME">QHBoxLayout</tt>, один <tt class="CLASSNAME">QGridLayout</tt> и один <tt class="CLASSNAME">QVBoxLayout</tt>. <tt class="CLASSNAME">QGridLayout</tt> и <tt class="CLASSNAME">QVBoxLayout</tt> расположены рядом друг с
          дружкой, внутри <tt class="CLASSNAME">QHBoxLayout</tt>. Рамка
          вокруг формы имеет ширину 11 пикселей, промежутки между
          подчиненными виджетами -- 6 пикселей.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.3. Раскладка диалога "Find
              File".</p>
            </div>
          </div><br>
          <tt class="CLASSNAME">QGridLayout</tt> работает как плоская
          сетка ячеек. <tt class="CLASSNAME">QLabel</tt>, в верхнем
          левом углу области, занимает ячейку (0, 0), а соответствующий
          ей <tt class="CLASSNAME">QLineEdit</tt> -- (0, 1). <tt class="CLASSNAME">QCheckBox</tt> объединяет две колонки и занимает
          ячейки (2, 0) и (2, 1). <tt class="CLASSNAME">QListView</tt>
          и <tt class="CLASSNAME">QLabel</tt>, расположенные снизу, так
          же занимают по две ячейки. Вызов <tt class="METHODNAME">addMultiCellWidget()</tt> имеет следующий
          синтаксис:
          <pre class="SCREEN">leftLayout-&gt;addMultiCellWidget(widget, row1, row2, col1, col2);      
      
</pre>где <tt class="PARAMETER"><em>widget</em></tt> -- это подчиненный
виджет, передаваемый этому менеджеру компоновки, <tt class="PARAMETER">
          <em>row1, col1</em></tt> -- верхняя левая ячейка, которую
          занимает виджет и <tt class="PARAMETER"><em>row2,
          col2</em></tt> -- правая нижняя ячейка.<br>
          <br>

          <p>Тот же самый диалог может быть создан с помощью
          визуального построителя <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>. Пример работы с
          визуальным построителем, мы рассматривали в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER2">Главе 2</a>.</p>

          <p>Использование менеджеров размещения дает определенные
          преимущества, которые мы уже обсуждали ранее. Если в область
          компоновки добавляется виджет или удаляется из нее, менеджер
          автоматически адаптируется под изменившиеся условия. То же
          самое применимо и к случаю, когда вызываются методы
          подчиненного компонента -- <tt class="METHODNAME">hide()</tt>
          и <tt class="METHODNAME">show()</tt>. Если подчиненный виджет
          изменит "идеальный" размер, то раскладка изменится,
          с учетом изменившихся обстоятельств. Кроме того, менеджеры
          размещения автоматически установят минимальный размер формы в
          целом, основываясь на минимальных и "идеальных"
          размерах дочерних виджетов.</p>

          <p>Во всех примерах, которые мы до сих пор рассматривали, мы
          просто объединяли виджеты менеджерами размещения и добавляли
          дополнительные распорки, для утилизации свободного
          пространства. Но иногда, чтобы расположение компонентов
          полностью соответствовало нашим желаниям, этого бывает
          недостаточно. В таких ситуациях необходимо дополнительно
          настраивать политики изменения размеров и
          "идеальные" размеры виджетов.</p>

          <p>Политика изменения размеров сообщает менеджеру компоновки,
          как виджет должен растягиваться или сжиматься. Qt
          по-умолчанию дает неплохие значения политики изменения
          размеров для всех стандартных виджетов, но никакое значение
          по-умолчанию не может идеально подходить под все случаи
          жизни. Поэтому, до сих пор обычной практикой считается
          дополнительная настройка политик изменения размеров для
          одного-двух виджетов на форме. Политика изменения размеров
          назначается для каждого из двух направлений (по вертикали и
          по горизонтали). Наиболее часто используются значения
          <tt class="PARAMETER"><em>Fixed, Minimum, Maximum,
          Preferred</em></tt> и <tt class="PARAMETER"><em>Expanding</em></tt>:</p>

          <ul>
            <li>
              <p><tt class="PARAMETER"><em>Fixed</em></tt> -- виджет
              имеет фиксированные размеры, т.е. он не может ни
              растягиваться, ни сжиматься. Он всегда должен иметь
              "идеальный" ( sizeHint() ) размер.</p>
            </li>

            <li>
              <p><tt class="PARAMETER"><em>Minimum</em></tt> --
              "идеальный" размер виджета, это минимально
              возможный его размер. Виджет не может сжиматься меньше
              этого размера, но может растягиваться и занимать все
              доступное пространство, если это потребуется.</p>
            </li>

            <li>
              <p><tt class="PARAMETER"><em>Maximum</em></tt> --
              "идеальный" размер виджета, это максимально
              возможный его размер, т.е. виджет может сжиматься до
              минимально возможного размера, но не может растягиваться
              больше "идеального".</p>
            </li>

            <li>
              <p><tt class="PARAMETER"><em>Preferred</em></tt> --
              "идеальный" размер виджета, это
              предпочтительный его размер, но в случае необходимости
              виджет может как растягиваться, так и сжиматься.</p>
            </li>

            <li>
              <p><tt class="PARAMETER"><em>Expanding</em></tt> --
              виджет может и растягиваться, и сжиматься, но он
              предпочитает растягиваться.</p>
            </li>
          </ul>Рисунок 6.4 подытоживает все, что было сказано выше о
          политиках изменения размеров, на примере <tt class="CLASSNAME">QLabel</tt>, отображающей текст "Some
          Text".

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.4.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.4. Различные политики изменения
              размеров.</p>
            </div>
          </div><br>
          Когда изменяется размер формы, которая включает в себя
          компоненты с политиками <tt class="PARAMETER"><em>Preferred</em></tt> и <tt class="PARAMETER"><em>Expanding</em></tt>, то дополнительное
          пространство отдается виджету с политикой <tt class="PARAMETER"><em>Expanding</em></tt>, в то время, как виджет
          <tt class="PARAMETER"><em>Preferred</em></tt> сохраняет
          "идеальные" размеры.<br>
          <br>

          <p>Существует еще две политики изменения размеров: <tt class="PARAMETER"><em>MinimumExpanding</em></tt> и <tt class="PARAMETER"><em>Ignored</em></tt>. Первая из них
          использовалась в ранних версиях Qt, хотя и довольно редко, в
          настоящее время не играет большой роли, поскольку лучший
          результат дает назначение политики <tt class="PARAMETER"><em>Expanding</em></tt> и повторная реализация
          (перекрытие) метода <tt class="METHODNAME">minimumSizeHint()</tt>. Вторая -- во многом
          похожа на <tt class="PARAMETER"><em>Expanding</em></tt>, но
          при этом игнорирует "идеальные" размеры
          виджета.</p>

          <p>В дополнение к политикам изменения размера, горизонтальная
          и вертикальная составляющие визуального компонента,
          <tt class="CLASSNAME">QSizePolicy</tt> хранят факторы
          растяжения. Они используются для задания степени
          растяжимости. Например, предположим, что на форме находятся
          <tt class="CLASSNAME">QListView</tt>, а под ним -- <tt class="CLASSNAME">QTextEdit</tt>. Нам необходимо, чтобы при
          растягивании формы <tt class="CLASSNAME">QTextEdit</tt> рос в
          два раза быстрее, чем <tt class="CLASSNAME">QListView</tt>.
          Для этого, фактор растягивания по вертикали (<tt class="VARNAME">verticalStretch</tt>) компонента <tt class="CLASSNAME">QTextEdit</tt> устанавливаем равным 2, а
          <tt class="CLASSNAME">QListView</tt> -- 1.</p>

          <p>Еще один способ воздействовать на порядок расположения --
          изменять минимальный и максимальный размеры подчиненных
          виджетов. Менеджер компоновки будет учитывать значения этих
          параметров.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SPLITTERS"></a>6.2.
          Разделители.</h1>

          <p>Разделитель (splitter) -- это виджет, который используется
          для размещения других виджетов и их разделения вертикальной
          или горизонтальной полосой. Пользователь может изменять
          размеры виджетов, перемещая разделитель. Они зачастую
          используются вместо менеджеров размещения, чтобы дать
          пользователю возможность самому управлять размерами
          виджетов.</p>

          <p>Разделители в Qt реализованы в виде класса <tt class="CLASSNAME">QSplitter</tt>. Подчиненные виджеты автоматически
          размещаются друг за дружкой, в порядке их создания, в смежных
          областях, разделителя. Ниже приводится код, который создает
          окно, изображенное на рисунке 6.5.</p>
          <pre class="SCREEN">#include &lt;qapplication.h&gt; 
#include &lt;qsplitter.h&gt; 
#include &lt;qtextedit.h&gt; 

int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  
  QSplitter splitter(Qt::Horizontal); 
  splitter.setCaption(QObject::tr("Splitter")); 
  app.setMainWidget(&amp;splitter); 
  
  QTextEdit *firstEditor = new QTextEdit(&amp;splitter); 
  QTextEdit *secondEditor = new QTextEdit(&amp;splitter); 
  QTextEdit *thirdEditor = new QTextEdit(&amp;splitter); 
  
  splitter.show(); 
  return app.exec(); 
}
      
</pre>На форме находятся три компонента <tt class="CLASSNAME">
          QTextEdit</tt>, выровненных по горизонтали виджетом
          <tt class="CLASSNAME">QSplitter</tt>. В отличие от менеджера
          размещения, который отвечает только за размещение подчиненных
          виджетов, <tt class="CLASSNAME">QSplitter</tt> является
          потомком класса <tt class="CLASSNAME">QWidget</tt> и может
          использоваться как любой другой виджет.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.5.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.5. Разделитель в приложении.</p>
            </div>
          </div><br>
          <br>
          <br>

          <p><tt class="CLASSNAME">QSplitter</tt> может размещать
          подчиненные виджеты как по горизонтали, так и по вертикали.
          За счет вкладывания одного разделителя в другой, могут быть
          достигнуты весьма замысловатые комбинации. Например,
          приложение - почтовый клиент, главное окно которого
          изображено на рисунке 6.6, содержит горизонтальный
          разделитель и, вложенный в него, вертикальный
          разделитель.</p>

          <p>Ниже приводится код конструктора подкласса <tt class="CLASSNAME">QMainWindow</tt>:</p>
          <pre class="SCREEN">MailClient::MailClient(QWidget *parent, const char *name) 
    : QMainWindow(parent, name) 
{ 
  horizontalSplitter = new QSplitter(Horizontal, this); 
  setCentralWidget(horizontalSplitter); 
  
  foldersListView = new QListView(horizontalSplitter); 
  foldersListView-&gt;addColumn(tr("Folders"));
  foldersListView-&gt;setResizeMode(QListView::AllColumns);
  
  verticalSplitter = new QSplitter(Vertical, horizontalSplitter); 
  messagesListView = new QListView(verticalSplitter); 
  messagesListView-&gt;addColumn(tr("Subject")); 
  messagesListView-&gt;addColumn(tr("Sender")); 
  messagesListView-&gt;addColumn(tr("Date")); 
  messagesListView-&gt;setAllColumnsShowFocus(true); 
  messagesListView-&gt;setShowSortIndicator(true); 
  messagesListView-&gt;setResizeMode(QListView::AllColumns); 
  
  textEdit = new QTextEdit(verticalSplitter); 
  textEdit-&gt;setReadOnly(true); 
  
  horizontalSplitter-&gt;setResizeMode(foldersListView, 
                                    QSplitter::KeepSize); 
  verticalSplitter-&gt;setResizeMode(messagesListView, 
                                  QSplitter::KeepSize); 
  ...
  readSettings(); 
}
      
</pre>Здесь сначала создается горизонтальный разделитель, после чего он
назначается центральным виджетом. Затем создаются подчиненные виджеты.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.6.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.6. Почтовый клиент в Mac OS X.</p>
            </div>
          </div><br>
          Когда пользователь изменит размеры окна, <tt class="CLASSNAME">QSplitter</tt> распределит пространство между
          подчиненными виджетами таким образом, что относительные их
          размеры останутся без изменения. Но в случае с почтовым
          клиентом нам необходимо, чтобы два <tt class="CLASSNAME">QListView</tt> сохранили свои размеры, а все
          дополнительное пространство было отдано компоненту <tt class="CLASSNAME">QTextEdit</tt>. Достигается это парой вызовов
          <tt class="METHODNAME">setResizeMode()</tt>.<br>
          <br>

          <p>На запуске приложения, <tt class="CLASSNAME">QSplitter</tt> устанавливает размеры подчиненных
          виджетов, основываясь на их начальных размерах. Передвинуть
          разделитель можно не только вручную, но и программно, вызвав
          <tt class="METHODNAME">QSplitter::setSizes()</tt>. Кроме
          того, <tt class="CLASSNAME">QSplitter</tt> предоставляет
          возможность сохранить свое положение, при завершении работы
          приложения, и восстановить его на следующем запуске. Ниже
          приводится функция, которая сохраняет настройки приложения -
          почтового клиента: <a name="P143"></a></p>
          <pre class="SCREEN">void MailClient::writeSettings() 
{ 
  QSettings settings; 
  settings.setPath("software-inc.com", "MailClient"); 
  settings.beginGroup("/MailClient"); 
  
  QString str; 
  QTextOStream out1(&amp;str); 
  
  out1 &lt;&lt; *horizontalSplitter; 
  settings.writeEntry("/horizontalSplitter", str); 
  QTextOStream out2(&amp;str); 
  out2 &lt;&lt; *verticalSplitter; 
  settings.writeEntry("/verticalSplitter", str); 
  
  settings.endGroup(); 
}
      
</pre>И, соответствующая ей, функция <tt class="METHODNAME">readSettings()</tt>.
          <pre class="SCREEN">void MailClient::readSettings() 
{ 
  QSettings settings; 
  settings.setPath("software-inc.com", "MailClient"); 
  settings.beginGroup("/MailClient"); 
  
  QString str1 = settings.readEntry("/horizontalSplitter"); 
  QTextIStream in1(&amp;str1); 
  in1 &gt;&gt; *horizontalSplitter; 
  QString str2 = settings.readEntry("/verticalSplitter"); 
  QTextIStream in2(&amp;str2); 
  in2 &gt;&gt; *verticalSplitter; 
  
  settings.endGroup(); 
}
      
</pre>Вся файловые операции, в этих функциях, выполняются через классы
<tt class="CLASSNAME">QTextIStream</tt> и <tt class="CLASSNAME">
          QTextOStream</tt> -- потомки класса <tt class="CLASSNAME">QTextStream</tt>.<br>
          <br>

          <p>По-умолчанию, во время перетаскивания, разделитель
          отображается в виде рамки. А размеры виджетов, с обеих сторон
          разделителя, изменяют размер только тогда, когда пользователь
          отпустит кнопку мыши. Чтобы изменения размеров происходили в
          реальном времени, необходимо вызвать <tt class="METHODNAME">setOpaqueResize(true)</tt>.</p>

          <p>Разделители <tt class="CLASSNAME">QSplitter</tt> полностью
          поддерживаются визуальным построителем <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>.
          Чтобы поместить виджеты в разделитель -- разместите
          подчиненные виджеты на форме примерно так, как вы желаете,
          затем выделите их и выберите пункт меню <strong class="COMMAND">Layout|Lay Out Horizontally (in Splitter)</strong>
          или <strong class="COMMAND">Layout|Lay Out Vertically (in
          Splitter)</strong>.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="WIDGETSTACKS"></a>6.3.
          Многостраничные виджеты.</h1>

          <p>Еще один виджет, которые может оказаться полезным, в
          смысле компоновки -- это <tt class="CLASSNAME">QWidgetStack</tt>. Он может содержать наборы
          виджетов, объединяемых в "страницы", и всегда
          показывает только одну страницу, скрывая остальные. Нумерация
          страниц начинается с 0. Чтобы сделать определенный
          подчиненный виджет-страницу видимым, необходимо вызвать
          функцию <tt class="METHODNAME">raiseWidget()</tt>, передав ей
          либо номер страницы, либо указатель на подчиненный
          виджет.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.7.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.7. <tt class="CLASSNAME">QWidgetStack</tt>.</p>
            </div>
          </div><br>
          Сам по себе <tt class="CLASSNAME">QWidgetStack</tt> невидим и
          не предоставляет никаких дополнительных визуальных элементов,
          с помощью которых пользователь мог бы переходить от страницы
          к странице. Маленькие стрелочки и темно-серая рамка, которые
          вы можете наблюдать на рисунке 6.7, предоставляются
          визуальным построителем <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span> для удобства разработчика.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.8.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.8. Диалог <strong class="COMMAND">Configure</strong>.</p>
            </div>
          </div><br>
          Диалог <strong class="COMMAND">Configure</strong>,
          изображенный на рисунке 6.8, может служить примером
          использования <tt class="CLASSNAME">QWidgetStack</tt>. В
          левой части окна диалога находится <tt class="CLASSNAME">QListBox</tt>, а в правой -- <tt class="CLASSNAME">QWidgetStack</tt>. Каждому элементу в <tt class="CLASSNAME">QListBox</tt> соответствует своя страница в
          <tt class="CLASSNAME">QWidgetStack</tt>. Формы подобного рода
          очень просто создаются в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>:

          <ol type="1">
            <li>
              <p>Создается новая форма из шаблона "Dialog"
              или "Widget".</p>
            </li>

            <li>
              <p>На форму добавляются <tt class="CLASSNAME">QListBox</tt> и <tt class="CLASSNAME">QWidgetStack</tt>.</p>
            </li>

            <li>
              <p>Каждая страница <tt class="CLASSNAME">QWidgetStack</tt> заполняется необходимыми
              виджетами. (Чтобы создать новую страницу -- щелкните
              правой кнопкой мыши и выберите из контекстного меню пункт
              <strong class="COMMAND">Add Page</strong>. Чтобы перейти
              к другой странице -- щелкните мышкой по одной из кнопок,
              расположенных в правом верхнем углу.)</p>
            </li>

            <li>
              <p>Объедините <tt class="CLASSNAME">QListBox</tt> и
              <tt class="CLASSNAME">QWidgetStack</tt> менеджером
              горизонтального размещения.</p>
            </li>

            <li>
              <p>Соедините сигнал <tt class="METHODNAME">highlighted(int)</tt>, от <tt class="CLASSNAME">QListBox</tt>, со слотом <tt class="METHODNAME">raiseWidget(int)</tt>, компонента <tt class="CLASSNAME">QWidgetStack</tt>.</p>
            </li>

            <li>
              <p>Установите свойство <tt class="VARNAME">currentItem</tt> (<tt class="CLASSNAME">QListBox</tt>) равным 0.</p>
            </li>
          </ol>Поскольку мы реализовали механизм смены страниц
          стандартными сигналами и слотами, диалог будет способен
          выполнять корректный переход от страницы к странице, даже во
          время предварительного просмотра в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SCROLLVIEWS"></a>6.4. Области
          просмотра с прокруткой.</h1>

          <p>Класс <tt class="CLASSNAME">QScrollView</tt> представляет
          собой область просмотра с двумя полосами прокрутки и
          "угловым" компонентом, находящимся в правом нижнем
          углу (обычно -- пустой <tt class="CLASSNAME">QWidget</tt>).
          Если необходимо добавить полосы прокрутки к своему виджету,
          то намного проще воспользоваться готовым <tt class="CLASSNAME">QScrollView</tt>, чем добавлять компоненты
          <tt class="CLASSNAME">QScrollBar</tt> к своему виджету и
          писать код, реализующий их функциональность.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.9.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.9. Виджеты, составляющие <tt class="CLASSNAME">QScrollView</tt>.</p>
            </div>
          </div><br>
          Самый простой способ добавить визуальный компонент в
          <tt class="CLASSNAME">QScrollView</tt> -- это вызвать метод
          <tt class="METHODNAME">addChild()</tt>, указав необходимый
          подчиненный виджет в качестве аргумента. <tt class="CLASSNAME">QScrollView</tt> автоматически переподчинит
          визуальный компонент, став его владельцем. Например, пусть
          необходимо окружить компонент <tt class="CLASSNAME">IconEditor</tt>, который был разработан нами в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER5">Главе 5</a>, полосами прокрутки. Для
          этого можно было бы написать следующий код:
          <pre class="SCREEN">#include &lt;qapplication.h&gt; 
#include &lt;qscrollview.h&gt; 

#include "iconeditor.h" 

int main(int argc, char *argv[]) 
{
  QApplication app(argc, argv); 
  
  QScrollView scrollView; 
  scrollView.setCaption(QObject::tr("Icon Editor")); 
  app.setMainWidget(&amp;scrollView); 
  
  IconEditor *iconEditor = new IconEditor; 
  scrollView.addChild(iconEditor); 
  
  scrollView.show(); 
  return app.exec(); 
}
      
</pre>По-умолчанию, полосы прокрутки отображаются только в том случае,
когда подчиненный виджет не умещается в область просмотра (viewport).
Однако, следующий код вынудит <tt class="CLASSNAME">QScrollView</tt>
всегда показывать их:
          <pre class="SCREEN">scrollView.setHScrollBarMode(QScrollView::AlwaysOn); 
scrollView.setVScrollBarMode(QScrollView::AlwaysOn);      
      
</pre>Когда изменяется "идеальный" размер подчиненного
виджета, <tt class="CLASSNAME">QScrollView</tt> автоматически
адаптируется под новые условия.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.10.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.10. Изменение размеров <tt class="CLASSNAME">QScrollView</tt>.</p>
            </div>
          </div><br>
          Еще один способ добавить полосы прокрутки к своему виджету --
          использовать <tt class="CLASSNAME">QScrollView</tt> в
          качестве класса-предка и перекрыть метод <tt class="METHODNAME">drawContents()</tt>. Такой подход реализован в
          классах <tt class="CLASSNAME">QIconView, QListBox, QListView,
          QTable</tt> и <tt class="CLASSNAME">QTextEdit</tt>. Если
          вашему виджету необходимы полосы прокрутки, то лучшим
          решением будет породить класс виджета от <tt class="CLASSNAME">QScrollView</tt>.<br>
          <br>

          <p>Чтобы продемонстрировать это на примере, попробуем
          написать новую версию класса <tt class="CLASSNAME">IconEditor</tt>, породив его от <tt class="CLASSNAME">QScrollView</tt>. Назовем новый класс <tt class="CLASSNAME">ImageEditor</tt>, поскольку полосы прокрутки дают
          нам возможность работать с изображениями большого
          размера.</p>
          <pre class="SCREEN">#ifndef IMAGEEDITOR_H 
#define IMAGEEDITOR_H 

#include &lt;qimage.h&gt; 
#include &lt;qscrollview.h&gt;

class ImageEditor : public QScrollView 
{ 
  Q_OBJECT 
  Q_PROPERTY(QColor penColor READ penColor WRITE setPenColor) 
  Q_PROPERTY(QImage image READ image WRITE setImage) 
  Q_PROPERTY(int zoomFactor READ zoomFactor WRITE setZoomFactor) 
  
public: 
  ImageEditor(QWidget *parent = 0, const char *name = 0); 
  
  void setPenColor(const QColor &amp;newColor); 
  QColor penColor() const { return curColor; } 
  void setZoomFactor(int newZoom); 
  int zoomFactor() const { return zoom; } 
  void setImage(const QImage &amp;newImage); const 
  QImage &amp;image() const { return curImage; } 
  
protected: 
  void contentsMousePressEvent(QMouseEvent *event); 
  void contentsMouseMoveEvent(QMouseEvent *event); 
  void drawContents(QPainter *painter, int x, int y, int width, int height); 
  
private: 
  void drawImagePixel(QPainter *painter, int i, int j); 
  void setImagePixel(const QPoint &amp;pos, bool opaque); 
  void resizeContents(); 
  QColor curColor; 
  QImage curImage; int zoom; 
}; 

#endif
      
</pre>Заголовочный файл очень похож на <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P100">предыдущий</a>.
Основное отличие состоит в том, что теперь предком является не
<tt class="CLASSNAME">QWidget</tt>, а <tt class="CLASSNAME">QScrollView</tt>. Другие, менее значимые отличия, мы
рассмотрим в процессе описания реализации класса.
          <pre class="SCREEN">ImageEditor::ImageEditor(QWidget *parent, const char *name) 
    : QScrollView(parent, name, WStaticContents | WNoAutoErase) 
{ 
  curColor = black; 
  zoom = 8; 
  curImage.create(16, 16, 32); 
  curImage.fill(qRgba(0, 0, 0, 0)); 
  curImage.setAlphaBuffer(true); 
  resizeContents(); 
}
      
</pre>Родительскому конструктору передаются флаги <tt class="PARAMETER"><em>WStaticContents</em></tt> и <tt class="PARAMETER">
          <em>WNoAutoErase</em></tt>. Они необходимы для области
          просмотра. Мы не назначаем политики изменения размеров,
          поскольку значения по-умолчанию (<tt class="PARAMETER"><em>Expanding, Expanding</em></tt>) нас вполне
          устраивают. В конструкторе ранней версии мы не вызывали
          <tt class="METHODNAME">updateGeometry()</tt>, поскольку
          начальные размеры виджета могли зависеть от действий
          менеджеров размещения. Однако в данном случае, нам необходимо
          задать начальные размеры компонента, что мы и делаем вызовом
          <tt class="METHODNAME">resizeContents()</tt>.
          <pre class="SCREEN">void ImageEditor::resizeContents() 
{ 
  QSize size = zoom * curImage.size(); 
  if (zoom &gt;= 3) 
    size += QSize(1, 1); 
  QScrollView::resizeContents(size.width(), size.height()); 
}
      
</pre>Приватная функция <tt class="METHODNAME">resizeContents()</tt>
вызывает унаследованный метод <tt class="METHODNAME">QScrollView::resizeContents()</tt>, передавая ему
начальные размеры содержимого <tt class="CLASSNAME">QScrollView</tt>,
который в свою очередь отображает полосы прокрутки, в зависимости от
размеров содержимого и области просмотра.<br>
          <br>

          <p>Нам нет необходимости перекрывать функцию <tt class="METHODNAME">sizeHint()</tt>. Компонент <tt class="CLASSNAME">QScrollView</tt> автоматически вычисляет
          "идеальный" размер, отталкиваясь от размера
          содержимого области просмотра.</p>
          <pre class="SCREEN">void ImageEditor::setImage(const QImage &amp;newImage) 
{ 
  if (newImage != curImage) { 
    curImage = newImage.convertDepth(32); 
    curImage.detach(); 
    resizeContents(); 
    updateContents(); 
  } 
}
      
</pre>В большинстве случаев, в оригинальном <tt class="CLASSNAME">
          IconEditor</tt>, когда необходимо было послать компоненту
          событие "paint", мы вызывали методы <tt class="METHODNAME">update()</tt> и <tt class="METHODNAME">updateGeometry()</tt> -- чтобы объявить об
          изменении "идеальных" размеров. В новой версии, эти
          вызовы заменены на <tt class="METHODNAME">updateContents()</tt> и <tt class="METHODNAME">resizeContents()</tt>, соответственно.
          <pre class="SCREEN">void ImageEditor::drawContents(QPainter *painter, int, int, int, int) 
{ 
  if (zoom &gt;= 3) { 
    painter-&gt;setPen(colorGroup().foreground()); 
    for (int i = 0; i &lt;= curImage.width(); ++i) 
      painter-&gt;drawLine(zoom * i, 0, 
                        zoom * i, zoom * curImage.height()); 
    for (int j = 0; j &lt;= curImage.height(); ++j) 
      painter-&gt;drawLine(0, zoom * j, 
                        zoom * curImage.width(), zoom * j); 
  } 
  
  for (int i = 0; i &lt; curImage.width(); ++i) { 
    for (int j = 0; j &lt; curImage.height(); ++j) 
      drawImagePixel(painter, i, j); 
  } 
}
      
</pre><tt class="CLASSNAME">QScrollView</tt>вызывает функцию
          <tt class="METHODNAME">drawContents()</tt>, чтобы
          перерисовать содержимое области просмотра. Объект <tt class="CLASSNAME">QPainter</tt> уже инициализирован, в соответствии
          с позициями движков в полосах прокрутки, поэтому мы просто
          "рисуем", точно так же как в обработчике события
          <tt class="METHODNAME">paintEvent()</tt>.<br>
          <br>

          <p>Второй, третий, четвертый и пятый аргументы определяют
          координаты прямоугольника, который должен быть перерисован.
          Мы могли бы использовать их, чтобы перерисовывать только
          видимую часть изображения, но для упрощения примера мы
          перерисовыаем все изображение.</p>

          <p>Функция <tt class="METHODNAME">drawImagePixel()</tt>,
          обращение к которой стоит в конце <tt class="METHODNAME">drawContents()</tt>, осталась без изменений
          (<a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P106">см. оригинальную версию</a>), поэтому здесь
          мы ее рассматривать не будем.</p>
          <pre class="SCREEN">void ImageEditor::contentsMousePressEvent(QMouseEvent *event) 
{ 
  if (event-&gt;button() == LeftButton) 
    setImagePixel(event-&gt;pos(), true); 
  else if (event-&gt;button() == RightButton) 
    setImagePixel(event-&gt;pos(), false); 
} 

void ImageEditor::contentsMouseMoveEvent(QMouseEvent *event) 
{ 
  if (event-&gt;state() &amp; LeftButton) 
    setImagePixel(event-&gt;pos(), true); 
  else if (event-&gt;state() &amp; RightButton) 
    setImagePixel(event-&gt;pos(), false); 
}
      
</pre>События от мыши, направляемые содержимому <tt class="CLASSNAME">
          QScrollView</tt>, обрабатываются специальными функциями
          обработчиками, имена которых начинаются со слова <tt class="METHODNAME">contents</tt>. Прежде, чем события будут
          переданы обработчикам, <tt class="CLASSNAME">QScrollView</tt>
          выполнит преобразование координат из системы координат
          области просмотра в систему координат содержимого, поэтому у
          нас не возникает необходимости в написании дополнительного
          кода, выполняющего эти действия.
          <pre class="SCREEN">void ImageEditor::setImagePixel(const QPoint &amp;pos, bool opaque) 
{ 
  int i = pos.x() / zoom; 
  int j = pos.y() / zoom; 
  
  if (curImage.rect().contains(i, j)) { 
    if (opaque) 
      curImage.setPixel(i, j, penColor().rgb()); 
    else curImage.setPixel(i, j, qRgba(0, 0, 0, 0)); 
    
    QPainter painter(viewport()); 
    painter.translate(-contentsX(), -contentsY()); 
    drawImagePixel(&amp;painter, i, j); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">setImagePixel()</tt> вызывается из
<tt class="METHODNAME">contentsMousePressEvent()</tt> и
          <tt class="METHODNAME">contentsMouseMoveEvent()</tt>, для
          закрашивания и очистки пикселей. Код функций, по большей
          части, остался без изменений, за исключением способа
          инициализации объекта <tt class="CLASSNAME">QPainter</tt>. В
          данном случае, мы передаем ему <tt class="METHODNAME">viewport()</tt>, в качестве владельца, поскольку
          рисование будет производиться на поверхности области
          просмотра, а затем выполняем преобразование системы
          координат, чтобы учесть положение движков на полосах
          прокрутки.<br>
          <br>

          <p>Последние три строки, которые работают с <tt class="CLASSNAME">QPainter</tt>, можно было бы заменить одной
          строкой:</p>
          <pre class="SCREEN">updateContents(i * zoom, j * zoom, zoom, zoom);      
      
</pre>Которая сообщила бы <tt class="CLASSNAME">QScrollView</tt> о
необходимости перерисовать один квадратик, который соответствует
текущему пикселю. Но поскольку у нас функция <tt class="METHODNAME">
          drawContents()</tt> не оптимизирована, то приходится
          создавать <tt class="CLASSNAME">QPainter</tt> и рисовать
          изображение пикселя самостоятельно.<br>
          <br>

          <p>Если теперь мы попробуем поработать с <tt class="CLASSNAME">ImageEditor</tt>, то мы практически не заметим
          разницы с оригинальным <tt class="CLASSNAME">IconEditor</tt>,
          вставленным в <tt class="CLASSNAME">QScrollView</tt>. Однако,
          другие виджеты, порожденные от <tt class="CLASSNAME">QScrollView</tt>, используют дополнительные
          преимущества родительского класса. Например, <tt class="CLASSNAME">QTextEdit</tt> выполняет перенос текста по
          словам.</p>

          <p>Обратите внимание: вам наверняка придется использовать
          класс <tt class="CLASSNAME">QScrollView</tt>, в качестве
          предка, если размеры отображаемого содержимого очень велики,
          поскольку некоторые оконные подсистемы не в состоянии
          отобразить виджеты, размеры которых превышают величину 32767
          пикселей.</p>

          <p>Еще один важный момент, которого мы не коснулись здесь: мы
          можем вставлять подчиненные виджеты в область просмотра,
          вызовом функции <tt class="METHODNAME">addWidget()</tt>, и
          перемещать вызовом <tt class="METHODNAME">moveWidget()</tt>.
          Всякий раз, когда пользователь перемещается по области
          просмотра, с помощью полос прокрутки, <tt class="CLASSNAME">QScrollView</tt> автоматически перемещает
          подчиненные виджеты на экране. (Если подчиненных виджетов
          слишком много, то прокрутка может существенно замедляться.
          Чтобы оптимизировать этот процесс, можно вызвать <tt class="METHODNAME">enableClipper(true)</tt>.) В качестве примера,
          использующего подобный подход, можно привести web-браузер, в
          котором большая часть содержимого может отрисовываться
          непосредственно в области просмотра, но кнопки и поля ввода
          на формах должны быть представлены в виде виджетов.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="DOCKWINDOWS"></a>6.5. Стыкуемые
          окна.</h1>

          <p>Стыкуемые окна -- это окна, которые могут отстыковываться
          и пристыковываться к специальным областям стыковки. Самый
          яркий пример, пожалуй, это панели инструментов.</p>

          <p>Объекты класса <tt class="CLASSNAME">QMainWindow</tt>
          предоставляют в распоряжение программиста четыре области
          стыковки: вверху, внизу, слева и справа от центрального
          виджета. Когда создаются экземпляры класса <tt class="CLASSNAME">QToolBar</tt>, они автоматически пристыковываются
          к верхней области окна-владельца.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.11.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.11. "Плавающие" пристыковываемые
              окна.</p>
            </div>
          </div><br>
          Каждое из таких окон имеет "рукоятку". Она
          отображается в виде двух серых линий в левой или в верхней
          части окна, как это показано на рисунке 6.12. Ухватив мышью
          за "рукоятку", пользователь может перемещать
          стыкуемые окна из одной области стыковки в другую. Он так же
          может отделять стыкуемые окна от главного окна приложения.
          Отстыкованные окна могут свободно перемещаться по всей
          поверхности экрана, они имеют свою полосу заголовка и могут
          иметь собственную кнопку закрытия окна. Отстыкованные окна
          всегда отображаются поверх родительского окна.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.12.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.12. <tt class="CLASSNAME">QMainWindow</tt> с
              пятью стыкуемыми окнами.</p>
            </div>
          </div><br>
          Чтобы кнопка закрытия отображалась на отстыкованном окне,
          необходимо вызвать <tt class="METHODNAME">setCloseMode()</tt>:
          <pre class="SCREEN">dockWindow-&gt;setCloseMode(QDockWindow::Undocked);      
      
</pre>Область стыковки -- <tt class="CLASSNAME">QDockArea</tt>, имеет
свое контекстное меню, со списком всех пристыкованных окон и панелей
инструментов. После того, как отстыкованное окно было закрыто
пользователем, оно может быть восстановлено с помощью этого меню.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.13.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.13. Контекстное меню <tt class="CLASSNAME">QDockArea</tt>.</p>
            </div>
          </div><br>
          Стыкуемые окна должны быть потомками класса <tt class="CLASSNAME">QDockWindow</tt>. Если вам нужна панель
          инструментов с кнопками и некоторыми другими виджетами, то
          для этой цели прекрасно подойдет <tt class="CLASSNAME">QToolBar</tt>, который является наследником
          <tt class="CLASSNAME">QDockWindow</tt>. Ниже приводится
          пример создания экземпляра класса <tt class="CLASSNAME">QToolBar</tt>, на который помещаются <tt class="CLASSNAME">QComboBox</tt>, <tt class="CLASSNAME">QSpinBox</tt> и ряд дополнительных кнопок.
          Полученная панель инструментов размещается в нижней области
          стыковки:
          <pre class="SCREEN">  QToolBar *toolBar = new QToolBar(tr("Font"), this); 
  QComboBox *fontComboBox = new QComboBox(true, toolBar);      

  QSpinBox *fontSize = new QSpinBox(toolBar); 
  boldAct-&gt;addTo(toolBar); 
  italicAct-&gt;addTo(toolBar); 
  underlineAct-&gt;addTo(toolBar); 
  moveDockWindow(toolBar, DockBottom);
      
</pre>Эта панель будет выглядеть просто отвратительно, если
пользователь переместит ее в левую или правую область стыковки, из-за
<tt class="CLASSNAME">QComboBox</tt> и <tt class="CLASSNAME">QSpinBox</tt>. Чтобы предотвратить такую возможность, мы
можем запретить стыковку к левой и правой областям, вызовом
          <tt class="METHODNAME">QMainWindow:: setDockEnabled()</tt>:
          <pre class="SCREEN">  setDockEnabled(toolBar, DockLeft, false); 
  setDockEnabled(toolBar, DockRight, false);      
      
</pre>Если необходимо создать нечто более похожее на плавающее окно или
палитру инструментов, то можно напрямую обращаться к
          <tt class="CLASSNAME">QDockWindow</tt>, вызывая метод
          <tt class="METHODNAME">setWidget()</tt>, чтобы добавить
          виджет в окно. Если необходимо предоставить пользователю
          возможность изменять размеры пристыкованного окна, то для
          этого можно воспользоваться функцией <tt class="METHODNAME">setResizeEnabled()</tt>.<br>
          <br>

          <p>Если виджет должен изменять свой вид, в зависимости от
          того, к какой из областей стыковки он присоединен, то для
          этого необходимо перекрыть метод <tt class="METHODNAME">QDockWindow:: setOrientation()</tt> и выполять
          все необходимые действия в нем.</p>

          <p>Если необходимо сохранять положение всех панелей
          инструментов и других стыкуемых окон, чтобы потом, на
          следующем запуске приложения восстанавливать его, можно
          написать код, который очень похож на тот, <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P143">который мы разбирали ранее</a>, используя оператор
          "&lt;&lt;" класса <tt class="CLASSNAME">QMainWindow</tt>, для записи в файл, и
          "&gt;&gt;" -- для восстановления из файла.</p>

          <p>Приложения, подобные <span class="emphasis"><em class="EMPHASIS">Microsoft Visual Studio</em></span> и <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span> очень
          широко используют стыкуемые окна, чтобы сделать интерфейс с
          пользователем более гибким.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="MULTIPLEDOCUMENTINTERFACE"></a>6.6. Многодокументный
          интерфейс.</h1>

          <p>Приложения, которые могут работать с несколькими
          документами, открываемыми в отдельных окнах и расположенных
          внутри главного окна, называют MDI-приложениями (MDI -- от
          англ. Multiple Document Interface). В Qt подобный интерфейс
          создается с помощью класса <tt class="CLASSNAME">QWorkspace</tt>, назначаемого центральным
          виджетом. Каждое окно с открытым документом становится
          подчиненным, по отношению к <tt class="CLASSNAME">QWorkspace</tt>.</p>

          <p>В этом разделе мы создадим приложение <strong class="COMMAND">Editor</strong> (текстовый редактор), изображенное
          на рисунке 6.14, чтобы продемонстрировать принципы создания
          MDI-приложений и оконных меню.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.14.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.14. Внешний вид приложения Editor.</p>
            </div>
          </div><br>
          Приложение состоит из двух классов: <tt class="CLASSNAME">MainWindow</tt> и <tt class="CLASSNAME">Editor</tt>. Полный код приложения находится на
          CD, сопровождающем книгу, а поскольку он во многом похож на
          код, который мы писали в приложении Spreadsheet (в первой
          части книги), то мы будем описывать только ту часть
          реализации, которая является для нас еще незнакомой.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig6.15.png"></p>

            <div class="CAPTION">
              <p>Рисунок 6.15. Меню приложения Editor.</p>
            </div>
          </div><br>
          Начнем с класса <tt class="CLASSNAME">MainWindow</tt>.
          <pre class="SCREEN">MainWindow::MainWindow(QWidget *parent, const char *name) 
    : QMainWindow(parent, name) 
{ 
  workspace = new QWorkspace(this); 
  setCentralWidget(workspace); 
  connect(workspace, SIGNAL(windowActivated(QWidget *)), 
          this, SLOT(updateMenus())); 
  connect(workspace, SIGNAL(windowActivated(QWidget *)), 
          this, SLOT(updateModIndicator())); 
  createActions(); 
  createMenus(); 
  createToolBars();
  createStatusBar(); 
  
  setCaption(tr("Editor")); 
  setIcon(QPixmap::fromMimeSource("icon.png")); 
}
      
</pre>В конструкторе создается экземпляр класса <tt class="CLASSNAME">
          QWorkspace</tt> и назначается центральным виджетом. Затем мы
          соединяем сигнал <tt class="METHODNAME">windowActivated()</tt>, класса <tt class="CLASSNAME">QWorkspace</tt>, с двумя приватными слотами. Эти
          слоты гарантируют, что меню и строка состояния всегда будут
          соответствовать текущему активному окну.
          <pre class="SCREEN">void MainWindow::newFile() 
{ 
  Editor *editor = createEditor(); 
  editor-&gt;newFile(); 
  editor-&gt;show(); 
}
      
</pre>Слот <tt class="METHODNAME">newFile()</tt> соответствует пункту
меню <strong class="COMMAND">File|New</strong>. Он создает новое окно
(класса <tt class="CLASSNAME">Editor</tt>) с документом, вызывая
приватную функцию <tt class="METHODNAME">createEditor()</tt>.
          <pre class="SCREEN">Editor *MainWindow::createEditor() 
{ 
  Editor *editor = new Editor(workspace); 
  connect(editor, SIGNAL(copyAvailable(bool)), 
          this, SLOT(copyAvailable(bool))); 
  connect(editor, SIGNAL(modificationChanged(bool)), 
          this, SLOT(updateModIndicator())); 
  return editor; 
}
      
</pre>Функция <tt class="METHODNAME">createEditor()</tt> создает виджет
класса <tt class="CLASSNAME">Editor</tt> и устанавливает два соединения
типа сигнал-слот. Первое соответствует пунктам меню
          <strong class="COMMAND">Edit|Cut</strong> и <strong class="COMMAND">Edit|Copy</strong>. Доступность этих пунктов меню
          разрешается или запрещается, в зависимости от наличия
          выделенного текста. Второе соединение отвечает за обновление
          индикатора MOD (признак наличия в документе несохраненных
          изменений), который находится в строке состояния.<br>
          <br>

          <p>Поскольку мы имеем дело с многодокументным интерфейсом, то
          вполне возможно, что одновременно могут оказаться открытыми
          несколько окон с документами. Вас может обеспокоить этот
          факт, поскольку интерес для нас представляют сигналы
          <tt class="METHODNAME">copyAvailable(bool)</tt> и <tt class="METHODNAME">modificationChanged()</tt>, исходящие только от
          активного окна. На самом деле это не может служить причиной
          для беспокойства, поскольку сигналы могут подавать только
          активные окна.</p>
          <pre class="SCREEN">void MainWindow::open() 
{ 
  Editor *editor = createEditor(); 
  if (editor-&gt;open()) 
    editor-&gt;show(); 
  else 
    editor-&gt;close(); 
}
      
</pre>Функция <tt class="METHODNAME">open()</tt> соответствует пункту
меню <strong class="COMMAND">File|Open</strong>. Она создает новое окно
<tt class="CLASSNAME">Editor</tt> и вызывает метод <tt class="METHODNAME">Editor::open()</tt>. Если функция <tt class="METHODNAME">
          Editor::open()</tt> завершается с ошибкой, то окно редактора
          просто закрывается, поскольку пользователь уже был извещен о
          возникших проблемах.
          <pre class="SCREEN">void MainWindow::save() 
{ 
  if (activeEditor()) { 
    activeEditor()-&gt;save(); 
    updateModIndicator(); 
  } 
}
      
</pre>Слот <tt class="METHODNAME">save()</tt> вызывает функцию
<tt class="METHODNAME">save()</tt> активного окна. Опять таки, весь
код, который фактически сохраняет файл, находится в классе
          <tt class="CLASSNAME">Editor</tt>.
          <pre class="SCREEN">Editor *MainWindow::activeEditor() 
{ 
  return (Editor *)workspace-&gt;activeWindow(); 
}
      
</pre>Приватная функция <tt class="METHODNAME">activeEditor()</tt>
возвращает указатель на активное окно редактора.
          <pre class="SCREEN">void MainWindow::cut() 
{ 
  if (activeEditor()) 
    activeEditor()-&gt;cut(); 
}
      
</pre>Слот <tt class="METHODNAME">cut()</tt> вызывает функцию
          <tt class="METHODNAME">cut()</tt> активного окна. Слоты
          <tt class="METHODNAME">copy(), paste()</tt> и <tt class="METHODNAME">del()</tt> реализованы аналогичным образом.
          <pre class="SCREEN">void MainWindow::updateMenus() 
{ 
  bool hasEditor = (activeEditor() != 0); 
  saveAct-&gt;setEnabled(hasEditor); 
  saveAsAct-&gt;setEnabled(hasEditor); 
  pasteAct-&gt;setEnabled(hasEditor); 
  deleteAct-&gt;setEnabled(hasEditor); 
  copyAvailable(activeEditor() 
                &amp;&amp; activeEditor()-&gt;hasSelectedText()); 
  closeAct-&gt;setEnabled(hasEditor); 
  closeAllAct-&gt;setEnabled(hasEditor); 
  tileAct-&gt;setEnabled(hasEditor); 
  cascadeAct-&gt;setEnabled(hasEditor); 
  nextAct-&gt;setEnabled(hasEditor); 
  previousAct-&gt;setEnabled(hasEditor); 
  
  windowsMenu-&gt;clear(); 
  createWindowsMenu(); 
}
      
</pre>Слот <tt class="METHODNAME">updateMenus()</tt> вызывается всякий
раз, когда активизируется другое окно (или когда закрывается последнее
окно с документом), с целью обновления системы меню. Большинство из
пунктов меню имеют смысл только при наличии активного дочернего окна,
поэтому мы запрещаем некоторые пункты меню, если нет ни одного окна с
открытым документом. Затем очищается меню <strong class="COMMAND">
          Windows</strong> и вызывается функция <tt class="METHODNAME">createWindowsMenu()</tt>, которая обновляет
          список открытых дочерних окон. <a name="P156"></a>
          <pre class="SCREEN">void MainWindow::createWindowsMenu() 
{ 
  closeAct-&gt;addTo(windowsMenu); 
  closeAllAct-&gt;addTo(windowsMenu); 
  windowsMenu-&gt;insertSeparator(); 
  tileAct-&gt;addTo(windowsMenu); 
  cascadeAct-&gt;addTo(windowsMenu); 
  windowsMenu-&gt;insertSeparator(); 
  nextAct-&gt;addTo(windowsMenu); 
  previousAct-&gt;addTo(windowsMenu); 
  
  if (activeEditor()) { 
    windowsMenu-&gt;insertSeparator(); 
    windows = workspace-&gt;windowList(); 
    int numVisibleEditors = 0; 
    
    for (int i = 0; i &lt; (int)windows.count(); ++i) { 
      QWidget *win = windows.at(i); 
      if (!win-&gt;isHidden()) { 
        QString text = tr("%1 %2") 
                       .arg(numVisibleEditors + 1) 
                       .arg(win-&gt;caption()); 
        if (numVisibleEditors &lt; 9) 
          text.prepend("&amp;"); 
        int id = windowsMenu-&gt;insertItem( 
                      text, this, SLOT(activateWindow(int))); 
        bool isActive = (activeEditor() == win); 
        windowsMenu-&gt;setItemChecked(id, isActive); 
        windowsMenu-&gt;setItemParameter(id, i); 
        ++numVisibleEditors; 
      } 
    } 
  } 
}
      
</pre>Приватная функция <tt class="METHODNAME">createWindowsMenu()</tt>
заполняет меню <strong class="COMMAND">Windows</strong> действиями
(action) и дополняет списком открытых окон. Перечень пунктов типичен
для меню подобного рода и соответствующие им действия легко реализуются
с помощью слотов <tt class="CLASSNAME">QWorkspace</tt> --
          <tt class="METHODNAME">closeActiveWindow(),
          closeAllWindows(), tile()</tt> и <tt class="METHODNAME">cascade()</tt>.<br>
          <br>

          <p>Активное окно, в списке, отмечается маркером, напротив
          имени документа. Когда пользователь выбирает пункт меню,
          соответствующий открытому документу, вызывается слот
          <tt class="METHODNAME">activateWindow()</tt>, которому в
          качестве аргумента передается индекс в массиве <tt class="VARNAME">windows</tt>. Это очень похоже на то, что мы делали
          в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">Главе 3</a>, когда создавали <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P54">список недавно открывавшихся документов</a>.</p>

          <p>Для первых девяти пунктов меню мы добавили символ
          амперсанда, перед порядковым номером пункта меню, чтобы можно
          было быстро перемещаться между открытыми документами, с
          помощью горячих клавиш.</p>
          <pre class="SCREEN">void MainWindow::activateWindow(int param) 
{ 
  QWidget *win = windows.at(param); 
  win-&gt;show(); 
  win-&gt;setFocus(); 
}
      
</pre>Функция <tt class="METHODNAME">activateWindow()</tt> вызывается,
когда пользователь выбирает какое либо окно с документом, из меню
<strong class="COMMAND">Windows</strong>. Параметр <tt class="PARAMETER"><em>param</em></tt> -- это индекс выбранного окна, в
массиве <tt class="VARNAME">windows</tt>.
          <pre class="SCREEN">void MainWindow::copyAvailable(bool available) 
{ 
  cutAct-&gt;setEnabled(available); 
  copyAct-&gt;setEnabled(available); 
}
      
</pre>Слот <tt class="METHODNAME">copyAvailable()</tt> вызывается,
когда выделяется какой либо текст (или наоборот, когда выделение
снимается) в окне редактора. Он так же вызывается из
          <tt class="METHODNAME">updateMenus()</tt>. И разрешает или
          запрещает пункты меню <strong class="COMMAND">Cut</strong> и
          <strong class="COMMAND">Copy</strong>.
          <pre class="SCREEN">void MainWindow::updateModIndicator() 
{ 
  if (activeEditor() &amp;&amp; activeEditor()-&gt;isModified()) 
    modLabel-&gt;setText(tr("MOD")); 
  else 
    modLabel-&gt;clear(); 
}
      
</pre>Функция <tt class="METHODNAME">updateModIndicator()</tt>
обновляет индикатор MOD в строке состояния. Вызывается при любом
изменении текста в окне редактора, а так же при активации другого окна.
          <pre class="SCREEN">void MainWindow::closeEvent(QCloseEvent *event) 
{ 
  workspace-&gt;closeAllWindows(); 
  if (activeEditor()) 
    event-&gt;ignore(); 
  else 
    event-&gt;accept(); 
}
      
</pre>Функция <tt class="METHODNAME">closeEvent()</tt> закрывает все
дочерние окна. Если какое либо из окон "проигнорирует"
событие "close" (например в том случае, когда пользователь
отменил закрытие окна, имевшее несохраненные данные), то это событие
так же игнорируется и главным окном приложения <tt class="CLASSNAME">
          MainWindow</tt>. В противном случае событие
          "принимается" и Qt закрывает окно. Если не
          перекрыть этот обработчик, то у пользователя не будет
          возможности записать на диск несохраненные данные.<br>
          <br>

          <p>На этом мы завершаем обзор класса <tt class="CLASSNAME">MainWindow</tt> и переходим к реализации класса
          <tt class="CLASSNAME">Editor</tt>. Этот класс представляет
          собой одно дочернее окно. Он порожден от класса <tt class="CLASSNAME">QTextEdit</tt>, который реализует всю необходимую
          функциональность по редактированию текста. Так же, как и
          любой другой виджет Qt, <tt class="CLASSNAME">QTextEdit</tt>
          может использоваться как дочернее окно в рабочей области
          MDI.</p>

          <p>Ниже приводится определение класса:</p>
          <pre class="SCREEN">class Editor : public QTextEdit 
{ 
  Q_OBJECT 
  
public: 
  Editor(QWidget *parent = 0, const char *name = 0); 
  
  void newFile(); 
  bool open(); 
  bool openFile(const QString &amp;fileName); 
  bool save(); 
  bool saveAs(); 
  QSize sizeHint() const; 
  
signals: 
  void message(const QString &amp;fileName, int delay); 
  
protected: 
  void closeEvent(QCloseEvent *event); 
  
private: 
  bool maybeSave(); 
  void saveFile(const QString &amp;fileName); 
  void setCurrentFile(const QString &amp;fileName); 
  QString strippedName(const QString &amp;fullFileName); 
  bool readFile(const QString &amp;fileName); 
  bool writeFile(const QString &amp;fileName); 
  
  QString curFile; 
  bool isUntitled; 
  QString fileFilters; 
};
      
</pre>Четыре приватных функции, которые <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P51">обсуждались</a>
нами при создании приложения Spreadsheet, аналогичным образом
реализованы и в классе <tt class="CLASSNAME">Editor</tt>. Это функции
<tt class="METHODNAME">maybeSave(), saveFile(), setCurrentFile()</tt> и
<tt class="METHODNAME">strippedName()</tt>.
          <pre class="SCREEN">Editor::Editor(QWidget *parent, const char *name) 
    : QTextEdit(parent, name) 
{ 
  setWFlags(WDestructiveClose); 
  setIcon(QPixmap::fromMimeSource("document.png")); 
  
  isUntitled = true; 
  fileFilters = tr("Text files (*.txt)\n" 
                "All files (*)"); 
}
      
</pre>В конструкторе, с помощью функции <tt class="METHODNAME">
          setWFlags()</tt>, взводится флаг <tt class="PARAMETER"><em>WDestructiveClose</em></tt>. Если конструктор
          класса не принимает флаги в качестве аргументов, как это
          имеет место быть в случае с <tt class="CLASSNAME">QTextEdit</tt>, то мы можем установить флаги
          вызовом <tt class="METHODNAME">setWFlags()</tt>.<br>
          <br>

          <p>Так как мы позволяем пользователям одновременно открывать
          несколько документов, необходимо предусмотреть какие либо
          характеристики окон, чтобы потом пользователи могли как-то их
          отличать между собой, до того, как вновь создаваемые
          документы будут сохранены. Самый распространенный способ --
          присваивать документам имена по-умолчанию, которые включают в
          себя порядковый номер (например, <tt class="FILENAME">document1.txt</tt>). Для этой цели мы используем
          переменную <tt class="VARNAME">isUntitled</tt>, которая
          отличает имена документов, уже существующих, и имена
          документов, которым имя еще не было присвоено
          пользователем.</p>

          <p>После вызова конструктора должна вызываться одна из двух
          функций -- либо <tt class="METHODNAME">newFile()</tt>, либо
          <tt class="METHODNAME">open()</tt>.</p>
          <pre class="SCREEN">void Editor::newFile() 
{ 
  static int documentNumber = 1; 
  
  curFile = tr("document%1.txt").arg(documentNumber); 
  setCaption(curFile); 
  isUntitled = true; 
  ++documentNumber; 
}
      
</pre>Функция <tt class="METHODNAME">newFile()</tt> генерирует новое
имя документа, например <tt class="FILENAME">document2.txt</tt>. Этот
код помещен в <tt class="METHODNAME">newFile()</tt>, а не в
конструктор, потому что нет необходимости вести счетчик создаваемых
документов для тех из них, которые после конструирования объекта будут
открываться функцией <tt class="METHODNAME">open()</tt>. Поскольку
переменная <tt class="VARNAME">documentNumber</tt> объявлена как
статическая, то она существует в единственном экземпляре, для всех
объектов класса <tt class="CLASSNAME">Editor</tt>.
          <pre class="SCREEN">bool Editor::open() 
{ 
  QString fileName = 
          QFileDialog::getOpenFileName(".", fileFilters, this); 
  if (fileName.isEmpty()) 
    return false; 
    
  return openFile(fileName); 
}
      
</pre>Функция <tt class="METHODNAME">open()</tt> пытается открыть
существующий файл, с помощью вызова <tt class="METHODNAME">openFile()</tt>.
          <pre class="SCREEN">bool Editor::save() 
{ 
  if (isUntitled) { 
    return saveAs(); 
  } else { 
    saveFile(curFile); 
    return true; } 
}
      
</pre>Функция <tt class="METHODNAME">save()</tt> использует переменную
<tt class="VARNAME">isUntitled</tt>, чтобы определить -- какую функцию
вызывать: <tt class="METHODNAME">saveFile()</tt> или
          <tt class="METHODNAME">saveAs()</tt>.
          <pre class="SCREEN">void Editor::closeEvent(QCloseEvent *event) 
{ 
  if (maybeSave()) 
    event-&gt;accept(); 
  else 
    event-&gt;ignore(); 
}
      
</pre>За счет перекрытия родительского метода <tt class="METHODNAME">
          closeEvent()</tt> мы даем пользователю возможность сохранить
          имеющиеся изменения. Логика сохранения реализована в функции
          <tt class="METHODNAME">maybeSave()</tt>, которая выводит
          запрос перед пользователем: "Желаете ли вы сохранить
          имеющиеся изменения?". Если она возвращает <tt class="PARAMETER"><em>true</em></tt>, то событие "close"
          принимается, в противном случае оно игнорируется и окно
          останется открытым.
          <pre class="SCREEN">void Editor::setCurrentFile(const QString &amp;fileName) 
{ 
  curFile = fileName; 
  setCaption(strippedName(curFile)); 
  isUntitled = false; 
  setModified(false); 
}
      
</pre>Функция <tt class="METHODNAME">setCurrentFile()</tt> вызывается
из <tt class="METHODNAME">openFile()</tt> и <tt class="METHODNAME">
          saveFile()</tt>, чтобы изменить содержимое переменных
          <tt class="VARNAME">curFile</tt> и <tt class="VARNAME">isUntitled</tt>, обновить заголовок окна и сбросить
          признак "modified". Класс <tt class="CLASSNAME">Editor</tt> наследует методы <tt class="METHODNAME">setModified()</tt> и <tt class="METHODNAME">isModified()</tt> от своего предка -- <tt class="CLASSNAME">QTextEdit</tt>, поэтому у нас нет необходимости
          "тащить" свой признак модификации документа. Когда
          пользователь вносит какие либо изменения в документ,
          <tt class="CLASSNAME">QTextEdit</tt> выдает сигнал <tt class="METHODNAME">modificationChanged()</tt> и устанавливает
          признак модификации.
          <pre class="SCREEN">QSize Editor::sizeHint() const 
{ 
  return QSize(72 * fontMetrics().width( x ), 
               25 * fontMetrics().lineSpacing()); 
}
      
</pre>Функция <tt class="METHODNAME">sizeHint()</tt> возвращает
"идеальные" размеры виджета, основываясь на размере символа
'x'. Класс <tt class="CLASSNAME">QWorkspace</tt> использует эти
размеры, чтобы назначить начальные размеры для окна с документом.<br>

          <br>

          <p>И в заключение приведем исходный текст файла <tt class="FILENAME">main.cpp</tt>:</p>
          <pre class="SCREEN">#include &lt;qapplication.h&gt; 

#include "mainwindow.h" 

int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  MainWindow mainWin; 
  app.setMainWidget(&amp;mainWin); 
  if (argc &gt; 1) { 
    for (int i = 1; i &lt; argc; ++i) 
      mainWin.openFile(argv[i]); 
    } else { 
      mainWin.newFile(); 
    } 
    
    mainWin.show(); 
    return app.exec(); 
}
      
</pre>Если пользователь задаст имена документов в командной строке, то
приложение попытается загрузить их. В противном случае приложение
создает пустой документ. Специфические ключи командной строки, такие
как <tt class="PARAMETER"><em>-style</em></tt> и <tt class="PARAMETER">
          <em>-font</em></tt>, будут автоматически исключены из списка
          аргументов, конструктором <tt class="CLASSNAME">QApplication</tt>. Так что, если мы дадим такую
          команду:
          <pre class="SCREEN">editor -style=motif readme.txt      
      
</pre>То приложение на запуске откроет один единственный документ
<tt class="FILENAME">readme.txt</tt>.<br>
          <br>

          <p>Многодокументный интерфейс -- один из способов
          одновременной работы с несколькими документами. Другой способ
          состоит в том, чтобы использовать несколько окон верхнего
          уровня. Он был описан в разделе <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#MULTIPLEDOCUMENTS">Работа с несколькими документами
          одновременно</a> Главы 3.</p>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER7"></a>Глава 7. Обработка событий.</h1>

        <p>Приложения с графическим интерфейсом управляются событиями:
        все, что происходит в приложении -- есть результат обработки
        тех или иных событий. При разработке программ под Qt,
        задумываться о событиях приходится довольно редко, поскольку
        виджеты Qt выдают <span class="emphasis"><em class="EMPHASIS">сигналы</em></span>, когда происходит нечто
        значительное. События приобретают значение в том случае, когда
        необходимо создать новый виджет или когда нужно расширить
        функциональность существующего виджета.</p>

        <p>В этой главе мы рассмотрим существующую модель обработки
        событий, расскажем о фильтрации событий и в заключение
        исследуем цикл обработки событий, на предмет того, как
        уменьшить время отклика приложения на действия пользователя, во
        время длительной обработки данных.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="REIMPLEMENTINGEVENTHANDLERS"></a>7.1. Обработчики
          событий.</h1>

          <p>События генерируются оконной системой или Qt, в ответ на
          различные ситуации. Когда нажимается или отпускается клавиша
          на клавиатуре или кнопка мыши, генерируется соответствующее
          событие. Когда перемещается одно окно и в результате этого
          перемещения открывается другое, лежавшее ниже, возникает
          событие, которое сообщает открывшемуся окну о необходимости
          перерисовать себя. События генерируются всякий раз, когда
          виджет теряет или получает фокус ввода. В большинстве своем,
          события генерируются в ответ на действия пользователя, но
          иногда, например события от таймера, они генерируются
          системой независимо от пользователя.</p>

          <p>Не надо путать события с сигналами. Сигналы необходимы для
          организации взаимодействий между виджетами, тогда как события
          необходимы для организации взаимодействия между виджетом и
          системой. Например, когда мы используем <tt class="CLASSNAME">QPushButton</tt>, нас больше интересует сигнал
          <tt class="METHODNAME">clicked()</tt>, нежели события от мыши
          или клавиатуры, которые стали причиной появления сигнала. Но
          если мы разрабатываем новый класс, на подобие <tt class="CLASSNAME">QPushButton</tt>, то нам придется писать код,
          который будет обрабатывать события от мыши и клавиатуры, и
          выдавать сигнал <tt class="METHODNAME">clicked()</tt> по мере
          необходимости.</p>

          <p>События поступают к объектам в функцию <tt class="METHODNAME">event()</tt>, унаследованную от <tt class="CLASSNAME">QObject</tt>. Реализация функции <tt class="METHODNAME">event()</tt> в <tt class="CLASSNAME">QWidget</tt> передает наиболее употребимые типы
          событий специализированным обработчикам, таким как <tt class="CLASSNAME">mousePressEvent(), keyPressEvent()</tt> и
          <tt class="CLASSNAME">paintEvent()</tt>, остальные события
          игнорируются.</p>

          <p>В предыдущих главах мы уже сталкивались с обработкой
          событий, при создании классов <tt class="CLASSNAME">MainWindow, IconEditor, Plotter, ImageEditor</tt>
          и <tt class="CLASSNAME">Editor</tt>. Полный список типов
          событий вы найдете в сопроводительной документации к классу
          <tt class="CLASSNAME">QEvent</tt>. Кроме того, за
          программистом сохраняется возможность создания и
          диспетчеризации своих собственных типов событий.
          Нестандартные типы событий широко применяются в многопоточных
          приложениях, но это тема <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER17">отдельной
          главы</a>. В этой главе мы рассмотрим два типа событий:
          события от клавиатуры и события от таймера.</p>

          <p>События от клавиатуры обрабатываются функциями <tt class="METHODNAME">keyPressEvent()</tt> и <tt class="METHODNAME">keyReleaseEvent()</tt>. В примере с виджетом
          <tt class="CLASSNAME">Plotter</tt>, мы перекрывали
          родительский обработчик <tt class="METHODNAME">keyPressEvent()</tt>. Обычно программиста
          интересует только <tt class="METHODNAME">keyPressEvent()</tt>, поскольку к моменту
          нажатия интересующей его клавиши уже нажаты
          клавиши-модификаторы, а к моменту отпускания нужной клавиши,
          клавиши-модификаторы могут быть уже отжаты. К
          клавишам-модификаторам относятся: <strong class="COMMAND">Ctrl, Shift</strong> и <strong class="COMMAND">Alt</strong>. Состояние этих клавиш может быть
          получено вызовом функции <tt class="METHODNAME">state()</tt>.
          Например, представим, что нам необходимо написать виджет
          <tt class="CLASSNAME">CodeEditor</tt> и реализовать
          обработчик событий от клавиатуры, который различал бы
          комбинации клавиш <tt class="PARAMETER"><em>Home</em></tt> и
          <tt class="PARAMETER"><em>Ctrl+Home</em></tt>, в этом случае
          мы могли бы написать следующий код:</p>
          <pre class="SCREEN">void CodeEditor::keyPressEvent(QKeyEvent *event) 
{ 
  switch (event-&gt;key()) { 
    case Key_Home: 
        if (event-&gt;state() &amp; ControlButton) 
          goToBeginningOfDocument(); 
        else 
          goToBeginningOfLine(); 
        break; 
    case Key_End:  
        ...
    default: 
      QWidget::keyPressEvent(event); 
  } 
}
      
</pre>Комбинации <tt class="PARAMETER"><em>Tab</em></tt> и
          <tt class="PARAMETER"><em>Backtab</em></tt> (<tt class="PARAMETER"><em>Shift+Tab</em></tt>) -- особый случай. Они
          обрабатываются в <tt class="METHODNAME">QWidget::event()</tt>
          до того, как событие попадет в <tt class="METHODNAME">keyPressEvent()</tt>. Смысл этой комбинации
          заключается в передаче фокуса от одного виджета к другому, в
          заданной последовательности. Как правило, такое поведение нас
          вполне устраивает, но что делать, если необходимо реализовать
          иную семантику для данных комбинаций, например, чтобы
          клавишей Tab можно было оформлять отступы в <tt class="CLASSNAME">CodeEditor</tt>? Выход довольно прост, он
          заключается в перекрытии метода предка <tt class="METHODNAME">event()</tt>:
          <pre class="SCREEN">bool CodeEditor::event(QEvent *event) 
{ 
  if (event-&gt;type() == QEvent::KeyPress) { 
    QKeyEvent *keyEvent = (QKeyEvent *)event; 
    if (keyEvent-&gt;key() == Key_Tab) { 
      insertAtCurrentPosition( \t ); 
      return true; 
    } 
  }
  return QWidget::event(event); 
}
      
</pre>Если событие пришло от клавиатуры, то объект типа
          <tt class="CLASSNAME">QEvent</tt> приводится к типу
          <tt class="CLASSNAME">QKeyEvent</tt> и выполняется
          определение нажатой клавиши. Если это клавиша <tt class="PARAMETER"><em>Tab</em></tt>, то выполняются некоторые
          действия и функция возвращает результат <tt class="PARAMETER"><em>true</em></tt>, сообщая Qt о том, что событие
          обработано. Если функция вернет <tt class="PARAMETER"><em>false</em></tt>, то Qt попробует вызвать
          метод <tt class="METHODNAME">event()</tt> владельца.<br>
          <br>

          <p>Использование объектов <tt class="CLASSNAME">QAction</tt>
          дает более высокий уровень обслуживания событий. Например,
          если предположить, что <tt class="CLASSNAME">CodeEditor</tt>
          имеет два публичных слота <tt class="METHODNAME">goToBeginningOfLine()</tt> и <tt class="METHODNAME">goToBeginningOfDocument()</tt> и <tt class="CLASSNAME">CodeEditor</tt> назначен центральным виджетом для
          класса <tt class="CLASSNAME">MainWindow</tt>, то можно было
          бы обслуживать комбинации клавиш следующим образом:</p>
          <pre class="SCREEN">MainWindow::MainWindow(QWidget *parent, const char *name) 
    : QMainWindow(parent, name) 
{ 
  editor = new CodeEditor(this); 
  setCentralWidget(editor); 
  
  goToBeginningOfLineAct = new QAction(tr("Go to Beginning of Line"), 
                                          tr("Home"), this); 
  connect(goToBeginningOfLineAct, SIGNAL(activated()), 
          editor, SLOT(goToBeginningOfLine())); 
  goToBeginningOfDocumentAct = new QAction(tr("Go to Beginning of Document"), 
                                              tr("Ctrl+Home"), this); 
  connect(goToBeginningOfDocumentAct, SIGNAL(activated()), 
          editor, SLOT(goToBeginningOfDocument()));
  ...
}
      
</pre>Такой способ облегчает добавление пунктов в меню или кнопок на
панель инструментов, но об этом мы уже говорили в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">
          Главе 3</a>. Если в меню не появляются пункты, описанные
          через <tt class="CLASSNAME">QAction</tt>, то необходимо
          заменить <tt class="CLASSNAME">QAction</tt> на <tt class="CLASSNAME">QAccel</tt> -- класс, который используется
          <tt class="CLASSNAME">QAction</tt> для обработки нажатий на
          комбинации клавиш.<br>
          <br>

          <p>Разница между этими двумя подходами (перекрытие метода
          <tt class="METHODNAME">keyPressEvent()</tt> и использование
          <tt class="CLASSNAME">QAction</tt> или <tt class="CLASSNAME">QAccel</tt>) очень похожа на разницу между
          перекрытием метода <tt class="METHODNAME">resizeEvent()</tt>
          и использованием дочерних классов от <tt class="CLASSNAME">QLayout</tt>. Если вы создаете свой виджет,
          порождая его от <tt class="CLASSNAME">QWidget</tt>, то скорее
          всего вам подойдет первый вариант, связанный с написанием
          нескольких своих обработчиков, с жестко зашитым поведением.
          Но если вы предполагаете использовать уже готовый виджет, то
          более удобен высокоуровневый подход, связанный с
          использованием <tt class="CLASSNAME">QAction</tt>.</p>

          <p>Другой распространенный тип событий -- события от таймера.
          В то время, как большинство событий связаны с действиями
          пользователя, события от таймера генерируются системой и
          позволяют организовать обработку данных через определенные
          интервалы времени. Этот тип событий может использоваться,
          например, для создания мигающего курсора или просто для
          обновления изображения на экране.</p>

          <p>С целью демонстрации обслуживания событий от таймера,
          создадим виджет <tt class="CLASSNAME">Ticker</tt>. Он будет
          выводить строку текста и прокручивать ее справа-налево на
          один пиксель каждые 30 миллисекунд. Если ширина виджета
          больше ширины текста, то заданный текст будет нарисован
          столько раз, сколько уместится на виджете.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig7.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 7.1. Внешний вид виджета Ticker.</p>
            </div>
          </div><br>
          Начнем с файла заголовка:
          <pre class="SCREEN">#ifndef TICKER_H 
#define TICKER_H 

#include &lt;qwidget.h&gt; 

class Ticker : public QWidget 
{ 
  Q_OBJECT 
  Q_PROPERTY(QString text READ text WRITE setText) 
  
public: 
  Ticker(QWidget *parent = 0, const char *name = 0); 
  
  void setText(const QString &amp;newText); 
  QString text() const { return myText; } 
  QSize sizeHint() const; 
  
protected: 
  void paintEvent(QPaintEvent *event); 
  void timerEvent(QTimerEvent *event); 
  void showEvent(QShowEvent *event); 
  void hideEvent(QHideEvent *event); 
  
private: 
  QString myText; 
  int offset; 
  int myTimerId; 
}; 

#endif      
      
</pre>Мы реализуем четыре обработчика событий, при чем с тремя из них
(<tt class="METHODNAME">timerEvent(), showEvent()</tt> и
          <tt class="METHODNAME">hideEvent()</tt>) мы встречаемся
          впервые.<br>
          <br>

          <p>Перейдем к файлу с реализацией:</p>
          <pre class="SCREEN">#include &lt;qpainter.h&gt; 

#include "ticker.h" 

Ticker::Ticker(QWidget *parent, const char *name) 
    : QWidget(parent, name) 
{ 
  offset = 0; 
  myTimerId = 0; 
}
      
</pre>Конструктор инициализирует переменную <tt class="VARNAME">
          offset</tt> значением 0. Координата <tt class="VARNAME">x</tt>, с которой будет выводится текст, получается
          из переменной <tt class="VARNAME">offset</tt>.
          <pre class="SCREEN">void Ticker::setText(const QString &amp;newText) 
{ 
  myText = newText; 
  update(); 
  updateGeometry(); 
}
      
</pre>Функция <tt class="METHODNAME">setText()</tt> запоминает текст,
который должен выводиться на экран. Она вызывает <tt class="METHODNAME">update()</tt>, чтобы перерисовать виджет, а функцию
<tt class="METHODNAME">updateGeometry()</tt> -- чтобы известить
менеджер размещения об изменении "идеального" размера
виджета.
          <pre class="SCREEN">QSize Ticker::sizeHint() const 
{ 
  return fontMetrics().size(0, text()); 
}
      
</pre>Функция <tt class="METHODNAME">sizeHint()</tt> возвращает
"идеальные" размеры области, которые необходимы для вывода
текста. Функция <tt class="METHODNAME">QWidget::fontMetrics()</tt>
возвращает экземпляр класса <tt class="CLASSNAME">QFontMetrics</tt>, с
помощью которого можно получить информацию об используемом шрифте. В
данном случае он возвращает размеры области, в которую уместился бы
заданный текст.
          <pre class="SCREEN">void Ticker::paintEvent(QPaintEvent *) 
{ 
  QPainter painter(this); 
  
  int textWidth = fontMetrics().width(text()); 
  if (textWidth &lt; 1) 
    return; 
  int x = -offset; 
  while (x &lt; width()) { 
    painter.drawText(x, 0, textWidth, height(), 
                     AlignLeft | AlignVCenter, text()); 
    x += textWidth; 
  } 
}
      
</pre>Функция <tt class="METHODNAME">paintEvent()</tt> выводит текст, с
помощью вызова <tt class="METHODNAME">QPainter::drawText()</tt>. С
помощью <tt class="METHODNAME">fontMetrics()</tt> она определяет ширину
текста и затем рисует его столько раз, сколько потребуется, чтобы
заполнить виджет на всю ширину, учитывая значение переменной
          <tt class="VARNAME">offset</tt>.
          <pre class="SCREEN">void Ticker::showEvent(QShowEvent *) 
{ 
  myTimerId = startTimer(30);
}
      
</pre>Функция <tt class="METHODNAME">showEvent()</tt> запускает таймер.
Функция <tt class="METHODNAME">QObject::startTimer()</tt> возвращает
целое число, которое может быть использовано для идентификации таймера.
Класс <tt class="CLASSNAME">QObject</tt> может поддерживать несколько
независимых таймеров, каждый со своим собственным временным интервалом.
После вызова <tt class="METHODNAME">startTimer()</tt>, Qt будет
автоматически генерировать события от таймера через интервалы времени,
приблизительно равные 30-ти миллисекундам. Точность таймера зависит от
операционной системы.<br>
          <br>

          <p>В принципе, <tt class="METHODNAME">startTimer()</tt> можно
          было бы вызвать и в конструкторе, но мы не сделали этого с
          целью экономии ресурсов системы, поскольку нет большого
          смысла в событиях от таймера, когда виджет невидим.</p>
          <pre class="SCREEN">void Ticker::timerEvent(QTimerEvent *event) 
{ 
  if (event-&gt;timerId() == myTimerId) { 
    ++offset; 
    if (offset &gt;= fontMetrics().width(text())) 
      offset = 0; 
    scroll(-1, 0); 
  } else { 
    QWidget::timerEvent(event); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">timerEvent()</tt> -- это
обработчик событий от таймера и вызывается системой через заданные
интервалы времени. Она увеличивает величину смещения на 1, чтобы
создать эффект перемещения, до тех пор, пока смещение не сравняется с
шириной текста. Затем прокручивает содержимое виджета на 1 пиксель
влево, вызовом функции <tt class="METHODNAME">QWidget::scroll()</tt>.
Теоретически, вместо <tt class="METHODNAME">scroll()</tt> можно было бы
вызвать <tt class="METHODNAME">update()</tt>, но функция
          <tt class="METHODNAME">scroll()</tt> более эффективна и к
          тому же предотвращает эффект мерцания, потому что она просто
          перемещает существующее на экране изображение и генерирует
          событие "paint" для очень узкой области, в данном
          случае область перерисовки имеет ширину в 1 пиксель.<br>
          <br>

          <p>Если событие поступило не от того таймера, который нас
          интересует, то оно просто передается базовому классу.</p>
          <pre class="SCREEN">void Ticker::hideEvent(QHideEvent *) 
{ 
  killTimer(myTimerId); 
}
      
</pre>Функция <tt class="METHODNAME">hideEvent()</tt> вызывает
<tt class="METHODNAME">QObject::killTimer()</tt>, которая останавливает
таймер.<br>
          <br>

          <p>Если необходимо создать несколько таймеров, то обработка
          событий от них может стать слишком громоздкой. В таких
          ситуациях проще создавать объекты класса <tt class="CLASSNAME">QTimer</tt> для каждого таймера. <tt class="CLASSNAME">QTimer</tt> выдает сигнал <tt class="METHODNAME">timeout()</tt> по истечении каждого интервала
          времени, кроме того, он предоставляет возможность создания
          таймеров-будильников, которые срабатывают один раз.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="INSTALLINGEVENTFILTERS"></a>7.2.
          Установка фильтров событий.</h1>

          <p>Одна из замечательных особенностей модели обработки
          событий в Qt -- возможность одного экземпляра <tt class="CLASSNAME">QObject</tt> отслеживать события, предназначенные
          для другого экземпляра <tt class="CLASSNAME">QObject</tt> до
          того, как последний получит их.</p>

          <p>Предположим, что у нас имеется виджет <tt class="CLASSNAME">CustomerInfoDialog</tt>, собранный из нескольких
          <tt class="CLASSNAME">QLineEdit</tt>, и нам необходимо
          передавать фокус ввода, от одного к другому, нажатием на
          клавишу "пробел". Решение "в лоб" --
          создать дочерний класс от <tt class="CLASSNAME">QLineEdit</tt> и перекрыть обработчик события
          <tt class="METHODNAME">keyPressEvent()</tt>, в котором
          вызывать <tt class="METHODNAME">focusNextPrevChild()</tt>,
          примерно так:</p>
          <pre class="SCREEN">void MyLineEdit::keyPressEvent(QKeyEvent *event) 
{ 
  if (event-&gt;key() == Key_Space) 
    focusNextPrevChild(true); 
  else 
    QLineEdit::keyPressEvent(event); 
}
      
</pre>Однако это решение имеет массу недостатков. Поскольку
          <tt class="CLASSNAME">MyLineEdit</tt> -- это нестандартный
          виджет, то нам придется приложить некоторые усилия, чтобы
          интегрировать его с <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>, если захотим создавать
          формы с помощью визуального построителя. Кроме того, если
          потребуется, чтобы другие типы виджетов (такие как <tt class="CLASSNAME">QComboBoxe</tt> и <tt class="CLASSNAME">QSpinBox</tt>) так же поддерживали эту
          особенность, то мы будем вынуждены создать дочерние классы и
          для этих виджетов.<br>
          <br>

          <p>Более гибкое решение -- позволить <tt class="CLASSNAME">CustomerInfoDialog</tt> отслеживать события,
          отправляемые подчиненным виджетам и реализовать необходимую
          функциональность. Делается это с помощью фильтров событий.
          Установка фильтра событий производится в два этапа:</p>

          <ol type="1">
            <li>
              <p>Регистрация фильтра событий, вызовом функции
              <tt class="METHODNAME">installEventFilter()</tt> того
              объекта, которому предназначены события.</p>
            </li>

            <li>
              <p>Создание обработчика перехваченных событий <tt class="METHODNAME">eventFilter()</tt>.</p>
            </li>
          </ol>Регистрацию фильтра событий мы поместим в конструктор
          класса <tt class="CLASSNAME">CustomerInfoDialog</tt>:
          <pre class="SCREEN">CustomerInfoDialog::CustomerInfoDialog(QWidget *parent, 
                                       const char *name) 
    : QDialog(parent, name) 
{ 
  ...
  firstNameEdit-&gt;installEventFilter(this); 
  lastNameEdit-&gt;installEventFilter(this); 
  cityEdit-&gt;installEventFilter(this); 
  phoneNumberEdit-&gt;installEventFilter(this); 
}
      
</pre>После регистрации фильтра, все события, которые предназначены
объектам <tt class="VARNAME">firstNameEdit, lastNameEdit, cityEdit</tt>
и <tt class="VARNAME">phoneNumberEdit</tt>, сначала попадут в
обработчик <tt class="METHODNAME">CustomerInfoDialog::eventFilter()</tt>.<br>
          <br>

          <p>Ниже приводится исходный код функции <tt class="METHODNAME">eventFilter()</tt>:</p>
          <pre class="SCREEN">bool CustomerInfoDialog::eventFilter(QObject *target, QEvent *event) 
{ 
  if (target == firstNameEdit || target == lastNameEdit 
          || target == cityEdit || target == phoneNumberEdit) { 
    if (event-&gt;type() == QEvent::KeyPress) { 
      QKeyEvent *keyEvent = (QKeyEvent *)event; 
      if (keyEvent-&gt;key() == Key_Space) { 
        focusNextPrevChild(true); 
        return true; 
      } 
    } 
  } 
  return QDialog::eventFilter(target, event); 
}
      
</pre>Прежде всего мы убеждаемся, что событие отправлено одному из
<tt class="CLASSNAME">QLineEdit</tt>. Не забывайте, что базовый класс
<tt class="CLASSNAME">QDialog</tt> может контролировать и другие
виджеты. (В Qt 3.2 это не относится к <tt class="CLASSNAME">QDialog</tt>. Однако, другие классы, такие как
          <tt class="CLASSNAME">QMainWindow</tt>, отслеживают события
          некоторых из подчиненных виджетов по различным причинам.)<br>
          <br>

          <p>Если событие пришло от клавиатуры, то выполняется
          приведение к типу <tt class="CLASSNAME">QKeyEvent</tt> и
          проверяется -- какая клавиша нажата. Если нажата клавиша
          "пробел", то вызывается функция <tt class="METHODNAME">focusNextPrevChild()</tt>, которая передает
          фокус вводв следующему виджету и возвращается результат
          <tt class="PARAMETER"><em>true</em></tt>, сообщая Qt о том,
          что событие обработано. Если вернуть <tt class="PARAMETER"><em>false</em></tt>, то Qt передаст событие
          объекту назначения.</p>

          <p>Если событие порождено не клавишей "пробел", то
          управление передается функции <tt class="METHODNAME">eventFilter()</tt> базового класса.</p>

          <p>В Qt предусмотрены пять уровней, на которых событие может
          быть перехвачено и обработано:</p>

          <ol type="1">
            <li>
              <p><strong class="COMMAND">Обработка событий в
              функциях-обработчиках</strong></p>

              <p>Перекрытие обработчиков событий, таких как: <tt class="METHODNAME">mousePressEvent(), keyPressEvent()</tt> и
              <tt class="METHODNAME">paintEvent()</tt>, безусловно
              самый распространенный способ. Мы уже видели множество
              примеров тому.</p>
            </li>

            <li>
              <p><strong class="COMMAND">Перекрытие метода <tt class="METHODNAME">QObject::event()</tt>.</strong></p>

              <p>Внутри этого обработчика мы можем перехватывать
              события до того, как они попадут в специализированные
              функции-обработчики. Этот подход чаще всего используется
              для того, чтобы изменить реакцию виджета на клавишу
              табуляции, как это было показано ранее. Он так же
              используется для обработки событий, которые встречаются
              не так часто, например: <tt class="METHODNAME">LayoutDirectionChange</tt>. Если мы
              перекрываем функцию <tt class="METHODNAME">event()</tt>,
              то необходимо предусмотреть вызов обработчика <tt class="METHODNAME">event()</tt> базового класса, чтобы
              обработать события, которые нас не интересуют.</p>
            </li>

            <li>
              <p><strong class="COMMAND">Установка фильтра событий для
              <tt class="CLASSNAME">QObject</tt>.</strong></p>

              <p>После того, как фильтр будет зарегистрирован функцией
              <tt class="METHODNAME">installEventFilter()</tt>, все
              события, предназначающиеся указанному объекту, сначала
              будут попадать в обработчик <tt class="METHODNAME">eventFilter()</tt>. Такой способ мы
              использовали для перехвата событий от клавиши
              "пробел" в примере выше.</p>
            </li>

            <li>
              <p><strong class="COMMAND">Установка фильтра событий
              объекта <tt class="CLASSNAME">QApplication</tt>.</strong></p>

              <p>После регистрации фильтра, любое событие,
              предназначенное для любого объекта в приложении, будет
              сначала попадать в обработчик <tt class="METHODNAME">eventFilter()</tt>. Такой подход чаще всего
              используется в целях отладки и реализации в приложении
              скрытых сюрпризов (так называемых "пасхальных
              яиц").</p>
            </li>

            <li>
              <p><strong class="COMMAND">Создание дочернего класса от
              <tt class="CLASSNAME">QApplication</tt> и перекрытие
              метода <tt class="METHODNAME">notify()</tt>.</strong></p>

              <p>Qt вызывает <tt class="METHODNAME">QApplication::notify()</tt>, чтобы передать
              событие приложению. Таким способом можно перехватить
              любое событие до того, как оно попадет в фильтр событий.
              Вообще фильтры событий более удобны, поскольку
              допускается одновременное существование любого количества
              фильтров, а функция <tt class="METHODNAME">notify()</tt>
              может быть только одна.</p>
            </li>
          </ol><br>
          <br>

          <p>Большинство типов событий, включая события от мыши и
          клавиатуры, могут передаваться дальше. Если событие не было
          обработано по пути к объекту наначения, или самим объектом,
          то процесс обработки события повторяется, но на этот раз
          объектом назначения становится виджет-владелец. Так
          продолжается до тех пор, пока событие не будет обработано,
          либо пока событие не достигнет виджет самого верхнего
          уровня.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig7.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 7.2. Обработка событий в окне диалога.</p>
            </div>
          </div><br>
          На рисунке 7.2 показан порядок передачи события от
          подчиненного виджета к владельцу. Когда пользователь нажимает
          какую либо клавишу, событие сначала передается виджету,
          который владеет фокусом ввода, в данном случае это <tt class="CLASSNAME">QCheckBox</tt> в правом нижнем углу. Если виджет
          не обрабатывает событие, то оно передается виджету <tt class="CLASSNAME">QGroupBox</tt> и затем <tt class="CLASSNAME">QDialog</tt>.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="STAYINGRESPONSIVEDURINGINTENSIVEPROCESSING"></a>7.3.
          Сокращение времени отклика при длительной обработке
          данных.</h1>

          <p>С вызова функции <tt class="METHODNAME">QApplication::exec()</tt> начинается главный
          цикл обработки событий. Сначала Qt запускает несколько
          событий, чтобы отобразить и перерисовать виджеты. После этого
          в цикле постоянно выполняется проверка поступления новых
          событий и их передача виджетам приложения.</p>

          <p>Во время обработки одного события, в очередь могут
          поступать другие события. Если обработка какого либо события
          занимает продолжительное время, то это может отрицательно
          сказаться на времени отклика пользовательского интерфейса.
          Например, ни одно событие, поступившее от оконной системы во
          время сохранения файла на диск, не будет обработано до тех
          пор, пока файл не будет сохранен полностью. В течение
          времени, необходимого для сохранения файла, приложение никак
          не реагирует на запросы оконной системы.</p>

          <p>Как одно из возможных решений данной проблемы -- создавать
          многопоточные приложения, в которых один поток будет отвечать
          за пользовательский интерфейс, а другой -- за дисковые
          операции (или любые другие действия, выполняющиеся
          продолжительное время). В этом случае приложение будет
          исправно откликаться на действия пользователя даже во время
          выполнения длительной обработки данных. Этот подход мы будем
          обсуждать в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER17">Главе 17</a>.</p>

          <p>Более простое решение -- вызывать <tt class="METHODNAME">QApplication::processEvents()</tt> как можно
          чаще, во время длительных операций. Эта функция выполняет
          обработку событий, ожидающих в очереди, и затем возвращает
          управление в вызвавшую функцию. Фактически, <tt class="METHODNAME">QApplication::exec()</tt> -- это не более чем
          цикл <tt class="METHODNAME">while</tt>, в котором вызывается
          функция <tt class="METHODNAME">processEvents()</tt>.</p>

          <p>Ниже приводится пример того, как можно сократить время
          отклика приложения Spreadsheet, во время сохранения большого
          файла на диск (<a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P77">см. оригинальную
          версию</a>):</p>
          <pre class="SCREEN">bool Spreadsheet::writeFile(const QString &amp;fileName) 
{ 
  QFile file(fileName); 
  ... 
  for (int row = 0; row &lt; NumRows; ++row) { 
    for (int col = 0; col &lt; NumCols; ++col) { 
      QString str = formula(row, col); 
      if (!str.isEmpty()) 
        out &lt;&lt; (Q_UINT16)row &lt;&lt; (Q_UINT16)col &lt;&lt; str; 
    } 
    qApp-&gt;processEvents(); 
  } 
  return true; 
}
      
</pre>Однако в таких случаях существует одна опасность: пользователь
может закрыть приложение до того, как файл будет сохранен, или даже
может повторно вызывать процедуру сохранения файла. Эта проблема
решается довольно просто -- нужно заменить вызов
          <pre class="SCREEN">qApp-&gt;processEvents();      
      
</pre>на
          <pre class="SCREEN">qApp-&gt;eventLoop()-&gt;processEvents(QEventLoop::ExcludeUserInput);      
      
</pre>который заставит Qt игнорировать события от мыши и
клавиатуры.<br>
          <br>

          <p>Зачастую возникает необходимость вывести окно диалога,
          демонстрирующего ход выполнения длительной операции. Для
          подобных целей предназначен <tt class="CLASSNAME">QProgressDialog</tt>, который имеет индикатор
          хода выполнения. У него так же имеется кнопка <strong class="COMMAND">Cancel</strong>, с помощью которой пользователь
          может прервать операцию. Ниже представлен измененный вариант
          функции, которая демонстрирует пользователю ход операции
          сохранения файла:</p>
          <pre class="SCREEN">bool Spreadsheet::writeFile(const QString &amp;fileName) 
{ 
  QFile file(fileName); 
  ... 
  QProgressDialog progress(tr("Saving file..."), tr("Cancel"), 
                           NumRows); 
  progress.setModal(true); 
  for (int row = 0; row &lt; NumRows; ++row) { 
    progress.setProgress(row); 
    qApp-&gt;processEvents();      
    if (progress.wasCanceled()) { 
      file.remove(); 
      return false; 
    } 
    for (int col = 0; col &lt; NumCols; ++col) { 
      QString str = formula(row, col); 
      if (!str.isEmpty()) 
        out &lt;&lt; (Q_UINT16)row &lt;&lt; (Q_UINT16)col &lt;&lt; str; 
    } 
  } 
  return true; 
}
      
</pre>На этот раз функция создает <tt class="CLASSNAME">QProgressDialog</tt>, которому передает значение переменной
<tt class="VARNAME">NumRows</tt>, как общее число шагов. Затем, перед
сохранением каждой строки, вызывается <tt class="METHODNAME">setProgress()</tt>, которая обновляет индикатор хода
операции. Процент выполнения вычисляется компонентом
          <tt class="CLASSNAME">QProgressDialog</tt> самостоятельно.
          Затем вызывается <tt class="METHODNAME">QApplication::processEvents()</tt>, чтобы
          обновить изображение на экране, а заодно и проверить -- не
          нажал ли пользователь на кнопку <strong class="COMMAND">Cancel</strong>. Если кнопка <strong class="COMMAND">Cancel</strong> была нажата, то операция сохранения
          прерывается и файл удаляется.<br>
          <br>

          <p>Мы не вызываем метод <tt class="METHODNAME">show()</tt>
          диалога, потому что он самостоятельно выполняет это действие.
          Если операция выполняется достаточно быстро, возможно потому
          что файл получился очень коротким, или потому что компьютер
          обладает очень высокой производительностью, <tt class="CLASSNAME">QProgressDialog</tt> обнаружит это и вообще не
          будет выводить себя на экран.</p>

          <p>Есть еще один способ выполнения длительных операций. Он
          сильно отличается от того, что был описан выше. Вместо того,
          чтобы в процессе длительных операций предусматривать
          обработку пользовательского интерфейса, можно наоборот,
          производить длительные операции, когда приложение
          простаивает. Этот способ пригоден в тех случаях, когда
          операция может быть безопасно прервана и затем опять
          продолжена.</p>

          <p>В Qt такой вариант может быть реализован с помощью
          специального таймера -- таймера с нулевым интервалом. Такие
          таймеры генерируют события, когда очередь событий пуста. Ниже
          приводится пример реализации обработчика событий от такого
          таймера:</p>
          <pre class="SCREEN">void Spreadsheet::timerEvent(QTimerEvent *event) 
{ 
  if (event-&gt;timerId() == myTimerId) { 
    while (step &lt; MaxStep &amp;&amp; !qApp-&gt;hasPendingEvents()) { 
      performStep(step); 
      ++step; 
    } 
  } else { 
    QTable::timerEvent(event); 
  } 
}
      
</pre>Если функция <tt class="METHODNAME">hasPendingEvents()</tt>
возвращает <tt class="PARAMETER"><em>true</em></tt>, обработка данных
приостанавливается и управление передается обратно в Qt. Обработка
будет продолжена, когда Qt обслужит все события в очереди.
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER8"></a>Глава 8. Двух- и трехмерная
        графика.</h1>

        <p>В этой главе будут рассмотрены графические возможности Qt.
        Краеугольным камнем движка двухмерной графики в Qt является
        <tt class="CLASSNAME">QPainter</tt>. Он может использоваться
        для рисования на поверхности виджета (на экране), во внутреннем
        буфере (pixmap) и на принтере. Кроме того, в состав Qt входит
        класс <tt class="CLASSNAME">QCanvas</tt>, который позволяет
        создавать изображения из графических примитивов.</p>

        <p>В качестве альтернативы <tt class="CLASSNAME">QPainter</tt>
        и <tt class="CLASSNAME">QCanvas</tt>, можно рассматривать
        библиотеку OpenGL. Она предоставляет механизмы создания
        трехмерной графики, но может использоваться и для рисования
        двухмерных изображений. Код, использующий OpenGL очень легко
        интегрируется в приложения Qt, мы продемонстрируем это на
        конкретных примерах.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="PAINTINGWITHQPAINTER"></a>8.1.
          Рисование средствами QPainter.</h1>

          <p>Класс <tt class="CLASSNAME">QPainter</tt> используется для
          создания изображений на "графических устройствах",
          таких как виджеты или карты пикселей (pixmap). Чаще всего он
          используется при создании нестандартных виджетов, для
          придания им уникального, ни на что не похожего, внешнего
          вида. Однако этот класс может использоваться и для вывода
          графики на принтер, более подробно мы коснемся этого вопроса
          немного ниже.</p>

          <p><tt class="CLASSNAME">QPainter</tt> может рисовать простые
          геометрические фигуры: точки, линии, прямоугольники, эллипсы,
          дуги, сегменты круга, замкнутые ломаные (многоугольники) и
          кривые Безье. Он так же может отображать карты пикселей,
          рисунки и текст.</p>

          <p>Когда конструктору <tt class="CLASSNAME">QPainter</tt>
          передается устройство для рисования, он получает часть
          настроек от заданного устройства, оставшиеся параметры
          настройки заполняет значениями по-умолчанию. Эти настройки
          определяют способ рисования. Тремя наиболее важными
          характеристиками <tt class="CLASSNAME">QPainter</tt> являются
          <strong class="COMMAND">перо</strong> (pen), <strong class="COMMAND">кисть</strong> (brush) и <strong class="COMMAND">шрифт</strong> (font).</p>

          <ul>
            <li>
              <p><span class="emphasis"><em class="EMPHASIS">Перо</em></span> используется для рисования
              линий и границ геометрических фигур. Оно характеризуется
              такими параметрами, как: цвет, толщина, стиль рисования
              линий, стиль оформления концов линий и стиль оформления
              углов.</p>

              <div class="MEDIAOBJECT">
                <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.1.png"></p>

                <div class="CAPTION">
                  <p>Рисунок 8.1. Методы класса QPainter, для рисования
                  геометрических фигур.</p>
                </div>
              </div><br>

              <div class="MEDIAOBJECT">
                <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.2.png"></p>

                <div class="CAPTION">
                  <p>Рисунок 8.2. Стили пера.</p>
                </div>
              </div><br>
              <br>
              <br>
            </li>

            <li>
              <p><span class="emphasis"><em class="EMPHASIS">Кисть</em></span> -- это шаблон, которым
              заполняются геометрические фигуры. Кисти характеризуются
              цветом и стилем.</p>
            </li>

            <li>
              <p><span class="emphasis"><em class="EMPHASIS">Шрифт</em></span> используется для рисования
              текста. Шрифт может иметь огромное количество атрибутов,
              среди них: название и размер.</p>
            </li>
          </ul>Настройки этих характеристик могут быть выполнены с
          помощью функций <tt class="METHODNAME">setPen(),
          setBrush()</tt> и <tt class="METHODNAME">setFont()</tt>.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.3. Стили оформления концов линий и
              углов.</p>
            </div>
          </div><br>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.4.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.4. Стили кисти.</p>
            </div>
          </div><br>
          Ниже приводится код, который рисует эллипс, показанный на
          рисунке 8.5(а):
          <pre class="SCREEN">  QPainter painter(this); 
  painter.setPen(QPen(black, 3, DashDotLine)); 
  painter.setBrush(QBrush(red, SolidPattern)); 
  painter.drawEllipse(20, 20, 100, 60);      
      
</pre>Следующий код рисует сегмент круга, показанный на рисунке 8.5(б):
          <pre class="SCREEN">  QPainter painter(this); 
  painter.setPen(QPen(black, 5, SolidLine)); 
  painter.setBrush(QBrush(red, DiagCrossPattern)); 
  painter.drawPie(20, 20, 100, 60, 60 * 16, 270 * 16);
      
</pre>Последние два аргумента <tt class="METHODNAME">drawPie()</tt>
выражаются в 1/16 долях градуса.

          <div class="INFORMALTABLE">
            <a name="AEN4155"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="250" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.5a.png"></p>

                      <div class="CAPTION">
                        <p>(а) Эллипс.</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="250" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.5b.png"></p>

                      <div class="CAPTION">
                        <p>(б) Сегмент круга.</p>
                      </div>
                    </div><br>
                  </td>

                  <td width="250" align="center" valign="top">
                    <div class="MEDIAOBJECT">
                      <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.5c.png"></p>

                      <div class="CAPTION">
                        <p>(в) Кривая Безье.</p>
                      </div>
                    </div><br>
                  </td>
                </tr>

                <tr>
                  <td> </td>

                  <td width="250" align="center" valign="top">Рисунок 8.5 Примеры геометрических
                      фигур.</td>

                  <td> </td>
                </tr>
              </tbody>
            </table>
          </div>И наконец код, который рисует кривую Безье, показанную
          на рисунке 8.5(в):
          <pre class="SCREEN">  QPainter painter(this); 
  QPointArray points(4); 
  points[0] = QPoint(20, 80); 
  points[1] = QPoint(50, 20); 
  points[2] = QPoint(80, 20); 
  points[3] = QPoint(120, 80); 
  painter.setPen(QPen(black, 3, SolidLine)); 
  painter.drawCubicBezier(points);      
      
</pre>Текущее состояние <tt class="CLASSNAME">QPainter</tt> может быть
сохранено на стеке, вызовом <tt class="METHODNAME">save()</tt> и
восстановлено со стека, вызовом <tt class="METHODNAME">restore()</tt>.
Это может потребоваться в том случае, когда необходимо на время
изменить какие либо настройки, а затем восстановить их прежние
значения.<br>
          <br>

          <p>Кроме перечисленных выше характеристик (перо, кисть и
          шрифт), <tt class="CLASSNAME">QPainter</tt> имеет еще целый
          ряд параметров настройки:</p>

          <ul>
            <li>
              <p><span class="emphasis"><em class="EMPHASIS">Цвет
              фона</em></span> (background color), который используется
              для заливки геометрических фигур (под шаблоном, наносимым
              кистью), текста или рисунков, когда <span class="emphasis"><em class="EMPHASIS">background
              mode</em></span> имеет значение <tt class="PARAMETER"><em>OpaqueMode</em></tt> (по-умолчанию:
              <tt class="PARAMETER"><em>TransparentMode</em></tt>).</p>
            </li>

            <li>
              <p><span class="emphasis"><em class="EMPHASIS">Растровые
              операции</em></span> (raster operation) определяют, как
              новое изображение должно накладываться на существующее.
              По-умолчанию: <tt class="PARAMETER"><em>CopyROP</em></tt>, т.е. новое изображение
              (пиксели) просто копируется на устройство рисования,
              ранее находившееся там изображение игнорируется. В список
              растровых операций так же входят: <tt class="PARAMETER"><em>XorROP, NotROP, AndROP</em></tt> и
              <tt class="PARAMETER"><em>NotAndROP</em></tt>.</p>
            </li>

            <li>
              <p><span class="emphasis"><em class="EMPHASIS">Начальные
              координаты кисти</em></span> (brush origin) задают
              начальную точку рисования шаблона кисти, обычно это левый
              верхний угол виджета.</p>
            </li>

            <li>
              <p><span class="emphasis"><em class="EMPHASIS">Врезка</em></span> (clip region) определяет
              область устройства, на которой может производиться
              рисование. Операции рисования за пределами этой области
              -- игнорируются.</p>
            </li>

            <li>
              <p><span class="emphasis"><em class="EMPHASIS">Область
              просмотра</em></span> (viewport), <span class="emphasis"><em class="EMPHASIS">окно</em></span> (window)
              и <span class="emphasis"><em class="EMPHASIS">матрица
              преобразования</em></span> (world matrix) определяют
              отношения между логической системой координат <tt class="CLASSNAME">QPainter</tt> и системой координат
              физического устройства. Значения по-умолчанию принимаются
              таковыми, что эти две системы координат совпадают.</p>
            </li>
          </ul>Рассмотрим подробнее систему координат, которая задается
          параметрами <span class="emphasis"><em class="EMPHASIS">область просмотра</em></span> (viewport),
          <span class="emphasis"><em class="EMPHASIS">окно</em></span>
          (window) и <span class="emphasis"><em class="EMPHASIS">матрицей преобразования</em></span> (world
          matrix). (В данном случае, термин "окно" не имеет
          ничего общего с виджетом самого верхнего уровня, а
          "область просмотра" -- с классом <tt class="CLASSNAME">QScrollView</tt>.)<br>
          <br>

          <p>Понятия <span class="emphasis"><em class="EMPHASIS">область просмотра</em></span> и <span class="emphasis"><em class="EMPHASIS">окно</em></span> тесно
          связаны между собой. <span class="emphasis"><em class="EMPHASIS">Область просмотра</em></span> -- это произвольный
          прямоугольник, заданный физическими координатами.
          <span class="emphasis"><em class="EMPHASIS">Окно</em></span>
          -- описывает тот же самый прямоугольник, но уже в логических
          координатах. Когда выполняется рисование, то указываются
          логические координаты, которые затем преобразуются в
          физические.</p>

          <p>По-умолчанию координаты области просмотра и окна совпадают
          с системой координат физического устройства. Например, если
          устройство отображения представляет из себя виджет, с
          размерами 320 X 200, то и область просмотра и окно имеют те
          же самые размеры. В данном случае логическая и физическая
          системы координат совпадают.</p>

          <p>Подобный механизм дает возможность писать код, который не
          зависит от размера или разрешения устройства. Конечно же, мы
          и сами можем выполнять отображение логических координат в
          физические, но проще доверить эту работу классу <tt class="CLASSNAME">QPainter</tt>. Например, представим, что нам
          необходимо работать в системе координат, ограниченной
          прямоугольником от (-50, -50) до (+50, +50), когда точка с
          координатами (0, 0) находится в центре прямоугольника. В этом
          случае можно установить параетры окна следующим образом:</p>
          <pre class="SCREEN">  painter.setWindow(QRect(-50, -50, 100, 100));      
      
</pre>где первые два аргумента задают координаты верхнего левого угла
(-50, -50), последние два аргумента (100, 100)-- ширину и высоту
прямоугольника, соответственно. В данном случае, это означает, что
логические координаты (-50, -50) соответствуют физическим координатам
(0, 0), а логические координаты (+50, +50) -- физическим (320, 200).
Изменять параметры области просмотра нет необходимости.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.6.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.6. Преобразование логических координат в
              физические.</p>
            </div>
          </div><br>
          Теперь перейдем к матрице преобразований (world matrix). Она
          задает набор трансформаций, которые должны быть выполнены в
          дополнение к преобразованиям логических координат в
          физические. Это позволяет выполнять изменение масштаба,
          вращение и сдвиг рисуемых элементов. Например, если
          необходимо нарисовать текст под углом 45 градусов, то можно
          написать следующий код:
          <pre class="SCREEN">  QWMatrix matrix; 
  matrix.rotate(45.0); 
  painter.setWorldMatrix(matrix); 
  painter.drawText(rect, AlignCenter, tr("Revenue"));
      
</pre>Здесь логические координаты, передаваемые в <tt class="METHODNAME">drawText()</tt>, сначала подвергаются трансформации, а
затем отображаются в физические координаты.<br>
          <br>

          <p>Если указывается несколько трансформаций, то они
          применяются в порядке следования в исходном коде программы.
          Например, допустим, что необходимо повернуть изображение
          относительно точки с координатами (10, 20). Для этого можно
          задать следующий порядок трансформаций: сдвинуть окно так,
          чтобы центр вращения переместился в координаты (0, 0),
          повернуть изображение и затем выполнить обратный сдвиг:</p>
          <pre class="SCREEN">  QWMatrix matrix; 
  matrix.translate(-10.0, -20.0); 
  matrix.rotate(45.0); 
  matrix.translate(+10.0, +20.0); 
  painter.setWorldMatrix(matrix); 
  painter.drawText(rect, AlignCenter, tr("Revenue"));
      
</pre>Более простой способ -- воспользоваться методами класса
          <tt class="CLASSNAME">QPainter</tt> -- <tt class="METHODNAME">translate(), scale(), rotate()</tt> и <tt class="METHODNAME">shear()</tt>:
          <pre class="SCREEN">  painter.translate(-10.0, -20.0); 
  painter.rotate(45.0); 
  painter.translate(+10.0, +20.0); 
  painter.drawText(rect, AlignCenter, tr("Revenue"));
      
</pre>Но если необходимо воспользоваться одним и тем же набором
трансформаций несколько раз подряд, то вариант с <tt class="CLASSNAME">
          QWMatrix</tt> даст значительный выигрыш по времени.<br>
          <br>

          <p>При необходимости, матрицу преобразований можно сохранить
          вызовом <tt class="METHODNAME">saveWorldMatrix()</tt> и затем
          восстановить вызовом <tt class="METHODNAME">restoreWorldMatrix()</tt>.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.7.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.7. Внешний вид виджета <tt class="CLASSNAME">OvenTimer</tt>.</p>
            </div>
          </div><br>
          С целью демонстрации использования преобразований, рассмотрим
          код виджета <tt class="CLASSNAME">OvenTimer</tt> (таймер
          электропечи), который изображен на рисунке 8.7. Этот
          компонент моделирует поведение обычного таймера, которыми
          раньше, до появления цифровых часов и таймеров, снабжались
          электропечи. Пользователь может щелкнуть по риске на лимбе
          таймера, чтобы установить время ожидания, после чего ручка
          таймера начнет вращаться против часовой стрелки и по
          достижении нулевой отметки <tt class="CLASSNAME">OvenTimer</tt> выдаст сигнал <tt class="METHODNAME">timeout()</tt>.
          <pre class="SCREEN">class OvenTimer : public QWidget 
{ 
  Q_OBJECT 
  
public: 
  OvenTimer(QWidget *parent, const char *name = 0); 
  
  void setDuration(int secs);
  int duration() const; 
  void draw(QPainter *painter); 
  
signals: 
  void timeout(); 
  
protected: 
  void paintEvent(QPaintEvent *event); 
  void mousePressEvent(QMouseEvent *event); 

private: 
  QDateTime finishTime; 
  QTimer *updateTimer; 
  QTimer *finishTimer; 
};
      
</pre>Класс <tt class="CLASSNAME">OvenTimer</tt> порожден от класса
<tt class="CLASSNAME">QWidget</tt> и перекрывает два виртуальных метода
предка: <tt class="METHODNAME">paintEvent()</tt> и <tt class="METHODNAME">mousePressEvent()</tt>.
          <pre class="SCREEN">#include &lt;qpainter.h&gt; 
#include &lt;qpixmap.h&gt; 
#include &lt;qtimer.h&gt; 

#include &lt;cmath&gt; 
using namespace std; 

#include "oventimer.h" 

const double DegreesPerMinute = 7.0; 
const double DegreesPerSecond = DegreesPerMinute / 60; 
const int MaxMinutes = 45; 
const int MaxSeconds = MaxMinutes * 60; 
const int UpdateInterval = 10; 

OvenTimer::OvenTimer(QWidget *parent, const char *name) 
    : QWidget(parent, name) 
{ 
  finishTime = QDateTime::currentDateTime(); 
  updateTimer = new QTimer(this); 
  finishTimer = new QTimer(this); 
  connect(updateTimer, SIGNAL(timeout()), this, SLOT(update())); 
  connect(finishTimer, SIGNAL(timeout()), this, SIGNAL(timeout())); 
}
      
</pre>В конструкторе создаются два объекта <tt class="CLASSNAME">
          QTimer</tt>: <tt class="METHODNAME">updateTimer</tt> -- для
          обновления изображения виджета, и <tt class="METHODNAME">finishTimer</tt> -- для выдачи сигнала
          <tt class="METHODNAME">timeout()</tt>, по достижении нулевой
          отметки.
          <pre class="SCREEN">void OvenTimer::setDuration(int secs) 
{ 
  if (secs &gt; MaxSeconds) 
    secs = MaxSeconds; 
  finishTime = QDateTime::currentDateTime().addSecs(secs); 
  updateTimer-&gt;start(UpdateInterval * 1000, false); 
  finishTimer-&gt;start(secs * 1000, true); 
  update(); 
}
      
</pre>Функция <tt class="METHODNAME">setDuration()</tt> устанавливает
продолжительность действия таймера в секундах. Аргумент
          <tt class="PARAMETER"><em>false</em></tt>, передаваемый в
          функцию <tt class="METHODNAME">dateTimer-&gt;start()</tt>
          сообщает Qt о том, что это таймер с многократным
          срабатыванием. Период срабатывания таймера равен 10 секундам.
          Таймер <tt class="VARNAME">finishTimer</tt> должен сработать
          всего один раз, поэтому в функцию <tt class="METHODNAME">start()</tt>, этого объекта, передается аргумент
          <tt class="PARAMETER"><em>true</em></tt>. Конечное время
          работы таймера вычисляется сложением текущего времени,
          которое мы получаем вызовом <tt class="METHODNAME">QDateTime::currentDateTime()</tt> и времени
          ожидания.<br>
          <br>

          <p>Переменная <tt class="VARNAME">finishTime</tt> имеет тип
          <tt class="CLASSNAME">QDateTime</tt>, который в Qt отвечает
          за хранение даты и времени. Объекты этого типа становятся
          просто незаменимы в ситуациях, когда в отмеряемый интервал
          времени попадает граница суток.</p>
          <pre class="SCREEN">int OvenTimer::duration() const 
{ 
  int secs = QDateTime::currentDateTime().secsTo(finishTime); 
  if (secs &lt; 0) 
    secs = 0; 
  return secs; 
}
      
</pre>Функция <tt class="METHODNAME">duration()</tt> возвращает число
секунд, оставшихся до конца работы таймера.
          <pre class="SCREEN">void OvenTimer::mousePressEvent(QMouseEvent *event) 
{ 
  QPoint point = event-&gt;pos() - rect().center(); 
  double theta = atan2(-(double)point.x(), -(double)point.y()) 
                 * 180 / 3.14159265359; 
  setDuration((int)(duration() + theta / DegreesPerSecond)); 
  update(); 
}
      
</pre>Когда пользователь щелкает по лимбу таймера, вычисляется новый
интервал действия таймера. Затем в очередь ставится событие
"paint". Теперь, на вершине будет находиться выбранная
пользователем риска.
          <pre class="SCREEN">void OvenTimer::paintEvent(QPaintEvent *) 
{ 
  QPainter painter(this); 
  int side = QMIN(width(), height()); 
  painter.setViewport((width() - side) / 2, (height() - side) / 2, 
                      side, side); 
  painter.setWindow(-50, -50, 100, 100); 
  draw(&amp;painter); 
}
      
</pre>В обработчике <tt class="METHODNAME">paintEvent()</tt>
устанавливается область просмотра (viewport), которая по своим размерам
является наибольшей квадратной областью, которую можно разместить в
виджете, а затем настраивается окно -- прямоугольник (-50, -50, 100,
100), с размерами 100 X 100. Макрос <tt class="METHODNAME">QMIN()</tt>
возвращает наименьшее из двух аргументов.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.8.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.8. Внешний вид виджета <tt class="CLASSNAME">OvenTimer</tt> с различными размерами.</p>
            </div>
          </div><br>
          Если область просмотра (viewport) не сделать квадратной, то
          лимб таймера будет рисоваться в виде эллипса, когда форма
          фиджета будет далека от квадратной. Вообще, во избежание
          подобного рода деформаций, необходимо задавать настройки
          области просмотра и окна с одинаковыми отношениями
          сторон.<br>
          <br>

          <p>Размеры окна (-50, -50, 100, 100) выбирались из следующих
          соображений:</p>

          <ul>
            <li>
              <p>Функции рисования в <tt class="CLASSNAME">QPainter</tt>, принимают значения координат в
              виде целых чисел. Если выбрать размер окна слишком
              маленьким, то координаты некоторых точек не смогут быть
              указаны достаточно точно, из-за возникающей проблемы
              округления.</p>
            </li>

            <li>
              <p>Если выбрать размер окна слишком большим, то при
              необходимости рисования текста функцией <tt class="METHODNAME">drawText()</tt>, нам придется выбирать шрифт
              большого размера.</p>
            </li>
          </ul>В данной ситуации, выбор параметров (-50, -50, 100, 100)
          окна выглядит более предпочтительно, чем скажем (-5, -5, 10,
          10) или (-2000, -2000, 4000, 4000).<br>
          <br>

          <p>Теперь перейдем к функции <tt class="METHODNAME">draw()</tt>:</p>
          <pre class="SCREEN">void OvenTimer::draw(QPainter *painter) 
{ 
  static const QCOORD triangle[3][2] = { 
      { -2, -49 }, { +2, -49 }, { 0, -47 } 
  }; 
  QPen thickPen(colorGroup().foreground(), 2); 
  QPen thinPen(colorGroup().foreground(), 1); 
  
  painter-&gt;setPen(thinPen); 
  painter-&gt;setBrush(colorGroup().foreground()); 
  painter-&gt;drawConvexPolygon(QPointArray(3, &amp;triangle[0][0]));
      
</pre>Рисование виджета начинается с маленького треугольника, который
обозначает нулевую позицию вверху. Треугольник задается тремя, жестко
зашитыми парами координат. Собственно рисование производится функцией
<tt class="METHODNAME">drawConvexPolygon()</tt>. Треугольник можно было
бы нарисовать функцией <tt class="METHODNAME">drawPolygon()</tt>, но
если заранее известно, что многоугольник выпуклый, то вы можете
сэкономить несколько микросекунд, за счет использования функции
<tt class="METHODNAME">drawConvexPolygon()</tt>.<br>
          <br>

          <p>Одна из замечательных сторон механизма перехода от
          логических координат к физическим состоит в том, что мы можем
          жестко зашивать координаты точек в исходный код и при этом
          получать неплохие результаты, при изменении размеров
          виджета.</p>
          <pre class="SCREEN">  painter-&gt;setPen(thickPen); 
  painter-&gt;setBrush(colorGroup().light()); 
  painter-&gt;drawEllipse(-46, -46, 92, 92); 
  painter-&gt;setBrush(colorGroup().mid()); 
  painter-&gt;drawEllipse(-20, -20, 40, 40); 
  painter-&gt;drawEllipse(-15, -15, 30, 30);
      
</pre>Далее рисуются внешний и два внутренних круга. Внешний круг
заполняется цветом "light" (обычно -- белый), Внутренние
круги заполняются цветом "mid" (обычно -- серый).
          <pre class="SCREEN">  int secs = duration(); 
  painter-&gt;rotate(secs * DegreesPerSecond); 
  painter-&gt;drawRect(-8, -25, 16, 50); 
  
  for (int i = 0; i &lt;= MaxMinutes; ++i) { 
    if (i % 5 == 0) { 
      painter-&gt;setPen(thickPen); 
      painter-&gt;drawLine(0, -41, 0, -44); 
      painter-&gt;drawText(-15, -41, 30, 25, 
                        AlignHCenter | AlignTop, 
                        QString::number(i)); 
      } else { 
        painter-&gt;setPen(thinPen); 
        painter-&gt;drawLine(0, -42, 0, -44); 
      } 
      painter-&gt;rotate(-DegreesPerMinute); 
  } 
}
      
</pre>Затем рисуются рукоятка и риски на лимбе. Напротив каждой пятой
риски рисуется число, обозначающее количество минут. Функция
          <tt class="METHODNAME">rotate()</tt> вызывается для того,
          чтобы повернуть систему координат. В начальный момент, риска
          с отметкой "0" находилась вверху, теперь же она
          переместилась в точку, координаты которой зависят от
          оставшегося до срабатывания времени. Рукоятка рисуется после
          выполнения поворота, поскольку ее ориентация зависит от угла
          поворота.<br>
          <br>

          <p>В цикле <tt class="METHODNAME">for</tt>, по краю внешнего
          круга рисуются риски, а под ними -- числа, обозначающие
          количество минут, с шагом 5. В конце каждой итерации
          выполняется поворот системы координат по часовой стрелке на 7
          градусов, что соответствует одной минуте. Таким образом,
          каждая следующая риска будет рисоваться на своем месте, хотя
          координаты в <tt class="METHODNAME">drawLine()</tt> и
          <tt class="METHODNAME">drawText()</tt> задаются одни и те
          же.</p>

          <p>Тут есть еще одна проблема, которую мы не учли --
          мерцание. Виджет перерисовывается целиком каждые 10 секунд,
          что становится причиной появления эффекта подмаргивания
          изображения. Чтобы избавиться от нее, добавим двойную
          буферизацию. Для этого нужно передать родительскому
          конструктору флаг <tt class="PARAMETER"><em>WNoAutoErase</em></tt> и изменить <tt class="METHODNAME">paintEvent()</tt> следующим образом:</p>
          <pre class="SCREEN">void OvenTimer::paintEvent(QPaintEvent *event) 
{ 
  static QPixmap pixmap; 
  QRect rect = event-&gt;rect(); 
  
  QSize newSize = rect.size().expandedTo(pixmap.size()); 
  pixmap.resize(newSize); 
  pixmap.fill(this, rect.topLeft()); 
  
  QPainter painter(&amp;pixmap, this); 
  int side = QMIN(width(), height()); 
  painter.setViewport((width() - side) / 2 - event-&gt;rect().x(), 
                      (height() - side) / 2 - event-&gt;rect().y(), 
                      side, side); 
  painter.setWindow(-50, -50, 100, 100); 
  draw(&amp;painter); 
  bitBlt(this, event-&gt;rect().topLeft(), &amp;pixmap); 
}
      
</pre>На этот раз все рисование производится в буфере. Сначала
устанавливается размер будущего изображения, в соответствии с размером
области, которую необходимо перерисовать. Затем настраиваются область
просмотра и окно таким образом, что сам процесс рисования проходит
точно так же, как и раньше. Благодаря этому нам не надо вносить
изменения в функцию <tt class="METHODNAME">draw()</tt>. В завершение
обработки события "paint", готовый буфер переносится на
поверхность виджета, функцией <tt class="METHODNAME">bitBlt()</tt>.<br>

          <br>

          <p>Очень похоже на то, что мы описывали в разделе <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#DOUBLEBUFFERING">Двойная буферизация</a>, но с одним важным
          отличием: в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER5">Главе 5</a>, для выполнения
          сдвига, мы пользовались функцией <tt class="METHODNAME">translate()</tt>, теперь же, мы вычитаем
          координаты левого верхнего угла прямоугольника, требующего
          перерисовки, при настройке области просмотра. Использование
          <tt class="METHODNAME">translate()</tt> здесь было бы не
          очень удобным, поскольку преобразование должно быть выражено
          в логических координатах, в то время как событие поставляется
          с координатами физическими.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="GRAPHICSWITHQCANVAS"></a>8.2.
          Рисование средствами QCanvas.</h1>

          <p><tt class="CLASSNAME">QCanvas</tt> (Canvas -- холст,
          полотно, канва. прим. перев.) предоставляет более
          высокоуровневый интерфейс, чем <tt class="CLASSNAME">QPainter</tt>. Он может включать в себя элементы
          любой формы и имеет внутреннюю реализацию двойной
          буферизации. Для приложений, которые занимаются визуализацией
          информации или двухмерных игр, выбор <tt class="CLASSNAME">QCanvas</tt> может оказаться лучшим решением.</p>

          <p>Элементы, которые может отображать <tt class="CLASSNAME">QCanvas</tt>, являются экземплярами класса
          <tt class="CLASSNAME">QCanvasItem</tt> или его потомков. Qt
          содержит неплохой набор предопределенных графических
          элементов: <tt class="CLASSNAME">QCanvasLine,
          QCanvasRectangle, QCanvasPolygon, QCanvasPolygonalItem,
          QCanvasEllipse, QCanvasSpline, QCanvasSprite</tt> и
          <tt class="CLASSNAME">QCanvasText.</tt>.</p>

          <p>Классы <tt class="CLASSNAME">QCanvas</tt> и <tt class="CLASSNAME">QCanvasItem</tt> -- просто данные, они не имеют
          визуального представления. Для отображения <tt class="CLASSNAME">QCanvas</tt> и его элементов мы должны
          использовать виджет <tt class="CLASSNAME">QCanvasView</tt>.
          Такое разделение данных и средств их отображения, позволяет
          отображать один и тот же <tt class="CLASSNAME">QCanvas</tt> в
          нескольких <tt class="CLASSNAME">QCanvasView</tt>, причем
          каждый из них может визуализировать свою собственную часть
          <tt class="CLASSNAME">QCanvas</tt>, причем с применением
          различных матриц преобразования.</p>

          <p>Класс <tt class="CLASSNAME">QCanvas</tt> оптимизирован для
          работы с большим количеством элементов. Когда изменяется
          какой либо элемент, то перерисовывается только та часть,
          которая действительно изменилась. В нем так же заложен
          эффективный алгоритм проверки на пересечение. Поэтому,
          <tt class="CLASSNAME">QCanvas</tt> можно смело рассматривать
          как неплохую альтернативу подходам, связанным с перекрытием
          родительских методов <tt class="METHODNAME">paintEvent()</tt>
          и <tt class="METHODNAME">QScrollView::drawContents()</tt>.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.9.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.9. Внешний вид виджета <tt class="CLASSNAME">DiagramView</tt>.</p>
            </div>
          </div><br>
          С целью демонстрации основных приемов работы с <tt class="CLASSNAME">QCanvas</tt>, приведем исходный код виджета
          <tt class="CLASSNAME">DiagramView</tt> -- редактора
          структурных диаграмм. Виджет поддерживает два типа фигур
          (прямоугольники и линии) и имеет контекстное меню, которое
          дает возможность вставить новый элемент в диаграмму,
          копировать элементы в буфер обмена, вставлять их из буфера
          обмена, удалять и изменять их свойства.
          <pre class="SCREEN">class DiagramView : public QCanvasView 
{ 
  Q_OBJECT 
  
public: 
  DiagramView(QCanvas *canvas, QWidget *parent = 0, const char *name = 0); 
  
public slots: 
  void cut(); 
  void copy(); 
  void paste(); 
  void del(); 
  void properties(); 
  void addBox();
  void addLine(); 
  void bringToFront(); 
  void sendToBack();
      
</pre>Класс <tt class="CLASSNAME">DiagramView</tt> порожден от класса
<tt class="CLASSNAME">QCanvasView</tt>, который в свою очередь ведет
родословную от класса <tt class="CLASSNAME">QScrollView</tt>. Он
предоставляет массу публичных слотов, через которые возможно
взаимодействие с приложением. Эти слоты так же используются и самим
виджетом, для обслуживания контекстного меню.
          <pre class="SCREEN">protected: 
  void contentsContextMenuEvent(QContextMenuEvent *event); 
  void contentsMousePressEvent(QMouseEvent *event); 
  void contentsMouseMoveEvent(QMouseEvent *event); 
  void contentsMouseDoubleClickEvent(QMouseEvent *event); 
  
private: 
  void createActions(); 
  void addItem(QCanvasItem *item); 
  void setActiveItem(QCanvasItem *item); 
  void showNewItem(QCanvasItem *item); 
  
  QCanvasItem *pendingItem; 
  QCanvasItem *activeItem; 
  QPoint lastPos; 
  int minZ; 
  int maxZ; 
  
  QAction *cutAct; 
  QAction *copyAct; 
  ... 
  QAction *sendToBackAct; 
};
      
</pre>Приватные и защищенные члены класса мы будем описывать очень
коротко.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.10.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.10. Элементы <tt class="CLASSNAME">DiagramBox</tt> и <tt class="CLASSNAME">DiagramLine</tt>.</p>
            </div>
          </div><br>
          Помимо класса <tt class="CLASSNAME">DiagramView</tt>, нам
          необходимо определить два класса элеменов даграмм. Назовем
          эти классы как <tt class="CLASSNAME">DiagramBox</tt> и
          <tt class="CLASSNAME">DiagramLine</tt>.
          <pre class="SCREEN">class DiagramBox : public QCanvasRectangle 
{ 
public: 
  enum { RTTI = 1001 }; 
  
  DiagramBox(QCanvas *canvas); 
  ~DiagramBox(); 
  
  void setText(const QString &amp;newText);
  QString text() const { return str; } 
  void drawShape(QPainter &amp;painter);
  QRect boundingRect() const; 
  int rtti() const { return RTTI; } 

private: 
  QString str; 
};
      
</pre>Элемент диаграммы <tt class="CLASSNAME">DiagramBox</tt>
отображается в виде прямоугольника, с текстом внутри. Он наследует
значительную часть функциональности от своего предка -- класса
<tt class="CLASSNAME">QCanvasRectangle</tt>, в который добавлена
возможность рисования дополнительного текста и маленьких квадратиков по
углам, для индикации активности элемента. В реальном приложении, эти
квадратики можно было бы использовать для того, чтобы изменять размеры
прямоугольника, но в данном случае, для упрощения примера, мы не будем
этого делать.<br>
          <br>

          <p>Функция <tt class="METHODNAME">rtti()</tt> перекрывает
          родительский метод. Имя этой функции происходит от
          английского "run-time type identification" --
          "идентификация типа во время исполнения".
          Возвращаемый ею результат будет сравниваться с константой
          <tt class="VARNAME">RTTI</tt>, чтобы узнать -- является ли
          тот или иной элемент объектом класса <tt class="CLASSNAME">DiagramBox</tt>. Эту же проверку можно было бы
          выполнить с использованием механизма C++ <tt class="METHODNAME">dynamic_cast&lt;T&gt;()</tt>, но это ограничило
          бы нас в выборе компилятора C++.</p>

          <p>Число 1001 выбрано случайным образом. Приемлемо любое
          значение, большее 1000, единственное ограничение: в одном и
          том же приложении не должны использоваться разные классы с
          одинаковым значением RTTI.</p>
          <pre class="SCREEN">class DiagramLine : public QCanvasLine 
{ 
public: 
  enum { RTTI = 1002 }; 
  
  DiagramLine(QCanvas *canvas); 
  ~DiagramLine(); 
  
  QPoint offset() const { return QPoint((int)x(), (int)y()); } 
  void drawShape(QPainter &amp;painter); 
  QPointArray areaPoints() const; 
  int rtti() const { return RTTI; } 
};
      
</pre>Элемент диаграммы <tt class="CLASSNAME">DiagramLine</tt>
отображается в виде линии. Этот класс наследует функциональность класса
<tt class="CLASSNAME">QCanvasLine</tt>, в который добавлена возможность
отображения маленьких квадратиков на концах линии, для индикации
активности элемента.<br>
          <br>

          <p>Перейдем к обзору реализации этих трех классов:</p>
          <pre class="SCREEN">DiagramView::DiagramView(QCanvas *canvas, QWidget *parent, 
                         const char *name) 
    : QCanvasView(canvas, parent, name) 
{ 
  pendingItem = 0; 
  activeItem = 0; 
  minZ = 0; 
  maxZ = 0; 
  createActions(); 
}
      
</pre>Конструктор <tt class="METHODNAME">DiagramView</tt> в первом
аргументе получает указатель на <tt class="CLASSNAME">QCanvas</tt> и
передает его унаследованному конструктору.<br>
          <br>

          <p>В приватной функции <tt class="METHODNAME">createActions()</tt> создаются экземпляры
          <tt class="CLASSNAME">QAction</tt>. Мы уже рассматривали
          подобные функции в примерах ранее, поэтому реализацию этой
          функции мы опустим.</p>
          <pre class="SCREEN">void DiagramView::contentsContextMenuEvent(QContextMenuEvent *event) 
{ 
  QPopupMenu contextMenu(this); 
  if (activeItem) { 
    cutAct-&gt;addTo(&amp;contextMenu); 
    copyAct-&gt;addTo(&amp;contextMenu); 
    deleteAct-&gt;addTo(&amp;contextMenu); 
    contextMenu.insertSeparator(); 
    bringToFrontAct-&gt;addTo(&amp;contextMenu); 
    sendToBackAct-&gt;addTo(&amp;contextMenu); 
    contextMenu.insertSeparator(); 
    propertiesAct-&gt;addTo(&amp;contextMenu); 
  } else { 
    pasteAct-&gt;addTo(&amp;contextMenu); 
    contextMenu.insertSeparator(); 
    addBoxAct-&gt;addTo(&amp;contextMenu); 
    addLineAct-&gt;addTo(&amp;contextMenu); 
  } 
  contextMenu.exec(event-&gt;globalPos()); 
}
      
</pre>Чтобы создать контекстное меню, мы перекрыли обработчик
          <tt class="METHODNAME">contentsContextMenuEvent()</tt>
          родительского класса <tt class="CLASSNAME">QScrollView</tt>.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.11.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.11. Контекстное меню виджета <tt class="CLASSNAME">DiagramView</tt>.</p>
            </div>
          </div><br>
          Если к моменту поступления события был активизирован какой
          либо из элементов диаграммы, то меню будет содержать пункты,
          которые имеют отношение к выделенному элементу:
          <strong class="COMMAND">Cut, Copy, Delete, Bring to Front,
          Send to Back</strong> и <strong class="COMMAND">Properties</strong>. В противном случае меню будет
          состоять из трех пунктов: <strong class="COMMAND">Paste, Add
          Box</strong> и <strong class="COMMAND">Add Line</strong>.
          <pre class="SCREEN">void DiagramView::addBox() 
{ 
  addItem(new DiagramBox(canvas())); 
} 

void DiagramView::addLine() 
{ 
  addItem(new DiagramLine(canvas())); 
}
      
</pre>Слоты <tt class="METHODNAME">addBox()</tt> и <tt class="METHODNAME">addLine()</tt> создают элементы диаграммы
          <tt class="CLASSNAME">DiagramBox</tt> или <tt class="CLASSNAME">DiagramLine</tt>, соответственно, которые затем
          добавляются в виджет, с помощью <tt class="METHODNAME">addItem()</tt>.
          <pre class="SCREEN">void DiagramView::addItem(QCanvasItem *item) 
{ 
  delete pendingItem; 
  pendingItem = item; 
  setActiveItem(0); 
  setCursor(crossCursor); 
}
      
</pre>Приватная функция <tt class="METHODNAME">addItem()</tt> изменяет
внешний вид указателя мыши на крестик и записывает в переменную
<tt class="VARNAME">pendingItem</tt> указатель на вновь созданный
элемент. Этот элемент не будет видим на экране до тех пор, пока не
будет вызван его метод <tt class="METHODNAME">show()</tt>.<br>

          <br>

          <p>Когда пользователь выбирает пункт контекстного меню
          <strong class="COMMAND">Add Box</strong> или <strong class="COMMAND">Add Line</strong>, изменяется внешний вид указателя
          мыши, но элемент будет добавлен только когда он щелкнет по
          канве. <a name="P190"></a></p>
          <pre class="SCREEN">void DiagramView::contentsMousePressEvent(QMouseEvent *event) 
{ 
  if (event-&gt;button() == LeftButton &lt;&lt; pendingItem) { 
    pendingItem-&gt;move(event-&gt;pos().x(), event-&gt;pos().y()); 
    showNewItem(pendingItem); 
    pendingItem = 0; 
    unsetCursor(); 
  } else { 
    QCanvasItemList items = canvas()-&gt;collisions(event-&gt;pos()); 
    if (items.empty()) 
      setActiveItem(0); 
    else 
      setActiveItem(*items.begin()); 
  } 
  lastPos = event-&gt;pos(); 
}
      
</pre>Когда пользователь нажимает левую кнопку мыши и при этом курсор
отображается в виде крестика, то вставляемый элемент диаграммы уже
создан. Поэтому нам остается только вставить его в позицию курсора
мыши, сделать видимым и вернуть внешний виж курсовра в первоначальное
состояние.<br>
          <br>

          <p>Любой другой щелчок по канве интерпретируется как попытка
          выделить какой либо из элементов или наоборот, снять
          выделение. Функция <tt class="METHODNAME">collisions()</tt>
          возвращает список всех элементов, находящихся под указателем
          мыши. Первый из этого списка активизируется. Если список
          содержит несколько элементов, то первым в нем всегда будет
          стоять тот элемент, который отображается поверх других.</p>
          <pre class="SCREEN">void DiagramView::contentsMouseMoveEvent(QMouseEvent *event) 
{ 
  if (event-&gt;state() &amp; LeftButton) { 
    if (activeItem) { 
      activeItem-&gt;moveBy(event-&gt;pos().x() - lastPos.x(), 
                         event-&gt;pos().y() - lastPos.y()); 
      lastPos = event-&gt;pos();
      canvas()-&gt;update(); 
    } 
  } 
}
      
</pre>Пользователь может перемещать элементы диаграммы, удерживая их
левой кнопкой мыши. Каждый раз, когда виджет получает событие,
извещающее о перемещении мыши, мы сдвигаем элемент по горизонтали и
вертикали, на полученные расстояния и вызываем <tt class="METHODNAME">
          update()</tt> канвы. Всякий раз, когда изменяется содержимое
          канвы, мы должны вызывать метод <tt class="METHODNAME">update()</tt>, чтобы перерисовать виджет.
          <pre class="SCREEN">void DiagramView::contentsMouseDoubleClickEvent(QMouseEvent *event) 
{ 
  if (event-&gt;button() == LeftButton &amp;&amp; activeItem 
           &amp;&amp; activeItem-&gt;rtti() == DiagramBox::RTTI) { 
    DiagramBox *box = (DiagramBox *)activeItem; 
    bool ok; 
    
    QString newText = QInputDialog::getText( 
            tr("Diagram"), tr("Enter new text:"), 
            QLineEdit::Normal, box-&gt;text(), &amp;ok, this); 
    if (ok) { 
      box-&gt;setText(newText); 
      canvas()-&gt;update(); 
    } 
  } 
}
      
</pre>Когда пользователь выполняет двойной щелчок по элементу
диаграммы, вызывается функция <tt class="METHODNAME">rtti()</tt>, а
полученное от нее значение сравнивается с <tt class="VARNAME">
          DiagramBox::RTTI</tt> (1001).

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.12.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.12. Диалог изменения текста в элементе
              <tt class="CLASSNAME">DiagramBox</tt>.</p>
            </div>
          </div><br>
          Если это действительно <tt class="CLASSNAME">DiagramBox</tt>,
          то запускается <tt class="CLASSNAME">QInputDialog</tt>, что
          позволяет пользователю изменить текст, отображаемый внутри
          прямоугольника.
          <pre class="SCREEN">void DiagramView::bringToFront() 
{ 
  if (activeItem) { 
    ++maxZ; 
    activeItem-&gt;setZ(maxZ); 
    canvas()-&gt;update(); 
  } 
}
      
</pre>Слот <tt class="METHODNAME">bringToFront()</tt> перемещает
выбранный элемент поверх других элементов диаграммы. Это достигается за
счет записи значания, в координату <tt class="VARNAME">z</tt>
компонента, большего, чем у других. Если на канве, в тех же самых
координатах, находятся два или более компонентов, то тот, который имеет
большее значение координаты <tt class="VARNAME">z</tt> будет
отображаться поверх остальных.
          <pre class="SCREEN">void DiagramView::sendToBack() 
{ 
  if (activeItem) { 
    --minZ; 
    activeItem-&gt;setZ(minZ); 
    canvas()-&gt;update(); 
  } 
}
      
</pre>Слот <tt class="METHODNAME">sendToBack()</tt> перемещает
выбранный элемент ниже других. Это достигается за счет записи значания,
в координату <tt class="VARNAME">z</tt> компонента, меньшего, чем у
других.
          <pre class="SCREEN">void DiagramView::cut() 
{ 
  copy(); 
  del(); 
}
      
</pre>Реализация слота <tt class="METHODNAME">cut()</tt> достаточно
проста, и мы не будем его подробно описывать.
          <pre class="SCREEN">void DiagramView::copy() 
{ 
  if (activeItem) { 
    QString str; 
    
    if (activeItem-&gt;rtti() == DiagramBox::RTTI) { 
      DiagramBox *box = (DiagramBox *)activeItem; 
      str = QString("DiagramBox %1 %2 %3 %4 %5") 
            .arg(box-&gt;width()) 
            .arg(box-&gt;height()) 
            .arg(box-&gt;pen().color().name()) 
            .arg(box-&gt;brush().color().name()) 
            .arg(box-&gt;text()); 
    } else if (activeItem-&gt;rtti() == DiagramLine::RTTI) { 
      DiagramLine *line = (DiagramLine *)activeItem; 
      QPoint delta = line-&gt;endPoint() - line-&gt;startPoint(); 
      str = QString("DiagramLine %1 %2 %3") 
            .arg(delta.x()) 
            .arg(delta.y()) 
            .arg(line-&gt;pen().color().name()); 
    } 
    QApplication::clipboard()-&gt;setText(str); 
  } 
}
      
</pre>Слот <tt class="METHODNAME">copy()</tt> преобразует информацию об
элементе в строку и копирует ее в буфер обмена. Строка содержит все
необходимые сведения, чтобы потом можно было опять воссоздать элемент.
Например, прямоугольник черного цвета, с текстом "My Left
Foot" белого цвета, будет представлен в виде строки:
          <pre class="SCREEN">      DiagramBox 320 40 #000000 #ffffff My Left Foot
      
</pre>Нет необходимости беспокоиться о сохранении координат элемента.
Когда элемент вынимается из буфера обмена, он просто вставляется в
левый верхний угол канвы. Представление объекта в виде строки -- это
самый простой способ добавить поддержку буфера обмена. Безусловно,
буфер обмена может хранить и двоичные данные в произвольном формате, но
об этом мы поговорим в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER9">Главе 9</a>.
          <pre class="SCREEN">void DiagramView::paste() 
{ 
  QString str = QApplication::clipboard()-&gt;text(); 
  QTextIStream in(&amp;str); 
  QString tag; 
  
  in &gt;&gt; tag; 
  if (tag == "DiagramBox") { 
    int width; 
    int height; 
    QString lineColor; 
    QString fillColor; 
    QString text; 
     
    in &gt;&gt; width &gt;&gt; height &gt;&gt; lineColor &gt;&gt; fillColor; 
    text = in.read(); 
     
    DiagramBox *box = new DiagramBox(canvas()); 
    box-&gt;move(20, 20); 
    box-&gt;setSize(width, height); 
    box-&gt;setText(text); 
    box-&gt;setPen(QColor(lineColor)); 
    box-&gt;setBrush(QColor(fillColor)); 
    showNewItem(box); 
  } else if (tag == "DiagramLine") {
    int deltaX; 
    int deltaY; 
    QString lineColor; 
      
    in &gt;&gt; deltaX &gt;&gt; deltaY &gt;&gt; lineColor; 
      
    DiagramLine *line = new DiagramLine(canvas()); 
    line-&gt;move(20, 20); 
    line-&gt;setPoints(0, 0, deltaX, deltaY); 
    line-&gt;setPen(QColor(lineColor)); 
    showNewItem(line); 
  } 
}
      
</pre>Слот <tt class="METHODNAME">paste()</tt> пользуется услугами
<tt class="CLASSNAME">QTextIStream</tt>, для разбора содержимого строки
из буфера обмена. <tt class="CLASSNAME">QTextIStream</tt> отделяет поля
в строке по символу пробела, точно так же, как и <tt class="METHODNAME">cin</tt>. Поля считываются оператором
"&gt;&gt;", за исключением последнего, которое может
содержать пробелы. Чтобы прочитать последнее поле используется метод
<tt class="METHODNAME">QTextStream::read()</tt>, который возвращает
остаток строки.
          <pre class="SCREEN">void DiagramView::del() 
{ 
  if (activeItem) {
    QCanvasItem *item = activeItem; 
    setActiveItem(0); 
    delete item; 
    canvas()-&gt;update(); 
  } 
}
      
</pre>Слот <tt class="METHODNAME">del()</tt> удаляет активный элемент и
перерисовывает канву.
          <pre class="SCREEN">void DiagramView::properties() 
{ 
  if (activeItem) { 
    PropertiesDialog dialog; 
    dialog.exec(activeItem); 
  } 
}
      
</pre>Слот <tt class="METHODNAME">properties()</tt> запускает диалог
изменения свойств активного элемента. Класс <tt class="CLASSNAME">
          PropertiesDialog</tt> получает только указатель на элемент, и
          сам определяет -- какого типа элемент он получил, после чего
          выполняет все необходимые действия.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.13.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.13. Два варианта отображения диалога
              <tt class="CLASSNAME">PropertiesDialog</tt>.</p>
            </div>
          </div><br>
          Файлы <tt class="FILENAME">.ui</tt> и <tt class="FILENAME">.ui.h</tt> вы найдете на CD, сопровождающем книгу.
          <pre class="SCREEN">void DiagramView::showNewItem(QCanvasItem *item) 
{ 
  setActiveItem(item); 
  bringToFront(); 
  item-&gt;show(); 
  canvas()-&gt;update(); 
}
      
</pre>Функция <tt class="METHODNAME">showNewItem()</tt> активизирует
элемент диаграммы и делает его видимым.
          <pre class="SCREEN">void DiagramView::setActiveItem(QCanvasItem *item) 
{
  if (item != activeItem) { 
    if (activeItem) 
      activeItem-&gt;setActive(false); 
    activeItem = item; 
    if (activeItem) 
      activeItem-&gt;setActive(true); 
    canvas()-&gt;update(); 
  } 
}
      
</pre>Последняя функция <tt class="METHODNAME">setActiveItem()</tt>
сбрасывает признак активности у предыдущего активного элемента,
запоминает указатель на новый активный элемент и активизирует его.
Признак активности элемента хранится в классе <tt class="CLASSNAME">
          QCanvasItem</tt>. Qt не использует его, но предоставляет
          такую возможность для удобства разработчика. Мы используем
          этот признак, поскольку в нашем случае активные элементы
          рисуются несколько иначе, чем неактивные.<br>
          <br>

          <p>Перейдем к рассмотрению реализации классов <tt class="CLASSNAME">DiagramBox</tt> и <tt class="CLASSNAME">DiagramLine</tt>.</p>
          <pre class="SCREEN">const int Margin = 2; 

void drawActiveHandle(QPainter &amp;painter, const QPoint &amp;center) 
{ 
  painter.setPen(Qt::black); 
  painter.setBrush(Qt::gray); 
  painter.drawRect(center.x() - Margin, center.y() - Margin, 
                   2 * Margin + 1, 2 * Margin + 1); 
}
      
</pre>Функция <tt class="METHODNAME">drawActiveHandle()</tt> рисует
маленькие квадратики, для индикации активности элемента диаграммы.
          <pre class="SCREEN">DiagramBox::DiagramBox(QCanvas *canvas) 
    : QCanvasRectangle(canvas) 
{ 
  setSize(100, 60); 
  setPen(black); 
  setBrush(white); 
  str = "Text"; 
}
      
</pre>В конструкторе задаются начальные размеры прямоугольника 100 X
60, цвет пера (черный) и цвет кисти (белый). Цветом пера отображаются
границы прямоугольника и текст, цветом кисти заливается внутреннее
пространство прямоугольника.
          <pre class="SCREEN">DiagramBox::~DiagramBox() 
{ 
  hide(); 
}
      
</pre>Деструктор скрывает элемент диаграммы, вызовом метода
          <tt class="METHODNAME">hide()</tt>. Это необходимо для любых
          классов, порожденных от <tt class="CLASSNAME">QCanvasPolygonalItem</tt> (базовый класс для
          <tt class="CLASSNAME">QCanvasRectangle</tt>).
          <pre class="SCREEN">void DiagramBox::setText(const QString &amp;newText) 
{ 
  str = newText; 
  update(); 
}
      
</pre>Функция <tt class="METHODNAME">setText()</tt> записывает текст,
который должен отображаться в прямоугольнике, и вызывает
          <tt class="METHODNAME">QCanvasItem::update()</tt>, чтобы
          отобразить изменения на экране.
          <pre class="SCREEN">void DiagramBox::drawShape(QPainter &amp;painter) 
{ 
  QCanvasRectangle::drawShape(painter); 
  painter.drawText(rect(), AlignCenter, text()); 
  if (isActive()) { 
    drawActiveHandle(painter, rect().topLeft()); 
    drawActiveHandle(painter, rect().topRight()); 
    drawActiveHandle(painter, rect().bottomLeft()); 
    drawActiveHandle(painter, rect().bottomRight()); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">drawShape()</tt> перекрывает метод
класса <tt class="CLASSNAME">QCanvasPolygonalItem</tt>, чтобы
нарисовать текст и маленькие квадратики по углам, если данный элемент
диаграммы активен. Сам прямоугольник рисуется родительским методом.
          <pre class="SCREEN">QRect DiagramBox::boundingRect() const 
{ 
  return QRect((int)x() - Margin, (int)y() - Margin, 
               width() + 2 * Margin, height() + 2 * Margin); 
}
      
</pre>Функция <tt class="METHODNAME">boundingRect()</tt> перекрывает
метод класса <tt class="CLASSNAME">QCanvasItem</tt>. Она вызывается
классом <tt class="CLASSNAME">QCanvas</tt>, для проверки наложения
одних элементов на другие и оптимизации перерисовки. Возвращаемые
размеры должны быть не меньше тех, которые получает
          <tt class="METHODNAME">drawShape()</tt>.<br>
          <br>

          <p>Значение, которое возвращает родительский метод, нас не
          устраивает потому, что он не учитывает размеры маленьких
          квадратиков, рисуемых по углам активного элемента.</p>
          <pre class="SCREEN">DiagramLine::DiagramLine(QCanvas *canvas) 
    : QCanvasLine(canvas) 
{ 
  setPoints(0, 0, 0, 99); 
}
      
</pre>Конструктор <tt class="METHODNAME">DiagramLine</tt> задает
координаты точек, между которыми будет нарисована линия: (0, 0) и (0,
99). В результате получается вертикальная линия, длиной в 100 пикселей.
          <pre class="SCREEN">DiagramLine::~DiagramLine() 
{ 
  hide(); 
}
      
</pre>Опять же, в деструкторе необходимо скрыть элемент.
          <pre class="SCREEN">void DiagramLine::drawShape(QPainter &amp;painter) 
{ 
  QCanvasLine::drawShape(painter); 
  if (isActive()) { 
    drawActiveHandle(painter, startPoint() + offset()); 
    drawActiveHandle(painter, endPoint() + offset()); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">drawShape()</tt> перекрывает
родительский метод, чтобы нарисовать маленькие квадратики на концах
линии, если элемент активен. Сама линия рисуется средствами
родительского класса. Реализация функции <tt class="METHODNAME">
          offset()</tt> находится внутри определения класса <tt class="CLASSNAME">DiagramLine</tt>. Она возвращает положение
          элемента на канве.
          <pre class="SCREEN">QPointArray DiagramLine::areaPoints() const 
{ 
  const int Extra = Margin + 1; 
  QPointArray points(6); 
  QPoint pointA = startPoint() + offset(); 
  QPoint pointB = endPoint() + offset(); 
  
  if (pointA.x() &gt; pointB.x()) 
    swap(pointA, pointB); 
  
  points[0] = pointA + QPoint(-Extra, -Extra); 
  points[1] = pointA + QPoint(-Extra, +Extra); 
  points[3] = pointB + QPoint(+Extra, +Extra); 
  points[4] = pointB + QPoint(+Extra, -Extra); 
  if (pointA.y() &gt; pointB.y()) { 
    points[2] = pointA + QPoint(+Extra, +Extra); 
    points[5] = pointB + QPoint(-Extra, -Extra); 
  } else { 
    points[2] = pointB + QPoint(-Extra, +Extra); 
    points[5] = pointA + QPoint(+Extra, -Extra); 
  } 
  return points; 
}
      
</pre>Функция <tt class="METHODNAME">areaPoints()</tt> играет роль,
аналогичную <tt class="METHODNAME">boundingRect()</tt> класса
          <tt class="CLASSNAME">DiagramBox</tt>. Аппроксимация области,
          принадлежащей диагональной линии, прямоугольником будет
          слишком грубым приближением. Потому необходимо перекрыть
          родительский метод и вернуть более точные границы области
          рисования элемента. В принципе, реализация метода в классе
          <tt class="CLASSNAME">QCanvasLine</tt> уже возвращает
          приемлемые границы, но она не учитывает маленькие квадратики,
          которые рисуются у активных элементов.<br>
          <br>

          <p>Первое, что делает функция -- сохраняет координаты точек
          во временных переменных <tt class="VARNAME">pointA</tt> и
          <tt class="VARNAME">pointB</tt>, а затем проверяет --
          находится ли точка <tt class="VARNAME">pointA</tt> левее
          точки <tt class="VARNAME">pointB</tt> и меняет их местами,
          если это необходимо, с помощью функции <tt class="METHODNAME">swap()</tt> (определена в <tt class="FILENAME">&lt;algorithm&gt;</tt>). После этого она выполняет
          различные действия для ниспадающих и восстающих линий.</p>

          <p>Границы области рисования линии всегда представляются в
          виде 6 точек, но их координаты существенно зависят от того --
          ниспадающая линия или восстающая. Однако, координаты 4-х
          точек из 6-ти (0, 1, 3 и 4) всегда одинаковы для обоих
          случаев. Например, точки 0 и 1 всегда определяют левый
          верхний и левый нижний углы конца A, а точка 2 задает правый
          нижний угол для восстающих линий на конце A и левый нижний
          угол для ниспадающих линий на конце B.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.14.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.14. Границы области рисования линий
              <tt class="CLASSNAME">DiagramLine</tt>.</p>
            </div>
          </div><br>
          При рассмотрении кода, который мы написали, вы наверняка
          заметили, что виджет <tt class="CLASSNAME">DiagramView</tt>
          реализует достаточно большой объем функциональности,
          отвечающей за выделение элементов и их перемещение по канве,
          а так же предоставляет контекстное меню для взаимодействия с
          пользователем.<br>
          <br>

          <p>Одна деталь, которую мы опустили -- пользователь не может
          изменить размеры элемента, манипулируя маленькими
          квадратиками. Если бы мы хотели добавить такую возможность,
          то скорее всего нам пришлось бы сделать все немного иначе.
          Вместо того, чтобы рисовать квадратики в <tt class="METHODNAME">drawShape()</tt>, нам скорее всего пришлось бы
          сделать их самостоятельными элементами канвы. И изменять
          внешний вид указателя мыши, вызовом <tt class="METHODNAME">setCursor()</tt>, когда он находится над
          квадратиком, но для этого, сначала потребовалось бы вызвать
          <tt class="METHODNAME">setMouseTracking(true)</tt>, потому
          что обычно Qt передает события перемещения мыши только тогда,
          когда какая либо кнопка мыши удерживается в нажатом
          состоянии.</p>

          <p>Кроме того, можно было бы расширить набор элементов
          диаграмм, сделать возможным выделение нескольких элементов
          диаграммы одновременно и добавить возможность объединения
          элементов в группы. Статья "Canvas Item Groupies",
          в ежеквартальнике <span class="emphasis"><em class="EMPHASIS">Qt Quarterly</em></span> ( <a href="http://doc.trolltech.com/qq/qq05-canvasitemgrouping.html" target="_top">http://doc.trolltech.com/qq/qq05-canvasitemgrouping.html</a>),
             описывает один из приемов реализации подобных
             возможностей.</p>

          <p>В этом разделе мы предоставили пример работающего кода,
          использующего функциональность классов <tt class="CLASSNAME">QCanvas</tt> и <tt class="CLASSNAME">QCanvasView</tt>, но не раскрыли всех
          возможностей класса <tt class="CLASSNAME">QCanvas</tt>.
          Например, элементы могут перемещаться по канве, если им
          указать скорость перемещения вызовом метода <tt class="METHODNAME">setVelocity()</tt>. За подробной информацией
          обращайтесь к сопроводительной документации.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="PRINTING"></a>8.3. Вывод на
          печать.</h1>

          <p>Процедура вывода изображений на печать в Qt очень похожа
          на рисование по поверхности виджетов. Вкратце, процесс печати
          можно представить следующими шагами:</p>

          <ol type="1">
            <li>
              <p>Создается экземпляр класса <tt class="CLASSNAME">QPrinter</tt>, который будет представлять
              "устройство для рисования".</p>
            </li>

            <li>
              <p>Вызывается функция <tt class="METHODNAME">QPrinter::setup()</tt>, которая покажет
              пользователю диалог выбора принтера.</p>
            </li>

            <li>
              <p>Создается экземпляр класса <tt class="CLASSNAME">QPainter</tt>, который будет
              взаимодействовать с объектом <tt class="CLASSNAME">QPrinter</tt>.</p>
            </li>

            <li>
              <p>Средствами <tt class="CLASSNAME">QPainter</tt>
              рисуется изображение на странице.</p>
            </li>

            <li>
              <p>Вызывается метод <tt class="METHODNAME">QPrinter::newPage()</tt>, чтобы прокрутить
              страницу.</p>
            </li>

            <li>
              <p>Повторять действия, описанные в пунктах 4 и 5, пока не
              будут отпечатаны все страницы.</p>
            </li>
          </ol>В операционных системах Windows и Mac OS X, <tt class="CLASSNAME">QPrinter</tt> использует системные драйверы. В
          Unix страницы генерируются в формате PostScript и затем
          передаются устройству печати <tt class="FILENAME">lp</tt> или
          <tt class="FILENAME">lpr</tt> (или любой другой программе,
          которая будет назначена вызовом <tt class="METHODNAME">QPrinter::setPrintProgram()</tt>).

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.15.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.15. Пример вывода на печать виджетов
              <tt class="CLASSNAME">OvenTimer</tt>, <tt class="CLASSNAME">QCanvas</tt> и <tt class="CLASSNAME">QImage</tt>.</p>
            </div>
          </div><br>
          Начнем обсуждение с простого примера, который печатает одну
          страницу. Для начала напечатаем виджет <tt class="CLASSNAME">OvenTimer</tt>:
          <pre class="SCREEN">void PrintWindow::printOvenTimer(OvenTimer *ovenTimer) 
{ 
  if (printer.setup(this)) { 
    QPainter painter(&amp;printer); 
    QRect rect = painter.viewport(); 
    int side = QMIN(rect.width(), 
    rect.height()); 
    painter.setViewport(0, 0, side, side); 
    painter.setWindow(-50, -50, 100, 100); 
    ovenTimer-&gt;draw(&amp;painter); 
  } 
}
      
</pre>Здесь мы исходим из того, что класс <tt class="CLASSNAME">
          PrintWindow</tt> содержит переменную-член <tt class="VARNAME">printer</tt>, класса <tt class="CLASSNAME">QPrinter</tt>. В противном случае можно было бы
          создать экземпляр <tt class="CLASSNAME">QPrinter</tt> на
          стеке, но в этом случае у нас отсутствовала бы возможность
          сохранить пользовательские настройки принтера.<br>
          <br>

          <p>Мы вызываем <tt class="METHODNAME">setup()</tt>, чтобы
          запустить диалог выбора принтера. Она возвращает <tt class="PARAMETER"><em>true</em></tt>, если пользователь нажал на
          кнопку <strong class="COMMAND">OK</strong>. После вызова
          <tt class="METHODNAME">setup()</tt>, объект <tt class="CLASSNAME">QPrinter</tt> готов к работе.</p>

          <p>Далее создается <tt class="CLASSNAME">QPainter</tt>,
          который будет рисовать на <tt class="CLASSNAME">QPrinter</tt>. Потом настраивается область
          просмотра (viewport) и назначается система координат окна
          (-50, -50, 100, 100) -- прямоугольник, который ожидает
          получить <tt class="CLASSNAME">OvenTimer</tt>, и в завершение
          выполняется рисование виджета, вызовом функции <tt class="METHODNAME">draw()</tt>. Если не установить размеры области
          просмотра, то виджет <tt class="CLASSNAME">OvenTimer</tt>
          будет вытянут на всю высоту страницы.</p>

          <p>По-умолчанию <tt class="CLASSNAME">QPainter</tt>
          устанавливает размеры окна такими, чтобы они соответствовали
          разрешению экрана (обычно где-то между 72 и 100 точками на
          дюйм), но в данном случае это не имеет большого значения, так
          как мы сами установили систему координат окна.</p>

          <p>Пример вывода на печать виджета <tt class="CLASSNAME">OvenTimer</tt> не имеет особой практической
          ценности, потому что он предназначен, в первую очередь, для
          вывода на экран и взаимодействия с пользователем. Но для
          других виджетов, таких как <tt class="CLASSNAME">Plotter</tt>, который был разработан нами в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER5">Главе 5</a>, этот пример приобретает
          определенный смысл.</p>

          <p>Более практичный пример -- вывод на печать <tt class="CLASSNAME">QCanvas</tt>. Приложения, которые его используют,
          очень часто нуждаются в возможности вывода на печать того,
          что нарисует пользователь.</p>
          <pre class="SCREEN">void PrintWindow::printCanvas(QCanvas *canvas) 
{ 
  if (printer.setup(this)) { 
    QPainter painter(&amp;printer); 
    QRect rect = painter.viewport(); 
    QSize size = canvas-&gt;size(); 
    size.scale(rect.size(), QSize::ScaleMin); 
    painter.setViewport(rect.x(), rect.y(), 
                        size.width(), size.height()); 
    painter.setWindow(canvas-&gt;rect()); 
    painter.drawRect(painter.window()); 
    painter.setClipRect(painter.viewport()); 
    
    QCanvasItemList items = canvas-&gt;collisions(canvas-&gt;rect()); 
    QCanvasItemList::const_iterator it = items.end(); 
    while (it != items.begin()) { 
      --it; 
      (*it)-&gt;draw(painter); 
    } 
  } 
}
      
</pre>На этот раз мы установили систему координат окна в соответствии с
размерами канвы и ограничили область просмотра тем же самым
соотношением сторон. Для этого мы использовали функцию
          <tt class="METHODNAME">QSize::scale()</tt>, задав в качестве
          второго аргумента <tt class="METHODNAME">ScaleMin</tt>.
          Например, если канва имела размер 640 X 480, а область
          просмотра <tt class="CLASSNAME">QPainter</tt> -- 5000 X 5000,
          в результате получится область просмотра с размерами 5000 X
          3750.<br>
          <br>

          <p>Функция <tt class="METHODNAME">collisions()</tt> возвратит
          список видимых элементов канвы, отсортированный по значению
          координаты <tt class="VARNAME">z</tt>. Список просматривается
          в цикле, начиная с конца, и выполняется рисование элементов
          списка вызовом <tt class="METHODNAME">QCanvasItem::draw()</tt>. Таким образом, чем
          выше в списке стоит элемент, тем позднее он будет
          нарисован.</p>

          <p>Третий пример -- печать картинки из <tt class="CLASSNAME">QImage</tt>.</p>
          <pre class="SCREEN">void PrintWindow::printImage(const QImage &amp;image) 
{ 
  if (printer.setup(this)) { 
    QPainter painter(&amp;printer); 
    QRect rect = painter.viewport(); 
    QSize size = image.size(); 
    size.scale(rect.size(), QSize::ScaleMin); 
    painter.setViewport(rect.x(), rect.y(), 
                        size.width(), size.height()); 
    painter.setWindow(image.rect()); 
    painter.drawImage(0, 0, image); 
  } 
}
      
</pre>Мы установили размеры окна в соответствии с размерами изображения
и размеры области просмотра (viewport), чтобы соблюсти отношения
сторон, после чего нарисовали изображение, начиная с позиции (0,
0).<br>
          <br>

          <p>Печать компонентов, которые занимают не более одной
          страницы, достаточно проста. Но нередко приходится
          сталкиваться с необходимостью вывода на печать
          многостраничных документов. В таких случаях нужно вывести на
          печать одну страницу, затем вызвать функцию <tt class="METHODNAME">newPage()</tt> и напечатать следующую страницу.
          Однако здесь возникает проблема определения окончания каждой
          из страниц.</p>

          <p>Qt предлагает два варианта вывода на печать
          многостраничных документов:</p>

          <ul>
            <li>
              <p>Можно "перегнать" документ в формат HTML и
              вывести его средствами <tt class="CLASSNAME">QSimpleRichText</tt>.</p>
            </li>

            <li>
              <p>Можно выполнять перевод страниц вручную.</p>
            </li>
          </ul>Далее мы рассмотрим оба варианта.<br>
          <br>

          <p>В качестве примера напечатаем справочник цветовода,
          который содержит названия цветов и их краткое описание.
          Каждая статья справочника хранится в виде <span class="emphasis"><em class="EMPHASIS">"название:
          описание"</em></span>, например:</p>
          <pre class="SCREEN">      Miltonopsis santanae: Самая опасная разновидность орхидеи.
      
</pre>Поскольку каждая статья представлена одной строкой, то весь
справочник можно представить как список строк -- <tt class="CLASSNAME">
          QStringList</tt>.<br>
          <br>

          <p>Следующий фрагмент кода выводит на печать содержимое
          справочника, предварительно "перегнав" его в формат
          HTML:</p>
          <pre class="SCREEN">void PrintWindow::printFlowerGuide(const QStringList &amp;entries) 
{ 
  QString str; 
  QStringList::const_iterator it = entries.begin(); 
  while (it != entries.end()) { 
    QStringList fields = QStringList::split(": ", *it); 
    QString title = QStyleSheet::escape(fields[0]); 
    QString body = QStyleSheet::escape(fields[1]); 
    
    str += "&lt;table width=\"100%\" border=1 cellspacing=0&gt;\n" 
           "&lt;tr&gt;&lt;td bgcolor=\"lightgray\"&gt;&lt;font size=\"+1\"&gt;" 
           "&lt;b&gt;&lt;i&gt;" + title + "&lt;/i&gt;&lt;/b&gt;&lt;/font&gt;\n&lt;tr&gt;&lt;td&gt;" 
           + body + "\n&lt;/table&gt;\n&lt;br&gt;\n";
    ++it; 
  } 
  printRichText(str); 
}
      
</pre>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.16.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.16. Пример вывода на печать справочника
              цветовода, с помощью <tt class="CLASSNAME">QSimpleRichText</tt>.</p>
            </div>
          </div><br>
          На первом шаге выполняется преобразование справочника в
          формат HTML. Каждая статья представляется в виде HTML таблицы
          с двумя ячейками. Функция <tt class="METHODNAME">QStyleSheet::escape()</tt> заменяет специальные
          символы <strong class="COMMAND">'&amp;',
          '&lt;', '&gt;'</strong> их аналогами HTML
          ("&amp;amp;", "&amp;lt;",
          "&amp;gt;"). И в заключение выводим на печать то,
          что получилось, вызовом <tt class="METHODNAME">printRichText()</tt>.
          <pre class="SCREEN">const int LargeGap = 48; 

void PrintWindow::printRichText(const QString &amp;str) 
{ 
  if (printer.setup(this)) { 
    QPainter painter(&amp;printer); 
    int pageHeight = painter.window().height() - 2 * LargeGap; 
    QSimpleRichText richText(str, bodyFont, "", 0, 0, 
                             pageHeight); 
    richText.setWidth(&amp;painter, painter.window().width()); 
    int numPages = (int)ceil((double)richText.height() 
                             / pageHeight); 
    int index; 
    
    for (int i = 0; i &lt; (int)printer.numCopies(); ++i) { 
      for (int j = 0; j &lt; numPages; ++j) { 
        if (i &gt; 0 || j &gt; 0) 
          printer.newPage(); 
        if (printer.pageOrder() 
                == QPrinter::LastPageFirst) { 
          index = numPages - j - 1;
        } else { 
          index = j; 
        } 
        printPage(&amp;painter, richText, pageHeight, index); 
      } 
    } 
  } 
}
      
</pre>Сначала мы рассчитываем высоту одной страницы, отталкиваясь от
размера окна и размера пространства, которое резервируется под нижний и
верхний колонтитулы. Затем создается объект класса <tt class="CLASSNAME">QSimpleRichText</tt>, содержащий HTML текст. Последний
аргумент, в конструкторе <tt class="CLASSNAME">QSimpleRichText</tt> --
это высота страницы. Класс <tt class="CLASSNAME">QSimpleRichText</tt>
использует эту величину, чтобы вставить разрывы страниц.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.17.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.17. Раскладка страницы справочника
              цветовода.</p>
            </div>
          </div><br>
          После этого выполняется печать каждой страницы. Внешний цикл
          <tt class="METHODNAME">for</tt> отсчитывает количество копий,
          запрошенных пользователем. В большинстве своем, драйверы
          принтеров поддерживают печать нескольких копий документа, в
          этом случае функция <tt class="METHODNAME">QPrinter::numCopies()</tt> вернет 1, в противном
          случае -- количество копий, запрошенных пользователем. В
          предыдущих примерах, с целью упрощения кода, мы игнорировали
          этот параметр.<br>
          <br>

          <p>Внутренний цикл <tt class="METHODNAME">for</tt> отсчитывет
          страницы. если страница не является первой, то вызывается
          функция <tt class="METHODNAME">newPage()</tt>. Для вывода
          очередной страницы на печать вызывается функция <tt class="METHODNAME">printPage()</tt>.</p>

          <p>Диалог выбора принтера позволяет пользователю заказать
          печать страниц в обратном порядке, мы так же соблюдаем и это
          требование.</p>

          <p>В данном примере предполагается, что <tt class="VARNAME">printer, bodyFont</tt> и <tt class="VARNAME">footerFont</tt> -- это переменные-члены класса
          <tt class="CLASSNAME">PrintWindow</tt>.</p>
          <pre class="SCREEN">void PrintWindow::printPage(QPainter *painter, 
                            const QSimpleRichText &amp;richText, 
                            int pageHeight, int index) 
{ 
  QRect rect(0, index * pageHeight + LargeGap, 
             richText.width(), pageHeight); 
  painter-&gt;saveWorldMatrix(); 
  painter-&gt;translate(0, -rect.y()); 
  richText.draw(painter, 0, LargeGap, rect, colorGroup()); 
  painter-&gt;restoreWorldMatrix(); 
  painter-&gt;setFont(footerFont); 
  painter-&gt;drawText(painter-&gt;window(), AlignHCenter | AlignBottom, 
                    QString::number(index + 1)); 
}
      
</pre>Функция <tt class="METHODNAME">printPage()</tt> выводит на печать
<tt class="METHODNAME">(index + 1)</tt>-ую страницу. Она содержит
HTML-код и номер страницы в нижнем колонтитуле.<br>
          <br>

          <p>Мы выполняем смещение системы координат и вызываем
          <tt class="METHODNAME">draw()</tt>, чтобы нарисовать текст, с
          нужной позиции. После этого, в нижнем колонтитуле, по центру
          страницы, выводится ее номер. Если бы нам потребовалось
          выводить что нибудь в верхнем колонтитуле, то мы добавили бы
          еще один вызов <tt class="METHODNAME">drawText()</tt>.</p>

          <p>Константа <tt class="VARNAME">LargeGap</tt> равна числу
          48. Если исходить из предположения, что разрешение экрана
          срставляет 96 точек на дюйм, то число 48 соответствует
          половине дюйма (12.7 мм). Чтобы найти точное значение для
          константы, в каждом конкретном случае, можно воспользоваться
          услугами класса <tt class="CLASSNAME">QPaintDeviceMetrics</tt>:</p>
          <pre class="SCREEN">  QPaintDeviceMetrics metrics(&amp;printer); 
  int LargeGap = metrics.logicalDpiY() / 2;
      
</pre>Ниже приводится один из вариантов инициализации
          <tt class="VARNAME">bodyFont</tt> и <tt class="VARNAME">footerFont</tt> в конструкторе <tt class="VARNAME">PrintWindow</tt>:
          <pre class="SCREEN">  bodyFont = QFont("Helvetica", 14); 
  footerFont = bodyFont;
      
</pre>А теперь покажем, как напечатать справочник с помощью
          <tt class="CLASSNAME">QPainter</tt>. Ниже приводится
          измененный вариант функции <tt class="METHODNAME">printFlowerGuide()</tt>:
          <pre class="SCREEN">void PrintWindow::printFlowerGuide(const QStringList &amp;entries) 
{ 
  if (printer.setup(this)) { 
    QPainter painter(&amp;printer); 
    vector&lt;QStringList&gt; pages; 
    int index; 
    
    paginate(&amp;painter, &amp;pages, entries);
    for (int i = 0; i &lt; (int)printer.numCopies(); ++i) { 
      for (int j = 0; j &lt; (int)pages.size(); ++j) { 
        if (i &gt; 0 || j &gt; 0) 
          printer.newPage(); 
        
        if (printer.pageOrder() == QPrinter::LastPageFirst) { 
          index = pages.size() - j - 1; 
        } else { 
          index = j; 
        } 
        printPage(&amp;painter, pages, index); 
      } 
    } 
  } 
}
      
</pre>Первое, что нужно сделать после настройки принтера и
          <tt class="CLASSNAME">QPainter</tt> -- это вызвать
          вспомогательную функцию <tt class="METHODNAME">paginate()</tt>, чтобы определить разбивку
          справочника по страницам. Результат работы функции -- массив
          <tt class="CLASSNAME">QStringList</tt>, в котором каждый из
          элементов хранит статьи справочника для одной страницы.<br>
          <br>

          <p>Например, допустим, что справочник содержит всего 6
          статей, которые мы обозначим как A, B, C, D, E и F. Теперь
          предположим, что статьи A и B располагаются на первой
          странице, C, D и E -- на второй, а F -- на третьей. Таким
          образом, массив <tt class="VARNAME">pages</tt>, в элементе с
          индексом 0, будет содержать статьи A и B, статьи C, D и E --
          в элементе с индексом 1 и статью F -- в элементе с индексом
          2.</p>

          <p>В остальном, функция <tt class="METHODNAME">printFlowerGuide()</tt> практически идентична
          приведенному ранее варианту. Однако, функция <tt class="METHODNAME">printPage()</tt> имеет существенные отличия, но
          об этом немного позже.</p>
          <pre class="SCREEN">void PrintWindow::paginate(QPainter *painter, 
                           vector&lt;QStringList&gt; *pages, 
                           const QStringList &amp;entries) 
{ 
  QStringList currentPage; 
  int pageHeight = painter-&gt;window().height() - 2 * LargeGap; 
  int y = 0; 
  
  QStringList::const_iterator it = entries.begin(); 
  while (it != entries.end()) { 
    int height = entryHeight(painter, *it); 
    if (y + height &gt; pageHeight &amp;&amp; !currentPage.empty()) { 
      pages-&gt;push_back(currentPage); 
      currentPage.clear(); 
      y = 0; 
    } 
    currentPage.push_back(*it); 
    y += height + MediumGap; ++it; 
  } 
  if (!currentPage.empty()) 
    pages-&gt;push_back(currentPage); 
}
      
</pre>Функция <tt class="METHODNAME">paginate()</tt> распределяет
статьи справочника по страницам, основываясь на результатах функции
<tt class="METHODNAME">entryHeight()</tt>, которая вычисляет высоту
одной статьи.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.18.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.18. Вывод справочника цветовода с помощью
              <tt class="CLASSNAME">QPainter</tt>.</p>
            </div>
          </div><br>
          Она в цикле проходит по всем статьям справочника и добавляет
          их в конец текущей страницы пока не закончится доступное
          пространство. После этого текущая страница добавляется в
          массив <tt class="VARNAME">pages</tt> и начинается заполнение
          новой страницы.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.19.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.19. Раскладка одной статьи справочника.</p>
            </div>
          </div><br>
          <pre class="SCREEN">int PrintWindow::entryHeight(QPainter *painter, const QString &amp;entry) { 
  QStringList fields = QStringList::split(": ", entry); 
  QString title = fields[0]; 
  QString body = fields[1]; 
  int textWidth = painter-&gt;window().width() - 2 * SmallGap; 
  int maxHeight = painter-&gt;window().height();
  painter-&gt;setFont(titleFont); 
  QRect titleRect = painter-&gt;boundingRect(0, 0, 
                                          textWidth, maxHeight, 
                                          WordBreak, title); 
  painter-&gt;setFont(bodyFont); 
  QRect bodyRect = painter-&gt;boundingRect(0, 0, 
                                         textWidth, maxHeight, 
                                         WordBreak, body); 
  return titleRect.height() + bodyRect.height() + 4 * SmallGap; 
}
      
</pre>Функция <tt class="METHODNAME">entryHeight()</tt>, с помощью
<tt class="METHODNAME">QPainter::boundingRect()</tt>, вычисляет высоту
статьи на странице. На рисунке 8.19 показана раскладка статьи
справочника и назначение констант <tt class="VARNAME">SmallGap</tt> и
<tt class="VARNAME">MediumGap</tt>.
          <pre class="SCREEN">void PrintWindow::printPage(QPainter *painter, 
                            const vector&lt;QStringList&gt; &amp;pages, 
                            int index) 
{ 
  painter-&gt;saveWorldMatrix(); 
  painter-&gt;translate(0, LargeGap); 
  QStringList::const_iterator it = pages[index].begin(); 
  while (it != pages[index].end()) { 
    QStringList fields = QStringList::split(": ", *it); 
    QString title = fields[0]; 
    QString body = fields[1]; 
    printBox(painter, titleFont, title, lightGray); 
    printBox(painter, bodyFont, body, white); 
    painter-&gt;translate(0, MediumGap); 
    ++it; 
  } 
  painter-&gt;restoreWorldMatrix(); 
  painter-&gt;setFont(footerFont); 
  painter-&gt;drawText(painter-&gt;window(), AlignHCenter | AlignBottom, 
                    QString::number(index + 1)); 
}
      
</pre>Функция <tt class="METHODNAME">printPage()</tt> обходит в цикле
все статьи справочника и печатает их в два приема: первый раз функция
<tt class="METHODNAME">printBox()</tt> вызывается для печати заголовка
статьи (название цветка) и второй раз -- для печати описания (тела
статьи). В заключение печатается номер страницы, внизу по центру.
          <pre class="SCREEN">void PrintWindow::printBox(QPainter *painter, const QFont &amp;font, 
                           const QString &amp;str, const QBrush &amp;brush) 
{ 
  painter-&gt;setFont(font); 
  int boxWidth = painter-&gt;window().width(); 
  int textWidth = boxWidth - 2 * SmallGap; 
  int maxHeight = painter-&gt;window().height(); 
  
  QRect textRect = painter-&gt;boundingRect(SmallGap, SmallGap, 
                                         textWidth, maxHeight, 
                                         WordBreak, str); 
  int boxHeight = textRect.height() + 2 * SmallGap;
  painter-&gt;setPen(QPen(black, 2, SolidLine)); 
  painter-&gt;setBrush(brush); 
  painter-&gt;drawRect(0, 0, boxWidth, boxHeight); 
  painter-&gt;drawText(textRect, WordBreak, str); 
  painter-&gt;translate(0, boxHeight); 
}
      
</pre>Функция <tt class="METHODNAME">printBox()</tt> рисует
прямоугольник, а затем внутри него -- текст.<br>
          <br>

          <p>Если на печать выводится большой документ, или
          пользователь заказал несколько копий одного документа, то
          неплохо было бы показать индикатор хода выполнения задания --
          <tt class="CLASSNAME">QProgressDialog</tt>. Ниже приводится
          модифицированный вариант функции <tt class="METHODNAME">printFlowerGuide()</tt>, которая выводит перед
          пользователем индикатор хода выполнения задания:</p>
          <pre class="SCREEN">void PrintWindow::printFlowerGuide(const QStringList &amp;entries) 
{ 
  if (printer.setup(this)) { 
    QPainter painter(&amp;printer); 
    vector&lt;QStringList&gt; pages; 
    int index; 
    
    paginate(&amp;painter, &amp;pages, entries); 
    
    int numSteps = printer.numCopies() * pages.size(); 
    int step = 0; 
    QProgressDialog progress(tr("Printing file..."), 
                             tr("Cancel"), numSteps, this); 
    progress.setModal(true); 
    
    for (int i = 0; i &lt; (int)printer.numCopies(); ++i) { 
      for (int j = 0; j &lt; (int)pages.size(); ++j) { 
        progress.setProgress(step); 
        qApp-&gt;processEvents(); 
        if (progress.wasCanceled()) { 
          printer.abort(); 
          return; 
        } 
        ++step;

        if (i &gt; 0 || j &gt; 0) 
          printer.newPage(); 
        if (printer.pageOrder() == QPrinter::LastPageFirst) { 
          index = pages.size() - j - 1; 
        } else { 
          index = j; 
        } 
        printPage(&amp;painter, pages, index); 
      } 
    } 
  } 
}
      
</pre>Когда пользователь нажимает на кнопку <strong class="COMMAND">
          Cancel</strong> -- вызывается <tt class="METHODNAME">QPrinter::abort()</tt>, которая останавливает
          процесс печати.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="GRAPHICSWITHOPENGL"></a>8.4.
          Графика OpenGL.</h1>

          <p>OpenGL -- это стандарт API, для отображения двух- и
          трехмерной графики. Приложения Qt могут использовать OpenGL,
          посредством модуля QGL. Мы полагаем, что вы уже имеете
          некоторое знакомство с OpenGL. Если это не так, то
          рекомендуем начать изучение с посещения сайта <a href="http://www.opengl.org/" target="_top">http://www.opengl.org/</a>.</p>

          <p>Рисование трехмерных объектов, с помощью OpenGL, не так
          сложно, как может показаться на первый взгляд. Все что вам
          нужно сделать -- создать дочерний класс от <tt class="CLASSNAME">QGLWidget</tt>, перекрыть некоторые виртуальные
          методы предка и связать приложение с модулем QGL и
          библиотекой OpenGL. Поскольку <tt class="CLASSNAME">QGLWidget</tt> ведет свою родословную от
          <tt class="CLASSNAME">QWidget</tt>, то здесь вполне применимы
          знания, которые вы уже получили. Основное отличие здесь
          состоит в том, что теперь, вместо <tt class="CLASSNAME">QPainter</tt>, вам придется использовать
          стандартные функции рисования из OpenGL.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig8.20.png"></p>

            <div class="CAPTION">
              <p>Рисунок 8.20. Приложение Cube.</p>
            </div>
          </div><br>
          Для демонстрации возможностей библиотеки OpenGL, напишем
          приложение Cube, изображенное на рисунке 8.20. Приложение
          рисует трехмерный куб, грани которого окрашены в различные
          цвета. Пользователь может вращать куб и перемещать его.
          Двойным щелчком мыши по грани куба, он сможет изменить ее
          цвет, с помощью диалога выбора цвета <tt class="CLASSNAME">QColorDialog</tt>.
          <pre class="SCREEN">class Cube : public QGLWidget 
{ 
public: 
  Cube(QWidget *parent = 0, const char *name = 0); 
  
protected: 
  void initializeGL(); 
  void resizeGL(int width, int height); 
  void paintGL(); 
  void mousePressEvent(QMouseEvent *event); 
  void mouseMoveEvent(QMouseEvent *event); 
  void mouseDoubleClickEvent(QMouseEvent *event);

private: 
  void draw(); 
  int faceAtPosition(const QPoint &amp;pos); 
  GLfloat rotationX; 
  GLfloat rotationY; 
  GLfloat rotationZ; 
  QColor faceColors[6]; 
  QPoint lastPos; 
};
      
</pre>Класс <tt class="CLASSNAME">Cube</tt> порожден от
          <tt class="CLASSNAME">QGLWidget</tt>. Функции <tt class="METHODNAME">initializeGL(), resizeGL()</tt> и <tt class="METHODNAME">paintGL()</tt> перекрывают методы родительского
          класса <tt class="CLASSNAME">QGLWidget</tt>. Обработчики
          событий от мыши перекрывают обработчики, унаследованные от
          <tt class="CLASSNAME">QWidget</tt>. Определение класса
          <tt class="CLASSNAME">QGLWidget</tt> находится в заголовке
          <tt class="FILENAME">&lt;qgl.h&gt;</tt>.
          <pre class="SCREEN">Cube::Cube(QWidget *parent, const char *name) 
    : QGLWidget(parent, name) 
{ 
  setFormat(QGLFormat(DoubleBuffer | DepthBuffer)); 
  rotationX = 0; 
  rotationY = 0; 
  rotationZ = 0; 
  faceColors[0] = red; 
  faceColors[1] = green; 
  faceColors[2] = blue; 
  faceColors[3] = cyan; 
  faceColors[4] = yellow; 
  faceColors[5] = magenta; 
}
      
</pre>В конструкторе вызывается <tt class="METHODNAME">QGLWidget::setFormat()</tt>, чтобы задать контекст
устройства отображения OpenGL, и инициализируются приватные
переменные-члены класса.
          <pre class="SCREEN">void Cube::initializeGL() 
{ 
  qglClearColor(black); 
  glShadeModel(GL_FLAT); 
  glEnable(GL_DEPTH_TEST); 
  glEnable(GL_CULL_FACE); 
}
      
</pre>Функция <tt class="METHODNAME">initializeGL()</tt> вызывается
один раз, перед вызовом <tt class="METHODNAME">paintGL()</tt>. Здесь
выполняется настройка контекста отображения.<br>
          <br>

          <p>Все функции являются стандартными вызовами из библиотеки
          OpenGL, за исключением <tt class="METHODNAME">qglClearColor()</tt> -- метода класса <tt class="CLASSNAME">QGLWidget</tt>. Если задаться целью, до конца
          следовать стандарту OpenGL, то мы могли бы вызвать функцию
          <tt class="METHODNAME">glClearColor()</tt>, в режиме RGBA,
          или <tt class="METHODNAME">glClearIndex()</tt>, в режиме
          индексированных цветов.</p>
          <pre class="SCREEN">void Cube::resizeGL(int width, int height) 
{ 
  glViewport(0, 0, width, height); 
  glMatrixMode(GL_PROJECTION); 
  glLoadIdentity(); 
  GLfloat x = (GLfloat)width / height; 
  glFrustum(-x, x, -1.0, 1.0, 4.0, 15.0);
  glMatrixMode(GL_MODELVIEW); 
}
      
</pre>Функция <tt class="METHODNAME">resizeGL()</tt> вызывается один
раз, перед <tt class="METHODNAME">paintGL()</tt>, но после того, как
будет вызвана функция <tt class="METHODNAME">initializeGL()</tt>. Здесь
настраивается область просмотра (viewport), проекция и прочие
настройки, которые зависят от размера виджета.
          <pre class="SCREEN">void Cube::paintGL() 
{ 
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 
  draw(); 
}
      
</pre>Функция <tt class="METHODNAME">paintGL()</tt> вызывается всякий
раз, когда возникает необходимость перерисовать содержимое виджета. Она
напоминает обработчик события <tt class="METHODNAME">QWidget::paintEvent()</tt>, только вместо
          <tt class="CLASSNAME">QPainter</tt> здесь используются
          обращения к функциям OpenGL. Собственно рисование выполняется
          внутри приватной функции <tt class="METHODNAME">draw()</tt>:
          <pre class="SCREEN">void Cube::draw() 
{ 
  static const GLfloat coords[6][4][3] = { 
      { { +1.0, -1.0, +1.0 }, { +1.0, -1.0, -1.0 }, 
        { +1.0, +1.0, -1.0 }, { +1.0, +1.0, +1.0 } }, 
      { { -1.0, -1.0, -1.0 }, { -1.0, -1.0, +1.0 }, 
        { -1.0, +1.0, +1.0 }, { -1.0, +1.0, -1.0 } }, 
      { { +1.0, -1.0, -1.0 }, { -1.0, -1.0, -1.0 }, 
        { -1.0, +1.0, -1.0 }, { +1.0, +1.0, -1.0 } }, 
      { { -1.0, -1.0, +1.0 }, { +1.0, -1.0, +1.0 }, 
        { +1.0, +1.0, +1.0 }, { -1.0, +1.0, +1.0 } }, 
      { { -1.0, -1.0, -1.0 }, { +1.0, -1.0, -1.0 }, 
        { +1.0, -1.0, +1.0 }, { -1.0, -1.0, +1.0 } }, 
      { { -1.0, +1.0, +1.0 }, { +1.0, +1.0, +1.0 }, 
        { +1.0, +1.0, -1.0 }, { -1.0, +1.0, -1.0 } } 
  }; 
  
  glMatrixMode(GL_MODELVIEW); 
  glLoadIdentity(); 
  glTranslatef(0.0, 0.0, -10.0); 
  glRotatef(rotationX, 1.0, 0.0, 0.0); 
  glRotatef(rotationY, 0.0, 1.0, 0.0); 
  glRotatef(rotationZ, 0.0, 0.0, 1.0);

  for (int i = 0; i &lt; 6; ++i) { 
    glLoadName(i); 
    glBegin(GL_QUADS); 
    qglColor(faceColors[i]); 
    for (int j = 0; j &lt; 4; ++j) { 
      glVertex3f(coords[i][j][0], coords[i][j][1], coords[i][j][2]); 
    } 
    glEnd(); 
  } 
}  
      
</pre>Внутри функции <tt class="METHODNAME">draw()</tt> выполняется
рисование куба, с учетом вращения по осям <tt class="VARNAME">
          x, y</tt> и <tt class="VARNAME">z</tt> и цветов граней,
          находящихся в массиве <tt class="VARNAME">faceColors</tt>.
          Все вызовы являются стандартными для OpenGL, за исключением
          <tt class="METHODNAME">qglColor()</tt>. Мы могли бы
          использовать вместо нее стандартные функции OpenGL <tt class="METHODNAME">glColor3d()</tt> или <tt class="METHODNAME">glIndex()</tt>, в зависимости от выбранного
          режима цветопередачи.
          <pre class="SCREEN">void Cube::mousePressEvent(QMouseEvent *event) 
{ 
  lastPos = event-&gt;pos(); 
} 

void Cube::mouseMoveEvent(QMouseEvent *event) 
{ 
  GLfloat dx = (GLfloat)(event-&gt;x() - lastPos.x()) / width(); 
  GLfloat dy = (GLfloat)(event-&gt;y() - lastPos.y()) / height(); 
  
  if (event-&gt;state() &amp; LeftButton) { 
    rotationX += 180 * dy; 
    rotationY += 180 * dx; 
    updateGL(); 
  } else if (event-&gt;state() &amp; RightButton) { 
    rotationX += 180 * dy; 
    rotationZ += 180 * dx; 
    updateGL(); 
  } 
  lastPos = event-&gt;pos(); 
}
      
</pre>Функции <tt class="METHODNAME">mousePressEvent()</tt> и
          <tt class="METHODNAME">mouseMoveEvent()</tt> позволяют
          пользователю вращать куб и перемещать его по поверхности
          экрана. Левой кнопкой мыши выполняется вращение по осям
          <tt class="VARNAME">x</tt> и <tt class="VARNAME">y</tt>,
          правой -- по осям <tt class="VARNAME">x</tt> и <tt class="VARNAME">z</tt>.<br>
          <br>

          <p>После изменения переменных <tt class="VARNAME">rotationX</tt> и/или <tt class="VARNAME">rotationY</tt> и <tt class="VARNAME">rotationZ</tt>, вызывается функция <tt class="METHODNAME">updateGL()</tt>, которая перерисовывает
          изображение.</p>
          <pre class="SCREEN">void Cube::mouseDoubleClickEvent(QMouseEvent *event) 
{ 
  int face = faceAtPosition(event-&gt;pos()); 
  if (face != -1) { 
    QColor color = QColorDialog::getColor(faceColors[face], 
                                          this); 
    if (color.isValid()) { 
      faceColors[face] = color; 
      updateGL(); 
    } 
  } 
}
      
</pre>Обработчик <tt class="METHODNAME">mouseDoubleClickEvent()</tt>
позволяет пользователю изменить цвет грани по двойному щелчку мыши. Для
определения номера грани вызывается функция <tt class="METHODNAME">
          faceAtPosition()</tt>. Если под указателем мыши действительно
          находится какая либо грань куба, вызывается <tt class="METHODNAME">QColorDialog::getColor()</tt>, чтобы получить от
          пользователя новый цвет грани. Затем он заносится в массив
          <tt class="VARNAME">faceColors</tt> и вызывается <tt class="METHODNAME">updateGL()</tt>, чтобы перерисовать изображение.
          <pre class="SCREEN">int Cube::faceAtPosition(const QPoint &amp;pos) 
{ 
  const int MaxSize = 512; 
  GLuint buffer[MaxSize]; 
  GLint viewport[4]; 
  
  glGetIntegerv(GL_VIEWPORT, viewport); 
  glSelectBuffer(MaxSize, buffer); 
  glRenderMode(GL_SELECT); 
  glInitNames(); 
  glPushName(0); 
  glMatrixMode(GL_PROJECTION); 
  glPushMatrix(); 
  glLoadIdentity(); 
  gluPickMatrix((GLdouble)pos.x(), 
                (GLdouble)(viewport[3] - pos.y()), 
                5.0, 5.0, viewport); 
  GLfloat x = (GLfloat)width() / height(); 
  glFrustum(-x, x, -1.0, 1.0, 4.0, 15.0); 
  draw(); 
  glMatrixMode(GL_PROJECTION); 
  glPopMatrix();

  if (!glRenderMode(GL_RENDER)) 
    return -1; 
  return buffer[3]; 
}
      
</pre>Функция <tt class="METHODNAME">faceAtPosition()</tt> возвращает
либо номер грани, находящейся в заданных координатах, либо -1, если
точка с заданными координатами не входит ни в одну из граней. Код,
выполняющий проверку, достаточно сложен. По сути -- он переводит сцену
в режим <tt class="VARNAME">GL_SELECT</tt>, чтобы мы могли
воспользоваться дополнительными возможностями OpenGL, и отыскивает
номер грани ("name").<br>
          <br>

          <p>Далее приводится содержимое файла <tt class="FILENAME">main.cpp</tt>:</p>
          <pre class="SCREEN">#include &lt;qapplication.h&gt; 

#include "cube.h" 

int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  if (!QGLFormat::hasOpenGL()) 
    qFatal("This system has no OpenGL support"); 
    
  Cube cube; 
  cube.setCaption(QObject::tr("Cube")); 
  cube.resize(300, 300); 
  app.setMainWidget(&amp;cube); 
  cube.show(); 
  return app.exec(); 
}
      
</pre>Если система не поддерживает OpenGL, то, с помощью вызова
<tt class="METHODNAME">qFatal()</tt>, приложение выводит сообщение об
ошибке и завершает работу.<br>
          <br>

          <p>Чтобы связать приложение Cube с модулем QGL и библиотекой
          OpenGL, в файл <tt class="FILENAME">.pro</tt> нужно добавить
          строчку:</p>
          <pre class="SCREEN">      CONFIG += opengl
      
</pre>За дополнительной информацией о модуле QGL, обращайтесь к
сопроводительной документации по классам <tt class="CLASSNAME">
          QGLWidget, QGLFormat, QGLContext</tt> и <tt class="CLASSNAME">QGLColormap</tt>.
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER9"></a>Глава 9. Drag and Drop.</h1>

        <p>"Drag and Drop" (от англ. "Перетащил и
        бросил") -- современный интуитивно понятный способ
        перемещения информации внутри приложения или между
        приложениями. Он часто реализуется как дополнение к поддержке
        буфера обмена.</p>

        <p>В этой главе мы покажем как добавить в приложение поддержку
        механизма "перетащил и бросил". Затем мы будем
        использовать код "drag and drop" для реализации
        поддержки буфера обмена. Это возможно по той простой причине,
        что в основе обоих механизмов лежит один абстрактный класс
        <tt class="CLASSNAME">QMimeSource</tt>, который может хранить
        данные в различных форматах.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="ENABLINGDRAGANDDROP"></a>9.1.
          Реализация механизма 'drag and drop' в
          приложениях.</h1>

          <p>В основе механизма "перетащил и бросил" лежат
          две операции: операция перетаскивания и операция сброса.
          Виджет может быть как источником, откуда начинается
          перетаскивание, так и местом, куда может производиться
          сбрасывание.</p>

          <p>Это очень мощный механизм, позволяющий перетаскивать
          данные из одного приложения в другое. Однако, в некоторых
          случаях, можно реализовать некоторое подобие механизма
          "перетащил и бросил", не прибегая к специальным
          возможностям Qt. Если все, что вам нужно -- это перетащить
          какие либо данные внутри одного виджета, то гораздо проще это
          выполняется перекрытием обработчиков событий от мыши.
          Подобный подход мы рассматривали в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER8">Главе
          8</a>, при разработке виджета <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P190"><tt class="CLASSNAME">DiagramView</tt></a>.</p>

          <p>В нашем первом примере мы рассмотрим -- как заставить Qt
          приложение принимать данные, перетаскиваемые из других
          приложений. Приложение представлено окном, где в качестве
          центрального, используется виджет <tt class="CLASSNAME">QTextEdit</tt>. Когда пользователь перемещает
          какой либо файл с рабочего стола или из
          программы-обозревателя, то наше приложение будет загружать
          его в <tt class="CLASSNAME">QTextEdit</tt>.</p>

          <p>Ниже приводится определение класса <tt class="CLASSNAME">MainWindow</tt>:</p>
          <pre class="SCREEN">class MainWindow : public QMainWindow 
{
  Q_OBJECT 
public: 
  MainWindow(QWidget *parent = 0, const char *name = 0); 
  
protected: 
  void dragEnterEvent(QDragEnterEvent *event); 
  void dropEvent(QDropEvent *event); 
  
private: 
  bool readFile(const QString &amp;fileName); 
  QString strippedName(const QString &amp;fullFileName); 
  
  QTextEdit *textEdit; 
};
      
</pre>Класс <tt class="CLASSNAME">MainWindow</tt> перекрывает методы
предка (<tt class="CLASSNAME">QWidget</tt>) <tt class="METHODNAME">
          dragEnterEvent()</tt> и <tt class="METHODNAME">dropEvent()</tt>. Так как целью данного примера
          является демонстрация работы механизма "drag and
          drop", ту часть реализации класса <tt class="CLASSNAME">MainWindow</tt>, которая не имеет отношения к
          этому механизму, мы приводить не будем.
          <pre class="SCREEN">MainWindow::MainWindow(QWidget *parent, const char *name) 
    : QMainWindow(parent, name) 
{ 
  setCaption(tr("Drag File")); 
  textEdit = new QTextEdit(this); 
  setCentralWidget(textEdit); 
  textEdit-&gt;viewport()-&gt;setAcceptDrops(false); 
  setAcceptDrops(true); 
}
      
</pre>В конструкторе создается объект класса <tt class="CLASSNAME">
          QTextEdit</tt> и назначается центральным виджетом приложения.
          Далее запрещается "сброс" в область <tt class="CLASSNAME">QTextEdit</tt> и разрешается для главного окна
          приложения.<br>
          <br>

          <p>Запрет на сброс для <tt class="CLASSNAME">QTextEdit</tt>
          накладывается из-за того, что обработка перетаскивания и
          сброса будет реализована в классе главного окна приложения.
          По-умолчанию <tt class="CLASSNAME">QTextEdit</tt> может
          принимать "сбрасываемые" текстовые данные,
          перетянутые из другого приложения, так например, если
          пользователь перетащит файл в область <tt class="CLASSNAME">QTextEdit</tt>, то в виджет будет вставлено имя
          файла. Но это не совсем то, что нам надо. Мы собираемся
          открыть файл и поместить его содержимое в центральный виджет,
          а не вставить его имя в текст. Поэтому мы не будем
          использовать возможности класса <tt class="CLASSNAME">QTextEdit</tt>, а реализуем свои собственные
          методы в классе главного окна приложения.</p>

          <p>Поскольку события, в случае отказа от обработки, переходят
          от подчиненного виджета -- виджету владельцу, то главное окно
          получит событие "сброса" даже в том случае, если
          сброс осуществлялся в области <tt class="CLASSNAME">QTextEdit</tt>.</p>
          <pre class="SCREEN">void MainWindow::dragEnterEvent(QDragEnterEvent *event) 
{ 
  event-&gt;accept(QUriDrag::canDecode(event)); 
}
      
</pre>Функция <tt class="METHODNAME">dragEnterEvent()</tt> вызывается,
когда пользователь перемещает некий объект в область виджета. Если
вызывается <tt class="METHODNAME">accept(true)</tt>, то это говорит о
том, что пользователь может сбросить перетаскиваемый объект на виджет.
Если вызывается <tt class="METHODNAME">accept(false)</tt> --
перетаскиваемый объект не может быть принят виджетом. Qt автоматически
изменяет внешний вид указателя мыши, показывая пользователю -- может
или не может быть сброшен данный объект в этом месте.<br>
          <br>

          <p>В нашем примере предполагается, что пользователь может
          сбросить в область приложения только имена файлов. Поэтому мы
          воспользовались услугами класса <tt class="CLASSNAME">QUriDrag</tt>, который обслуживает перетаскивание
          файлов, для опознания перетаскиваемого объекта. Этот класс
          может использоваться для опознания Универсальных
          Идентификаторов Ресурсов (URI -- Universal Resource
          Identifier), таких как пути FTP или HTTP.</p>
          <pre class="SCREEN">void MainWindow::dropEvent(QDropEvent *event) 
{ 
  QStringList fileNames; 
  if (QUriDrag::decodeLocalFiles(event, fileNames)) { 
    if (readFile(fileNames[0])) 
      setCaption(tr("%1 - Drag File") 
                 .arg(strippedName(fileNames[0]))); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">dropEvent()</tt> вызывается в
момент сброса объекта на виджет. Функция <tt class="METHODNAME">
          QUriDrag::decodeLocalFiles()</tt> возвращает список имен
          файлов, которые перетаскивает пользователь. Из этого списка
          мы вынимаем первый файл. Обычно пользователь перетаскивает
          файлы по одному, но возможна ситуация, когда перетаскивается
          несколько выделенных файлов.<br>
          <br>

          <p>Кроме того, класс <tt class="CLASSNAME">QWidget</tt>
          предоставляет методы <tt class="METHODNAME">dragMoveEvent()</tt> и <tt class="METHODNAME">dragLeaveEvent()</tt>, но в большинстве
          приложений эти методы не используются.</p>

          <p>Второй пример показывает -- как начать перетаскивание и
          как принять сбрасываемый объект. С этой целью мы создадим
          подкласс от <tt class="CLASSNAME">QListBox</tt>, и реализуем
          в нем поддержку механизма "перетащил и бросил".
          Этот класс мы будем использовать в приложении "Project
          Chooser", показанном на рисунке 9.1.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig9.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 9.1. Внешний вид приложения "Project
              Chooser".</p>
            </div>
          </div><br>
          Окно приложения состоит из двух списков -- участников
          проектов. Каждый из списков отвечает за отдельный проект.
          Пользователь может перемещать имена участников проектов из
          одного списка в другой.<br>
          <br>

          <p>Вся реализация будет размещаться в единственном классе,
          потомке <tt class="CLASSNAME">QListBox</tt>. Ниже приводится
          определение класса:</p>
          <pre class="SCREEN">class ProjectView : public QListBox 
{ 
  Q_OBJECT
public: 
  ProjectView(QWidget *parent, const char *name = 0); 
  
protected: 
  void contentsMousePressEvent(QMouseEvent *event); 
  void contentsMouseMoveEvent(QMouseEvent *event); 
  void contentsDragEnterEvent(QDragEnterEvent *event); 
  void contentsDropEvent(QDropEvent *event); 
  
private: 
  void startDrag(); 
  QPoint dragPos; 
};
      
</pre>Класс <tt class="CLASSNAME">ProjectView</tt> реализует четыре
обработчика событий, объявленных в <tt class="CLASSNAME">QScrollView</tt> (базовый класс для <tt class="CLASSNAME">
          QListBox</tt>).
          <pre class="SCREEN">ProjectView::ProjectView(QWidget *parent, const char *name) 
    : QListBox(parent, name) 
{ 
  viewport()-&gt;setAcceptDrops(true); 
}
      
</pre>В конструкторе мы разрешаем прием сбрасываемых объектов в область
списка.
          <pre class="SCREEN">void ProjectView::contentsMousePressEvent(QMouseEvent *event) 
{ 
  if (event-&gt;button() == LeftButton) 
    dragPos = event-&gt;pos(); 
    QListBox::contentsMousePressEvent(event); 
}
      
</pre>Когда пользователь нажимает левую кнопку мыши, позиция указателя
запоминается в приватной переменной <tt class="VARNAME">dragPos</tt> и
вызывается метод предка <tt class="METHODNAME">contentsMousePressEvent()</tt>, чтобы обработать нажатие
кнопки в обычном порядке.
          <pre class="SCREEN">void ProjectView::contentsMouseMoveEvent(QMouseEvent *event) 
{ 
  if (event-&gt;state() &amp; LeftButton) { 
    int distance = (event-&gt;pos() - dragPos).manhattanLength(); 
    if (distance &gt; QApplication::startDragDistance()) 
      startDrag(); 
  } 
  QListBox::contentsMouseMoveEvent(event); 
}
      
</pre>Когда пользователь перемещает указатель мыши, при удерживаемой
левой кнопке, мы полагаем, что началось перетаскивание объекта. Далее
вычисляется расстояние между текущим положением указателя мыши и точкой
начала перетаскивания.<br>
          <br>

          <p>Если это расстояние больше, чем рекомендуемое классом
          <tt class="CLASSNAME">QApplication</tt> (обычно 4 пикселя),
          после которого перемещение мыши действительно начинает
          рассматриваться как перетаскивание объекта, вызывается
          <tt class="METHODNAME">startDrag()</tt>, которая отмечает
          начало перетаскивания. Это дает возможность избежать ложного
          запуска процесса перетаскивания из-за дрожжания руки
          пользователя.</p>
          <pre class="SCREEN">void ProjectView::startDrag() 
{ 
  QString person = currentText(); 
  if (!person.isEmpty()) { 
    QTextDrag *drag = new QTextDrag(person, this); 
    drag-&gt;setSubtype("x-person"); 
    drag-&gt;setPixmap(QPixmap::fromMimeSource("person.png")); 
    drag-&gt;drag(); 
  } 
}
      
</pre>В <tt class="METHODNAME">startDrag()</tt> создается объект класса
<tt class="CLASSNAME">QTextDrag</tt>. Этот класс представляет
перетаскиваемый объект, который содержит перемещаемый текст. Это один
из нескольких предопределенных типов, которые предоставляет Qt для
перетаскиваемых объектов. Кроме него можно еще назвать
          <tt class="CLASSNAME">QImageDrag, QColorDrag</tt> и
          <tt class="CLASSNAME">QUriDrag</tt>. Дополнительно, в
          соответствие перетаскиваемому объекту, мы ставим небольшую
          картинку, которая будет перемещаться вслед за указателем
          мыши, изображая перетаскиваемый объект.<br>
          <br>

          <p>Затем вызывается <tt class="METHODNAME">setSubtype()</tt>,
          которая устанавливает подтип объекта -- <tt class="PARAMETER"><em>x-person</em></tt>. После этого полный тип
          объекта MIME приобретает значение <tt class="PARAMETER"><em>text/x-person</em></tt>. Если этого не
          сделать, то перетаскиваемый объект будет иметь тип MIME --
          <tt class="PARAMETER"><em>text/plain</em></tt>.</p>

          <p>Стандартные типы MIME определены IANA (Internet Assigned
          Numbers Authority). Полный MIME тип состоит из названия типа
          и подтипа, разделенных символом слэша. Когда создается
          нестандартный тип, рекомендуется предварять название подтипа
          префиксом <tt class="PARAMETER"><em>x-</em></tt>. Типы MIME
          используются буфером обмена и механизмом "drag and
          drop" для идентификации различных типов данных.</p>

          <p>Функция <tt class="METHODNAME">drag()</tt> отмечает начало
          операции перетаскивания. После этого Qt принимает на себя
          обязательства по владению перетаскиваемым объектом, пока
          перемещение не будет завершено. Она сама удалит объект, когда
          нужда в нем отпадет, даже если он так и не достигнет места
          назначения. <a name="P219"></a></p>
          <pre class="SCREEN">void ProjectView::contentsDragEnterEvent(QDragEnterEvent *event) 
{ 
  event-&gt;accept(event-&gt;provides("text/x-person")); 
}
      
</pre>Виджет класса <tt class="CLASSNAME">ProjectView</tt> может не
только начать перетаскивание объекта, типа <tt class="PARAMETER">
          <em>text/x-person</em></tt>, но так же может принимать
          сбрасываемые объекты этого типа. Когда перемещаемый объект
          попадает в область виджета, выполняется проверка на
          корректность типа MIME.
          <pre class="SCREEN">void ProjectView::contentsDropEvent(QDropEvent *event) 
{ 
  QString person; 
  
  if (QTextDrag::decode(event, person)) { 
    QWidget *fromWidget = event-&gt;source(); 
    if (fromWidget &amp;&amp; fromWidget != this 
            &amp;&amp; fromWidget-&gt;inherits("ProjectView")) { 
      ProjectView *fromProject = (ProjectView *)fromWidget; 
      QListBoxItem *item = fromProject-&gt;findItem(person, ExactMatch); 
      delete item;
      insertItem(person); 
    } 
  } 
}
      
</pre>В функции <tt class="METHODNAME">contentsDropEvent()</tt>, с
помощью <tt class="METHODNAME">QTextDrag::decode()</tt>, из
перетаскиваемого объекта извлекается текстовая строка. Функция
<tt class="METHODNAME">QDropEvent::source()</tt> возвращает указатель
на виджет, в котором была начата операция перетаскивания, но только в
том случае, если виджет принадлежит тому же самому приложению. Если
виджет-приемник и виджет-источник -- это не одно и то же, и
виджет-источник принадлежит классу <tt class="CLASSNAME">ProjectView</tt>, то элемент списка удаляется из
виджета-источника (вызовом <tt class="METHODNAME">delete</tt>) и
вставляется в виджет-приемник.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SUPPORTINGCUSTOMDRAGTYPES"></a>9.2. Поддержка нестандартных
          типов данных при перетаскивании.</h1>

          <p>До сих пор мы имели дело с предопределенными типами
          перетаскиваемых объектов. Например, мы использовали
          <tt class="CLASSNAME">QUriDrag</tt>, для перетаскивания
          файлов, и <tt class="CLASSNAME">QTextDrag</tt> -- для текста.
          Оба этих класса являются наследниками <tt class="CLASSNAME">QDragObject</tt>, который служит базой для всех
          перемещаемых объектов. В свою очредь, класс <tt class="CLASSNAME">QDragObject</tt> наследует свойства абстрактного
          класса <tt class="CLASSNAME">QMimeSource</tt>,
          предназначенного для хранения данных различных типов.</p>

          <p>Если вы пожелаете перемещать объекты с текстовой
          информацией, с изображениями, с именами файлов или с
          информацией о цвете, то можно использовать предопределенные
          классы Qt: <tt class="CLASSNAME">QTextDrag, QImageDrag,
          QUriDrag</tt> и <tt class="CLASSNAME">QColorDrag</tt>. Но
          если вам необходимо перемещать нестандартные типы данных, то
          у вас есть два пути:</p>

          <ul>
            <li>
              <p>Сохранить информацию, в двоичном представлении, в
              объекте класса <tt class="CLASSNAME">QStoredDrag</tt>.</p>
            </li>

            <li>
              <p>Создать свой собственный класс перетаскиваемых
              объектов, породив его от <tt class="CLASSNAME">QDragObject</tt> и перекрыв соответствующие
              виртуальные методы.</p>
            </li>
          </ul>Класс <tt class="CLASSNAME">QStoredDrag</tt> может
          хранить любые двоичные данные, что позволяет использовать его
          для любых типов MIME. Например, если вам потребуется
          перетащить некоторые данные, хранящиеся в файле формата
          (фиктивного) ASDF, то можно рекомендовать примерно такой код:
          <pre class="SCREEN">void MyWidget::startDrag() 
{ 
  QByteArray data = toAsdf(); 
  if (!data.isEmpty()) { 
    QStoredDrag *drag = new QStoredDrag("octet-stream/x-asdf", this); 
    drag-&gt;setEncodedData(data); 
    drag-&gt;setPixmap(QPixmap::fromMimeSource("asdf.png")); 
    drag-&gt;drag(); 
  } 
}
      
</pre>Однако, <tt class="CLASSNAME">QStoredDrag</tt> имеет ряд
неудобств. Одно из них заключается в том, что он может хранить только
один MIME тип. Если мы предполагаем использовать механизм "drag
and drop" только в пределах одного приложения, то это не является
большой проблемой. Но когда необходимо реализовать взаимодействие между
различными приложениями, то одного MIME типа, как правило бывает
недостаточно.<br>
          <br>

          <p>Другое неудобство состоит в необходимости преобразования
          данных в <tt class="CLASSNAME">QByteArray</tt>, даже если
          приемник не может принимать данные этого типа. При достаточно
          большом объеме данных, это может привести к неоправданной
          потере производительности. Было бы намного удобнее, если бы
          преобразование выполнялось в момент сброса перетаскиваемого
          объекта.</p>

          <p>Решение этих двух проблем заключается в создании дочернего
          класса от <tt class="CLASSNAME">QDragObject</tt> и реализации
          двух виртуальных методов <tt class="METHODNAME">format()</tt>
          и <tt class="METHODNAME">encodedData()</tt>, используемых Qt
          для получения сведений о перетаскиваемых объектах. Чтобы
          показать -- как это можно сделать, мы создадим класс
          <tt class="CLASSNAME">CellDrag</tt>, который будет хранить
          данные из одной или нескольких ячеек таблицы <tt class="CLASSNAME">QTable</tt>.</p>
          <pre class="SCREEN">class CellDrag : public QDragObject 
{ 
public: 
  CellDrag(const QString &amp;text, QWidget *parent = 0, 
           const char *name = 0); 
  const char *format(int index) const; 
  QByteArray encodedData(const char *format) const; 
  
  static bool canDecode(const QMimeSource *source); 
  static bool decode(const QMimeSource *source, QString &amp;str); 
  
private: 
  QString toCsv() const; 
  QString toHtml() const; 
  QString plainText; 
};
      
</pre>Класс <tt class="CLASSNAME">CellDrag</tt> порожден от класса
<tt class="CLASSNAME">QDragObject</tt>. В нем только две функции имеют
прямое отношение к механизму "drag and drop" -- это
          <tt class="METHODNAME">format()</tt> и <tt class="METHODNAME">encodedData()</tt>. Дополнительно, только лишь
          для удобства, он предоставляет в распоряжение программиста
          статические функции <tt class="METHODNAME">canDecode()</tt> и
          <tt class="METHODNAME">decode()</tt>, которые извлекают
          данные в момент сброса.
          <pre class="SCREEN">CellDrag::CellDrag(const QString &amp;text, QWidget *parent, 
                   const char *name) 
    : QDragObject(parent, name) 
{ 
  plainText = text; 
}
      
</pre>Конструктору передается строка в текстовом виде, которая будет
перемещаться. Это обычный текст, который может содержать символы
табуляции и перевода строки. Этот текстовый тип мы использовали в
<a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER4">Главе 4</a>, когда добавляли в приложение
Spreadsheet поддержку буфера обмена (см. раздел <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#IMPLEMENTINGTHEEDITMENU">Реализация меню Edit</a>).
          <pre class="SCREEN">const char *CellDrag::format(int index) const 
{ 
  switch (index) { 
    case 0: 
      return "text/csv"; 
    case 1: 
      return "text/html"; 
    case 2:
      return "text/plain"; 
    default: 
      return 0; 
  } 
}
      
</pre>Функция <tt class="METHODNAME">format()</tt> перекрывает метод
родительского класса <tt class="CLASSNAME">QMimeSource</tt> и
возвращает различные MIME типы, поддерживаемые объектом при
перетаскивании. В нашем примере поддерживаются три типа данных: CSV (от
англ. Comma-Separated Values -- Данные, Разделенные Запятыми), HTML и
простой текст.<br>
          <br>

          <p>Когда Qt пытается определить -- какой MIME тип
          поддерживается перетаскиваемым объектом, она вызывает
          <tt class="METHODNAME">format()</tt> с аргументом <tt class="PARAMETER"><em>index</em></tt>, равным 0, 1, 2... и так до
          тех пор, пока <tt class="METHODNAME">format()</tt> не вернет
          пустой указатель. Типы MIME для CSV и HTML были взяты из
          официального списка, который вы найдете по адресу: <a href="http://www.iana.org/assignments/media-types/" target="_top">http://www.iana.org/assignments/media-types/</a>
             .</p>

          <p>Порядок следования форматов не имеет значения, однако,
          хорошей практикой считается помещать наиболее
          предпочтительные форматы в начало. Приложения, которые
          поддерживают несколько форматов, зачастую останавливаются на
          первом подходящем формате.</p>
          <pre class="SCREEN">QByteArray CellDrag::encodedData(const char *format) const 
{ 
  QByteArray data; 
  QTextOStream out(data); 
  
  if (qstrcmp(format, "text/csv") == 0) { 
    out &lt;&lt; toCsv(); 
  } else if (qstrcmp(format, "text/html") == 0) { 
    out &lt;&lt; toHtml(); 
  } else if (qstrcmp(format, "text/plain") == 0) { 
    out &lt;&lt; plainText; 
  } 
  return data; 
}
      
</pre>Функция <tt class="METHODNAME">encodedData()</tt> возвращает
данные в заказанном формате. Аргумент <tt class="PARAMETER"><em>
          format</em></tt>, обычно содержит одну из строк, которую
          возвращает функция <tt class="METHODNAME">format()</tt>, но
          мы не можем безоговорочно утверждать это, поскольку не все
          приложения проверяют тип MIME вызовом <tt class="METHODNAME">format()</tt>. В приложениях Qt такая проверка
          обычно выполняется вызовом <tt class="METHODNAME">provides()</tt> внутри <tt class="METHODNAME">QDragEnterEvent</tt> и <tt class="METHODNAME">QDragMoveEvent</tt> (<a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P219">как мы это
          видели ранее</a>).<br>
          <br>

          <p>Для преобразования <tt class="CLASSNAME">QString</tt> в
          <tt class="CLASSNAME">QByteArray,</tt> лучше использовать
          <tt class="CLASSNAME">QTextStream</tt>.</p>
          <pre class="SCREEN">QString CellDrag::toCsv() const 
{ 
  QString out = plainText; 
  out.replace("\\", "\\\\"); 
  out.replace("\"", "\\\""); 
  out.replace("\t", "\", \"");
  out.replace("\n", "\"\n\""); 
  out.prepend("\""); 
  out.append("\""); 
  return out; 
}
   
QString CellDrag::toHtml() const 
{ 
  QString out = QStyleSheet::escape(plainText); 
  out.replace("\t", "&lt;td&gt;"); 
  out.replace("\n", "\n&lt;tr&gt;&lt;td&gt;"); 
  out.prepend("&lt;table&gt;\n&lt;tr&gt;&lt;td&gt;"); 
  out.append("\n&lt;/table&gt;"); 
  return out; 
}
      
</pre>Функции <tt class="METHODNAME">toCsv()</tt> и
          <tt class="METHODNAME">toHtml()</tt> выполняют преобразование
          символов табуляции и перевода строки в соответствующие
          элементы формата CSV и HTML. Например, данные
          <pre class="SCREEN">      Red    Green    Blue 
      Cyan   Yellow   Magenta
      
</pre>будут преобразованы в
          <pre class="SCREEN">      "Red",   "Green",   "Blue" 
      "Cyan",  "Yellow",  "Magenta"     
      
</pre>или в
          <pre class="SCREEN">      &lt;table&gt; 
      &lt;tr&gt;&lt;td&gt;Red&lt;td&gt;Green&lt;td&gt;Blue 
      &lt;tr&gt;&lt;td&gt;Cyan&lt;td&gt;Yellow&lt;td&gt;Magenta 
      &lt;/table&gt;
      
</pre>Преобразование выполняется простой заменой одних символов
другими, с помощью <tt class="METHODNAME">QString::replace()</tt>. Для
экранирования специальных символов HTML используется статическая
функция <tt class="METHODNAME">QStyleSheet::escape()</tt>.
          <pre class="SCREEN">bool CellDrag::canDecode(const QMimeSource *source) 
{ 
  return source-&gt;provides("text/plain"); 
}
      
</pre>Функция <tt class="METHODNAME">canDecode()</tt> возвращает
<tt class="PARAMETER"><em>true</em></tt>, если перетаскиваемые данные
могут быть декодированы, в противном случае возвращается
          <tt class="PARAMETER"><em>false</em></tt>.<br>
          <br>

          <p>Хотя мы и предусматриваем поддержку трех форматов для
          перетаскиваемых данных, мы будем принимать только данные в
          простом текстовом виде, поскольку для наших нужд этого будет
          более чем достаточно. Если пользователь попытается
          переместить ячейки из <tt class="CLASSNAME">QTable</tt> в
          HTML-редактор, то данные будут преобразованы в HTML-таблицу.
          Но если пользователь попробует переместить произвольную
          HTML-таблицу (например, из браузера) в <tt class="CLASSNAME">QTable</tt>, то эти данные не будут восприняты
          приложением.</p>
          <pre class="SCREEN">bool CellDrag::decode(const QMimeSource *source, QString &amp;str) 
{ 
  QByteArray data = source-&gt;encodedData("text/plain");
  str = QString::fromLocal8Bit((const char *)data, data.size()); 
  return !str.isEmpty(); 
}
      
</pre>И, наконец, функция <tt class="METHODNAME">decode()</tt>
преобразует <tt class="PARAMETER"><em>text/plain</em></tt> данные в
<tt class="CLASSNAME">QString</tt>. Здесь мы предполагаем, что
используется 8-ми битная кодировка символов.<br>
          <br>

          <p>Если вы пожелаете точно указывать кодировку символов, для
          перемещаемых данных, вы можете задать параметр <tt class="PARAMETER"><em>charset</em></tt> формата <tt class="PARAMETER"><em>text/plain</em></tt>, напимер:</p>
          <pre class="SCREEN">      text/plain;charset=US-ASCII 
      text/plain;charset=ISO-8859-1 
      text/plain;charset=Shift_JIS
      
</pre>Итак. Мы закончили описание реализации класса
          <tt class="CLASSNAME">CellDrag</tt>. Нам осталось только
          интегрировать его с <tt class="CLASSNAME">QTable</tt>.
          Оказывается, класс <tt class="CLASSNAME">QTable</tt> уже
          выполняет почти все, что нам нужно. Единственное, что нам
          остается сделать -- это вызвать <tt class="METHODNAME">setDragEnabled(true)</tt> в конструкторе и
          перекрыть метод <tt class="METHODNAME">QTable::dragObject()</tt>, который будет
          возвращать <tt class="CLASSNAME">CellDrag</tt>:
          <pre class="SCREEN">QDragObject *MyTable::dragObject() 
{ 
  return new CellDrag(selectionAsString(), this); 
}
      
</pre>Мы не приводим текст функции <tt class="METHODNAME">selectionAsString()</tt>, поскольку он почти полностью
совпадает с текстом функции <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P80"><tt class="METHODNAME">
          Spreadsheet::copy()</tt></a>.<br>
          <br>

          <p>Чтобы добавить поддержку приема данных, сбрасываемых на
          таблицу, необходимо перекрыть методы <tt class="METHODNAME">contentsDragEnterEvent()</tt> и <tt class="METHODNAME">contentsDropEvent()</tt> точно так же, как мы
          это делали в приложении "Project Chooser".</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="ADVANCEDCLIPBOARDHANDLING"></a>9.3. Расширенные возможности
          буфера обмена.</h1>

          <p>Большинство приложений используют внутренние механизмы Qt,
          при работе с буфером обмена. Например, класс <tt class="CLASSNAME">QTextEdit</tt> включает в себя поддержку
          комбинаций клавиш <strong class="COMMAND">Ctrl+X,
          Ctrl+C</strong> и <strong class="COMMAND">Ctrl+V</strong>,
          которые соответствуют слотам <tt class="METHODNAME">cut(),
          copy()</tt> и <tt class="METHODNAME">paste()</tt>. В
          результате этого, от программиста не требуется написания
          специального кода, отвечающего за работу с буфером
          обмена.</p>

          <p>При написании собственных классов, вы можете получить
          доступ к буферу обмена с помощью функции <tt class="METHODNAME">QApplication::clipboard()</tt>, которая
          возвращает указатель на объект класса <tt class="CLASSNAME">QClipboard</tt>. Работа с буфером обмена на
          удивление проста и незатейлива! Чтобы поместить в него данные
          нужно лишь вызвать метод <tt class="METHODNAME">setText(),
          setImage()</tt> или <tt class="METHODNAME">setPixmap()</tt>.
          Чтобы получить данные из буфера -- <tt class="METHODNAME">text(), image()</tt> или <tt class="METHODNAME">pixmap()</tt>. В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER4">Главе 4</a>
          мы уже пробовали работать с буфером обмена, при разработке
          приложения Spreadsheet.</p>

          <p>Однако, в некоторых случаях, встроенной поддержки буфера
          обмена может оказаться недостаточно. Например, может
          потребоваться обеспечить поддержку данных, которые не
          являются ни текстом, ни рисунком. Или, с целью повышения
          совместимости с другими приложениями, необходимо будет
          организовать обмен данными в нескольких форматах. Проблема
          очень напоминает то, с чем мы уже столкнулись чуть выше,
          поэтому и решение ее практически аналогичное: необходимо
          создать дочерний класс от <tt class="CLASSNAME">QMimeSource</tt> и перекрыть методы родительского
          класса <tt class="METHODNAME">format()</tt> и <tt class="METHODNAME">encodedData().</tt>.</p>

          <p>Если в приложение включена поддержка механизма "drag
          and drop", то вы можете просто использовать уже
          существующий потомок класса <tt class="CLASSNAME">QDragObject</tt>, помещая объекты этого типа в
          буфер обмена, вызовом <tt class="METHODNAME">setData()</tt>.
          Поскольку <tt class="CLASSNAME">QDragObject</tt> ведет свою
          родословную от <tt class="CLASSNAME">QMimeSource</tt>, а
          буфер обмена умеет взаимодействовать с классом <tt class="CLASSNAME">QMimeSource</tt>, то все будет работать без
          особых проблем.</p>

          <p>Рассмотрим на примере, как можно реализовать функцию
          <tt class="METHODNAME">copy()</tt> для потомка класса
          <tt class="CLASSNAME">QTable</tt>:</p>
          <pre class="SCREEN">void MyTable::copy() 
{ 
  QApplication::clipboard()-&gt;setData(dragObject()); 
}
      
</pre>В конце предыдущего раздела мы реализовали функцию
          <tt class="METHODNAME">dragObject()</tt>, которая возвращает
          <tt class="CLASSNAME">CellDrag</tt>, предназначенный для
          хранения содержимого выделенных ячеек.<br>
          <br>

          <p>Чтобы извлечь данные из буфера обмена, необходимо
          обратиться к методу <tt class="METHODNAME">data()</tt>. Ниже
          приводится текст функции <tt class="METHODNAME">paste()</tt>
          для потомка класса <tt class="CLASSNAME">QTable</tt>:</p>
          <pre class="SCREEN">void MyTable::paste() 
{ 
  QMimeSource *source = QApplication::clipboard()-&gt;data(); 
  if (CellDrag::canDecode(source)) { 
    QString str; 
    CellDrag::decode(source, str); 
    performPaste(str); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">performPaste()</tt> -- практически
полный аналог функции <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P81"><tt class="METHODNAME">Spreadsheet::paste()</tt></a> из <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER4">
          Главы 4</a>.<br>
          <br>

          <p>Это практически все, что необходимо для расширения
          возможностей при работе с буфером обмена.</p>

          <p>Буфер обмена X11, предоставляет дополнительные
          возможности, которые недоступны в операционных системах
          Windows и Mac OS X. В X11, обычно имеется возможность вставки
          выделенной области, щелчком средней кнопки трехкнопочной
          мыши, благодаря наличию отдельного буфера
          "выделения". Если вы желаете добавить поддержку
          этого буфера обмена в свои виджеты, вам придется добавить
          дополнительный аргумент <tt class="PARAMETER"><em>QClipboard::Selection</em></tt> во все
          вызовы, обращающиеся к буферу обмена. Например, вот как можно
          реализовать обработчик события <tt class="METHODNAME">mouseReleaseEvent()</tt> в текстовом редакторе,
          который должен поддерживать вставку блоков текста по щелчку
          средней кнопки мыши:</p>
          <pre class="SCREEN">void MyTextEditor::mouseReleaseEvent(QMouseEvent *event) 
{ 
  QClipboard *clipboard = QApplication::clipboard(); 
  if (event-&gt;button() == MidButton 
          &amp;&amp; clipboard-&gt;supportsSelection()) { 
    QString text = clipboard-&gt;text(QClipboard::Selection); pasteText(text); 
  } 
}
      
</pre>На платформе X11 функция <tt class="METHODNAME">supportsSelection()</tt> возвращает <tt class="PARAMETER">
          <em>true</em></tt>, на других -- <tt class="PARAMETER"><em>false</em></tt>.
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER10"></a>Глава 10. Ввод/вывод.</h1>

        <p>Темой обсуждения этой главы будут -- чтение и запись файлов,
        навигация по файловой системе и взаимодействие с внешними
        приложениями.</p>

        <p>Qt предоставляет в ваше распоряжение два замечательных
        класса: <tt class="CLASSNAME">QDataStream</tt> и <tt class="CLASSNAME">QTextStream</tt>, которые значительно упрощают
        операции чтения-записи файлов. Они берут на себя хлопоты о
        порядке следования байт и кодировке текста, обеспечивая полную
        совместимость приложений на разных платформах.</p>

        <p>Во многих приложениях необходимо реализовать возможность
        обхода файловой системы или предоставления сведений о файлах.
        Классы <tt class="CLASSNAME">QDir</tt> и <tt class="CLASSNAME">QFileInfo</tt> возьмут на себя эту
        "черную" и "неблагодарную" работу.</p>

        <p>Иногда возникает необходимость запускать другие программы из
        нашего приложения. Класс <tt class="CLASSNAME">QProcess</tt>
        сможет выполнить это в асинхронном режиме, не
        "замораживая" интерфейс с пользователем.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="READINGANDWRITINGBINARYDATA"></a>10.1. Чтение и запись
          двоичных данных.</h1>

          <p>Чтение и запись данных произвольного формата, с помощью
          <tt class="CLASSNAME">QDataStream</tt> -- это самый простой
          способ организовать сохранение и загрузку данных в
          Qt-приложении. Он поддерживает огромное количество типов
          данных Qt, включая <tt class="CLASSNAME">QByteArray, QFont,
          QImage, QMap&lt;K, T&gt;, QPixmap, QString,
          QValueList&lt;T&gt;</tt> и <tt class="CLASSNAME">QVariant</tt>. Перечень типов данных,
          поддерживаемых <tt class="CLASSNAME">QDataStream</tt> вы
          найдете по адресу <a href="http://doc.trolltech.com/3.2/datastreamformat.html" target="_top">http://doc.trolltech.com/3.2/datastreamformat.html</a>
             .</p>

          <p>Чтобы продемонстрировать основные приемы работы с
          двоичными данными, мы напишем два класса: <tt class="CLASSNAME">Drawing</tt> и <tt class="CLASSNAME">Gallery</tt>. Первый будет хранить основные
          сведения о картине (имя художника, название и год создания),
          второй -- список картин.</p>

          <p>Начнем с класса <tt class="CLASSNAME">Gallery</tt>.</p>
          <pre class="SCREEN">class Gallery : public QObject 
{ 
public: 
  bool loadBinary(const QString &amp;fileName); 
  bool saveBinary(const QString &amp;fileName); 
  ... 
  
private: 
  enum { MagicNumber = 0x98c58f26 }; 
  
  void writeToStream(QDataStream &amp;out); 
  void readFromStream(QDataStream &amp;in); 
  void error(const QFile &amp;file, const QString &amp;message); 
  void ioError(const QFile &amp;file, const QString &amp;message); 
  
  QByteArray getData(); 
  void setData(const QByteArray &amp;data); 
  QString toString(); 
  
  std::list&lt;Drawing&gt; drawings; 
};
      
</pre>Он содержит публичные функции, которые сохраняют и загружают
данные. Данные -- это список картин. Каждый элемент списка -- это
объект класса <tt class="CLASSNAME">Drawing</tt>. Приватные функции мы
будем рассматривать по мере необходимости.<br>
          <br>

          <p>Ниже приводится исходный текст функции, сохраняющей список
          картин в двоичном виде:</p>
          <pre class="SCREEN">bool Gallery::saveBinary(const QString &amp;fileName) 
{ 
  QFile file(fileName); 
  if (!file.open(IO_WriteOnly)) { 
    ioError(file, tr("Cannot open file %1 for writing")); 
    return false; 
  } 
  
  QDataStream out(&amp;file); 
  out.setVersion(5); 
  out &lt;&lt; (Q_UINT32)MagicNumber; 
  writeToStream(out); 
  if (file.status() != IO_Ok) { 
    ioError(file, tr("Error writing to file %1")); 
    return false; 
  } 
  return true; 
}
      
</pre>Сначала мы открываем файл. Затем устанавливаем версию
          <tt class="CLASSNAME">QDataStream</tt>. Номер версии
          определяет способ сохранения различных типов данных. Базовые
          типы языка C++ всегда сохраняются в неизменном виде.<br>
          <br>

          <p>Далее в файл выводится сигнатура (число), которая
          идентифицирует файлы галереи. Чтобы обеспечить совместимость
          с другими платформами, мы приводим <tt class="VARNAME">MagicNumber</tt> к типу <tt class="CLASSNAME">Q_UINT32</tt>.</p>

          <p>Список картин выводится в файл приватной функцией
          <tt class="METHODNAME">writeToStream()</tt>. Нет
          необходимости явно закрывать файл -- это будет сделано
          автоматически, когда объект <tt class="VARNAME">QFile</tt>
          выйдет из области видимости по завершении функции.</p>

          <p>После вызова <tt class="METHODNAME">writeToStream()</tt>
          проверяется статус устройства <tt class="CLASSNAME">QFile</tt>. Если возникла ошибка -- вызывается
          <tt class="METHODNAME">ioError()</tt>, которая выводит окно с
          сообщением и вызывающей программе возвращается значение
          <tt class="PARAMETER"><em>false</em></tt>.</p>
          <pre class="SCREEN">void Gallery::ioError(const QFile &amp;file, const QString &amp;message) 
{ 
  error(file, message + ": " + file.errorString()); 
}
      
</pre>Функция <tt class="METHODNAME">ioError()</tt> вызывает более
универсальную функцию <tt class="METHODNAME">error()</tt>:
          <pre class="SCREEN">void Gallery::error(const QFile &amp;file, const QString &amp;message) 
{ 
  QMessageBox::warning(0, tr("Gallery"), message.arg(file.name())); 
}
      
</pre>Теперь рассмотрим функцию <tt class="METHODNAME">writeToStream()</tt>:
          <pre class="SCREEN">void Gallery::writeToStream(QDataStream &amp;out) 
{ 
  list&lt;Drawing&gt;::const_iterator it = drawings.begin(); 
  while (it != drawings.end()) { 
    out &lt;&lt; *it; 
    ++it; 
  } 
}
      
</pre>Она последовательно проходит по списку картин и сохраняет их одну
за другой в поток, который был передан в качестве аргумента. Если бы
мы, вместо <tt class="VARNAME">list&lt;Drawing&gt;</tt> использовали
определение <tt class="VARNAME">QValueList&lt;Drawing&gt;</tt>, мы
могли бы обойтись без цикла, просто записав:
          <pre class="SCREEN">  out &lt;&lt; drawings; 
      
</pre>Когда <tt class="VARNAME">QValueList&lt;T&gt;</tt> помещается в
поток, то каждый элемент списка записывается посредством его
собственного оператора "&lt;&lt;".
          <pre class="SCREEN">QDataStream &amp;operator&lt;&lt;(QDataStream &amp;out, const Drawing &amp;drawing) 
{ 
  out &lt;&lt; drawing.myTitle &lt;&lt; drawing.myArtist &lt;&lt; drawing.myYear; 
  return out; 
}
      
</pre>Вывод объекта <tt class="CLASSNAME">Drawing</tt> осуществляется
простой записью трех его переменных-членов: <tt class="VARNAME">
          myTitle, myArtist</tt> и <tt class="VARNAME">myYear</tt>.
          Перегруженный оператор <tt class="METHODNAME">operator&lt;&lt;()</tt> должен быть объявлен как
          "дружественный" (friend). В заключение функция
          возвращает поток. Это общепринятая в языке C++ идиома
          программирования, которая позволяет объединять операторы
          "&lt;&lt;" в цепочки, например:
          <pre class="SCREEN">  out &lt;&lt; drawing1 &lt;&lt; drawing2 &lt;&lt; drawing3;
      
</pre>Ниже приводится определение класса <tt class="CLASSNAME">
          Drawing</tt>:
          <pre class="SCREEN">class Drawing 
{ 
  friend QDataStream &amp;operator&lt;&lt;(QDataStream &amp;, const Drawing &amp;); 
  friend QDataStream &amp;operator&gt;&gt;(QDataStream &amp;, Drawing &amp;); 
  
public: 
  Drawing() { myYear = 0; } 
  Drawing(const QString &amp;title, const QString &amp;artist, int year) 
  { myTitle = title; myArtist = artist; myYear = year; } 
  
  QString title() const { return myTitle; } 
  void setTitle(const QString &amp;title) { myTitle = title; } 
  QString artist() const { return myArtist; } 
  void setArtist(const QString &amp;artist) { myArtist = artist; } 
  int year() const { return myYear; } 
  void setYear(int year) { myYear = year; } 
  
private: 
  QString myTitle; 
  QString myArtist; 
  int myYear; 
};
      
</pre>Рассмотрим функцию, которая читает файл со списком картин:
          <pre class="SCREEN">bool Gallery::loadBinary(const QString &amp;fileName) 
{ 
  QFile file(fileName); 
  if (!file.open(IO_ReadOnly)) { 
    ioError(file, tr("Cannot open file %1 for reading")); 
    return false; 
  } 
  
  QDataStream in(&amp;file); 
  in.setVersion(5); 
  
  Q_UINT32 magic; 
  in &gt;&gt; magic; 
  if (magic != MagicNumber) { 
    error(file, tr("File %1 is not a Gallery file")); 
    return false; 
  } 
  
  readFromStream(in); 
  
  if (file.status() != IO_Ok) { 
    ioError(file, tr("Error reading from file %1")); 
    return false; 
  } 
  return true; 
}
      
</pre>Файл открывается на чтение и создается объект
          <tt class="CLASSNAME">QDataStream</tt>, который будет читать
          данные из файла. Мы установили версию 5 для <tt class="CLASSNAME">QDataStream</tt>, поскольку в этой версии была
          произведена запись в файл. Использование фиксированного
          номера версии -- 5, гарантирует, что приложение всегда сможет
          читать и записывать данные, если оно собрано с Qt 3.2 или
          более поздней.<br>
          <br>

          <p>Работа с файлом начинается со считывания сигнатуры (числа)
          <tt class="VARNAME">MagicNumber</tt>. Это дает нам
          уверенность, что мы работаем с файлом, содержащим список
          картин, а не что-то иное. Затем список считывается функцией
          <tt class="METHODNAME">readFromStream()</tt>.</p>
          <pre class="SCREEN">void Gallery::readFromStream(QDataStream &amp;in) 
{ 
  drawings.clear(); 
  while (!in.atEnd()) { 
    Drawing drawing; 
    in &gt;&gt; drawing; 
    drawings.push_back(drawing); 
  } 
}
      
</pre>Функция начинается с очистки ранее находившихся в списке данных.
Затем в цикле производится считывание всех описаний картин, одного за
другим. Если бы мы, вместо <tt class="VARNAME">list&lt;Drawing&gt;</tt>
использовали определение <tt class="VARNAME">QValueList&lt;Drawing&gt;</tt>, мы могли бы обойтись без
цикла, просто записав:
          <pre class="SCREEN">  in &gt;&gt; drawings;
      
</pre>Когда <tt class="VARNAME">QValueList&lt;T&gt;</tt> получает
данные из потока, то каждый элемент списка читается посредством его
собственного оператора "&gt;&gt;".
          <pre class="SCREEN">QDataStream &amp;operator&gt;&gt;(QDataStream &amp;in, Drawing &amp;drawing) 
{ 
  in &gt;&gt; drawing.myTitle &gt;&gt; drawing.myArtist &gt;&gt; drawing.myYear; 
  return in; 
}
      
</pre>Реализация оператора "&gt;&gt;" является зеркальным
отражением оператора "&lt;&lt;". При использовании
          <tt class="CLASSNAME">QDataStream</tt> у нас не возникает
          необходимости производить синтаксический анализ в любом его
          проявлении.<br>
          <br>

          <p>При желании, читать и записывать любые двоичные данные в
          необработанном виде, можно с помощью функций <tt class="METHODNAME">readRawBytes()</tt> и <tt class="METHODNAME">writeRawBytes()</tt>.</p>

          <p>Чтение и запись данных базовых типов (таких как <tt class="CLASSNAME">Q_UINT16</tt> или <tt class="CLASSNAME">float</tt>), может производиться как операторами
          "&lt;&lt;" и "&gt;&gt;", так и с помощью
          функций <tt class="METHODNAME">readRawBytes()</tt> и
          <tt class="METHODNAME">writeRawBytes()</tt>. По-умолчанию,
          порядок следования байт, используемый <tt class="CLASSNAME">QDataStream</tt> -- "big-endian". Для
          того, чтобы изменить его на "little-endian"
          (храктерный для платформы Intel), необходимо указывать его
          явно:</p>
          <pre class="SCREEN">  stream.setByteOrder(QDataStream::LittleEndian);
      
</pre>В случае чтения/записи базовых типов языка C++, указывать версию,
через вызов <tt class="METHODNAME">setVersion()</tt>,
необязательно.<br>
          <br>

          <p>Если необходимо записать/прочитать файл, что называется
          "за один присест", то можно воспользоваться
          методами класса <tt class="CLASSNAME">QFile</tt> --
          <tt class="METHODNAME">writeBlock()</tt> и <tt class="METHODNAME">readAll()</tt>, например:</p>
          <pre class="SCREEN">  file.writeBlock(getData());
      
</pre>Данные, записанные таким образом, находятся в файле в виде
простой последовательности байт. Однако, в этом случае, вся
ответственность за структурирование и идентификацию данных при
считывании, полностью ложится на плечи разработчика. За создание списка
<tt class="CLASSNAME">QByteArray</tt> и заполнение его данными, в
классе <tt class="CLASSNAME">Gallery</tt> отвечает приватная функция
<tt class="METHODNAME">getData()</tt>. Чтение блока данных из файла
выглядит не менее просто, чем запись:
          <pre class="SCREEN">  setData(file.readAll());
      
</pre>За извлечение данных из <tt class="CLASSNAME">QByteArray</tt>, в
классе <tt class="CLASSNAME">Gallery</tt> отвечает приватная функция
<tt class="METHODNAME">setData()</tt>.<br>
          <br>

          <p>Сохранение всех данных, в виде <tt class="CLASSNAME">QByteArray</tt>, может потребовать значительного
          объема памяти, но такой способ имеет свои преимущества.
          Например, мы можем сжать данные, с помощью <tt class="METHODNAME">qCompress()</tt>, при записи в файл:</p>
          <pre class="SCREEN">  file.writeBlock(qCompress(getData()));
      
</pre>И разархивировать при считывании:
          <pre class="SCREEN">  setData(qUncompress(file.readAll()));
      
</pre>Ниже приводится один из возможных вариантов реализации функций
<tt class="METHODNAME">getData()</tt> и <tt class="METHODNAME">
          setData()</tt>:
          <pre class="SCREEN">QByteArray Gallery::getData() 
{ 
  QByteArray data; 
  QDataStream out(data, IO_WriteOnly); 
  writeToStream(out); 
  return data; 
}
      
</pre>Здесь создается поток <tt class="CLASSNAME">QDataStream</tt>,
которому в качестве устройства вывода, вместо <tt class="CLASSNAME">
          QFile</tt>, назначается <tt class="CLASSNAME">QByteArray</tt>. После этого массив заполняется
          двоичными данными, вызовом <tt class="METHODNAME">writeToStream()</tt>.<br>
          <br>

          <p>Аналогичным образом, функция <tt class="METHODNAME">setData()</tt> обращается к <tt class="METHODNAME">readFromStream()</tt>, для чтения ранее
          записанных данных:</p>
          <pre class="SCREEN">void Gallery::setData(const QByteArray &amp;data) 
{ 
  QDataStream in(data, IO_ReadOnly); 
  readFromStream(in); 
}
      
</pre>В примерах выше, мы сохраняли и считывали данные, жестко задавая
номер версии для <tt class="CLASSNAME">QDataStream</tt>. Такой подход
достаточно прост и надежен, но он имеет один маленький недостаток: мы
не сможем работать с файлами, записанными с новыми версиями. Например,
если в последующих версиях Qt, в класс <tt class="CLASSNAME">QFont</tt>
будут добавлены новые элементы, то мы лишимся возможности сохранять и
загружать компоненты этого типа, используя более старую версию
<tt class="CLASSNAME">QDataStream</tt>.<br>
          <br>

          <p>Как одно из возможных решений этой проблемы -- записывать
          в файл номер версии:</p>
          <pre class="SCREEN">  QDataStream out(&amp;file); 
  out &lt;&lt; (Q_UINT32)MagicNumber; 
  out &lt;&lt; (Q_UINT16)out.version(); 
  writeToStream(out);
      
</pre>Этот код будет выполнять запись данных, с использованием самой
последней версии <tt class="CLASSNAME">QDataStream</tt>.<br>
          <br>

          <p>При чтении таких файлов, сначала будет считываться
          сигнатура файла и номер версии <tt class="CLASSNAME">QDataStream</tt>:</p>
          <pre class="SCREEN">  QDataStream in(&amp;file); 
  
  Q_UINT32 magic; 
  Q_UINT16 streamVersion; 
  in &gt;&gt; magic &gt;&gt; streamVersion; 
  
  if (magic != MagicNumber) { 
    error(file, tr("File %1 is not a Gallery file")); 
    return false; 
  } else if ((int)streamVersion &gt; in.version()) { 
    error(file, tr("File %1 is from a more recent version of the " 
                   "application")); 
    return false; 
  } 
  in.setVersion(streamVersion); 
  readFromStream(in);
      
</pre>Чтение данных будет возможно в том случае, если номер версии
будет меньше или равен версии, используемой приложением. В противном
случае чтение завершится сообщением об ошибке.<br>
          <br>

          <p>Вместо версии <tt class="CLASSNAME">QDataStream</tt> можно
          использовать версию приложения. Например, допустим, что некий
          формат файла соответствует версии 1.3 приложения. Тогда мы
          могли бы записать следующий код:</p>
          <pre class="SCREEN">  QDataStream out(&amp;file); 
  out.setVersion(5); 
  out &lt;&lt; (Q_UINT32)MagicNumber; 
  out &lt;&lt; (Q_UINT16)0x0103; 
  writeToStream(out);
      
</pre>При чтении такого файла можно определять версию
          <tt class="CLASSNAME">QDataStream</tt>, основываясь на версии
          приложения:
          <pre class="SCREEN">  QDataStream in(&amp;file); 
  
  Q_UINT32 magic; 
  Q_UINT16 appVersion; 
  in &gt;&gt; magic &gt;&gt; appVersion; 
  
  if (magic != MagicNumber) { 
    error(file, tr("File %1 is not a Gallery file")); 
    return false; 
  } else if (appVersion &gt; 0x0103) { 
    error(file, tr("File %1 is from a more recent version of the " 
                   "application")); 
    return false; 
  } 
  
  if (appVersion &lt;= 0x0102) { 
    in.setVersion(4);
  } else { 
    in.setVersion(5); 
  } 
  readFromStream(in);
      
</pre>Этот код говорит, что для чтения данных из файла, созданного
приложением с версией 1.2 или более ранней, должна использоваться 4-я
версия <tt class="CLASSNAME">QDataStream</tt>, для чтения данных из
файла, созданного приложением с версией 1.3 -- 5-я версия
          <tt class="CLASSNAME">QDataStream</tt>.<br>
          <br>

          <p>Как только мы получаем в руки механизм определения версии
          <tt class="CLASSNAME">QDataStream</tt>, процедура чтения и
          записи двоичных данных становится простой и надежной.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="READINGANDWRITINGTEXT"></a>10.2.
          Чтение и запись текста.</h1>

          <p>Для чтения и записи текстовых данных, Qt предоставляет
          класс <tt class="CLASSNAME">QTextStream</tt>. Он может
          использоваться как для чтения/записи простого текста, так и
          для файлов с другими текстовыми форматами, такими как HTML,
          XML и файлов с исходными текстами программ. Он принимает на
          себя обязательства по преобразованию кодировки символов между
          Unicode и 8-ми битными кодировками, а так же по разному
          обрабатывает признак окончания строки, в соответствии с
          соглашениями, принятыми в различных операционных
          системах.</p>

          <p>В качестве фундаментального типа данных, <tt class="CLASSNAME">QTextStream</tt> использует <tt class="CLASSNAME">QChar</tt>. В дополнение к символьным и строковым
          данным, <tt class="CLASSNAME">QTextStream</tt> поддерживает
          базовые числовые типы языка C++, конвертируя их в/из
          строки.</p>

          <p>С целью демонстрации возможностей <tt class="CLASSNAME">QTextStream</tt>, продолжим рассмотрение
          реализации класса <tt class="CLASSNAME">Gallery</tt>. Ниже
          приводится исходный текст функции <tt class="METHODNAME">saveText()</tt>, которая сохраняет список картин
          в простой текстовый файл:</p>
          <pre class="SCREEN">bool Gallery::saveText(const QString &amp;fileName) 
{ 
  QFile file(fileName); 
  if (!file.open(IO_WriteOnly | IO_Translate)) { 
    ioError(file, tr("Cannot open file %1 for writing")); 
    return false; 
  } 
  
  QTextStream out(&amp;file); 
  out.setEncoding(QTextStream::UnicodeUTF8); 
  
  list&lt;Drawing&gt;::const_iterator it = drawings.begin(); 
  while (it != drawings.end()) { 
    out &lt;&lt; *it; 
    ++it; 
  } 
  if (file.status() != IO_Ok) { 
    ioError(file, tr("Error writing to file %1")); 
    return false; 
  } 
  return true; 
}
      
</pre>При открытии файла используется флаг <tt class="PARAMETER">
          <em>IO_Translate</em></tt>, чтобы корректным образом
          перевести символ перевода строки в последовательность
          символов, которая соответствует используемой операционной
          системе ("/r/n" -- для Windows, "/r" --
          для Mac OS X). Затем устанавливается кодировка символов
          UTF-8, совместимая с ASCII. (За дополнительной информацией об
          Unicode, см. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER15">Главу 15</a>.) После этого,
          в цикле, в файл выводятся описания картин, с помощью
          перегруженного оператора "&lt;&lt;":
          <pre class="SCREEN">QTextStream &amp;operator&lt;&lt;(QTextStream &amp;out, const Drawing &amp;drawing) 
{ 
  out &lt;&lt; drawing.myTitle &lt;&lt; ":" &lt;&lt; drawing.myArtist &lt;&lt; ":" 
      &lt;&lt; drawing.myYear &lt;&lt; endl; 
  return out; 
}
      
</pre>При записи сведений о картине, в качестве разделителя полей,
используется символ двоеточия. Каждая запись в файле завершается
символом перевода строки. При этом мы исходим из предположения, что ни
имя художника, ни название картины не содержат символов двоеточия или
перевода строки.<br>
          <br>

          <p>Ниже показан пример содержимого файла, созданного функцией
          <tt class="METHODNAME">saveText()</tt>:</p>
          <pre class="SCREEN">      The False Shepherds:Hans Bol:1576 
      Panoramic Landscape:Jan Brueghel the Younger:1619 
      Dune Landscape:Jan van Goyen:1630 
      River Delta:Jan van Goyen:1653
      
</pre>Теперь перейдем к функции чтения файла:
          <pre class="SCREEN">bool Gallery::loadText(const QString &amp;fileName) 
{ 
  QFile file(fileName); 
  if (!file.open(IO_ReadOnly | IO_Translate)) { 
    ioError(file, tr("Cannot open file %1 for reading")); 
    return false; 
  } 
  
  drawings.clear(); 
  QTextStream in(&amp;file); 
  in.setEncoding(QTextStream::UnicodeUTF8); 
  
  while (!in.atEnd()) { 
    Drawing drawing; 
    in &gt;&gt; drawing; 
    drawings.push_back(drawing); 
  } 
  
  if (file.status() != IO_Ok) { 
    ioError(file, tr("Error reading from file %1")); 
    return false; 
  } 
  return true; 
}
      
</pre>Все самое интересное в этой функции, заключено внутри цикла
<tt class="METHODNAME">while</tt>. Он выполняет чтение данных, с
помощью оператора "&gt;&gt;", до тех пор, пока не будет
достигнут конец файла.<br>
          <br>

          <p>Реализация оператора "&gt;&gt;" не так
          тривиальна, поскольку представление текстовых данных не так
          однозначно. Рассмотрим следующий пример:</p>
          <pre class="SCREEN">  out &lt;&lt; "alpha" &lt;&lt; "bravo";
      
</pre>Если исходить из того, что <tt class="VARNAME">out</tt> -- это
экземпляр класса <tt class="CLASSNAME">QTextStream</tt>, то в файл
фактически будет записана одна строка "alphabravo". Мы не
сможем прочитать данные, просто написав:
          <pre class="SCREEN">  in &gt;&gt; str1 &gt;&gt; str2;
      
</pre>Фактически, в переменную <tt class="VARNAME">str1</tt> будет
записана строка "alphabravo", а в переменную
          <tt class="VARNAME">str2</tt> -- ничего.<br>
          <br>

          <p>Если записываемый текст состоит из отдельных слов, мы
          можем вставлять пробелы между ними и затем читать этот текст
          слово за словом. (Этот подход был реализован в функциях
          <tt class="METHODNAME">DiagramView::copy()</tt> и <tt class="METHODNAME">DiagramView::paste()</tt>, в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER8">Главе 8</a>.) Но в данном случае этот вариант не
          подходит, поскольку имя художника и название картины могут
          состоять более чем из одного слова. Поэтому, за один раз
          читается целая строка и затем разбивается на элементы, с
          помощью функции <tt class="METHODNAME">QStringList::split()</tt> :</p>
          <pre class="SCREEN">QTextStream &amp;operator&gt;&gt;(QTextStream &amp;in, Drawing &amp;drawing) 
{ 
  QString str = in.readLine(); 
  QStringList fields = QStringList::split(":", str); 
  if (fields.size() == 3) { 
    drawing.myTitle = fields[0]; 
    drawing.myArtist = fields[1]; 
    drawing.myYear = fields[2].toInt(); 
  } 
  return in; 
}
      
</pre>Текстовые файлы могут читаться за один прием, с помощью
          <tt class="METHODNAME">QTextStream::read()</tt>:
          <pre class="SCREEN">  QString wholeFile = in.read();
      
</pre>В переменной, конец каждой строки будет отмечен символом
'\n', независимо от используемой операционной системы.<br>

          <br>

          <p>Считывание файла за раз может оказаться удобным решением,
          если данные должны пройти предварительную обработку,
          например:</p>
          <pre class="SCREEN">  wholeFile.replace("&amp;", "&amp;amp;"); 
  wholeFile.replace("&lt;", "&amp;lt;"); 
  wholeFile.replace("&gt;", "&amp;gt;");
      
</pre>Чтобы записать данные в файл за одно обращение, можно сначала
разместить их в переменной, а затем вывести на диск:
          <pre class="SCREEN">QString Gallery::saveToString() 
{ 
  QString result; 
  QTextOStream out(&amp;result); 
  list&lt;Drawing&gt;::const_iterator it = drawings.begin(); 
  while (it != drawings.end()) { 
    out &lt;&lt; *it; 
    ++it; 
  }
  return result; 
}
      
</pre>Связать поток со строковой переменной так же просто, как и
связать поток с файлом.
          <pre class="SCREEN">void Gallery::readFromString(const QString &amp;data) 
{ 
  QString string = data; 
  drawings.clear(); 
  QTextIStream in(&amp;string); 
  while (!in.atEnd()) { 
    Drawing drawing; 
    in &gt;&gt; drawing; 
    drawings.push_back(drawing); 
  } 
}
      
</pre>Запись текстовых данных -- довольно простая операция, а вот
чтение их может оказаться довольно сложной задачей. В случае
использования сложных форматов может потребоваться написать полноценный
синтаксический анализатор. Как правило, подобные анализаторы считывают
текст символ за символом, с помощью оператора "&gt;&gt;" в
переменную типа <tt class="CLASSNAME">QChar</tt> или построчно, с
помощью <tt class="METHODNAME">readLine()</tt> и затем анализируют
полученную строку.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="HANDLINGFILESANDDIRECTORIES"></a>10.3. Работа с файлами и
          каталогами.</h1>

          <p>Класс <tt class="CLASSNAME">QDir</tt> дает возможность
          навигации по файловой системе и получать информацию о файлах,
          независимо от типа операционной системы. Чтобы показать
          некоторые особенности класса <tt class="CLASSNAME">QDir</tt>,
          напишем небольшое консольное приложение, которое подсчитывает
          суммарный объем всех файлов с изображениями в заданном
          каталоге и вложенных подкаталогах.</p>

          <p>Основу приложения составляет функция <tt class="METHODNAME">imageSpace()</tt>, которая суммирует размеры
          файлов в заданном каталоге:</p>
          <pre class="SCREEN">int imageSpace(const QString &amp;path) 
{ 
  QDir dir(path); 
  QStringList::Iterator it; 
  int size = 0; 
  
  QStringList files = dir.entryList("*.png *.jpg *.jpeg", 
                                    QDir::Files); 
  it = files.begin(); 
  while (it != files.end()) { 
    size += QFileInfo(path, *it).size(); 
    ++it; 
  } 
  
  QStringList dirs = dir.entryList(QDir::Dirs); 
  it = dirs.begin(); 
  while (it != dirs.end()) { 
    if (*it != "." &amp;&amp; *it != "..") 
      size += imageSpace(path + "/" + *it);
    ++it; 
  } 
  return size; 
}
      
</pre>Начинается она с создания экземпляра класса <tt class="CLASSNAME">QDir</tt>, с заданным полным именем каталога. Затем
вызывается функция <tt class="METHODNAME">entryList()</tt>, которой
передаются два аргумента. Первый из них -- это список шаблонов имен
файлов, разделенных пробелами. В шаблонах допускается указывать символы
подстановки '*' и '?'. В данном примере будут
учитываться только файлы изображений, в форматах JPEG и PNG. Второй
аргумент определяет тип элементов результирующего списка (обычные
файлы, каталоги, устройства и пр.).<br>
          <br>

          <p>Затем, в цикле, осуществляется проход по списку файлов и
          суммируются их размеры. Класс <tt class="CLASSNAME">QFileInfo</tt> позволяет получить доступ к таким
          характеристикам файла, как размер, права доступа, владелец и
          время (создания, последнего обращения, последнего
          изменения).</p>

          <p>Вторым обращением к <tt class="METHODNAME">entryList()</tt> создается список вложенных
          подкаталогов. После чего, в цикле, выполняется проход по
          подкаталогам, с рекурсивным вызовом <tt class="METHODNAME">imageSpace()</tt> для каждого из них.</p>

          <p>Полный путь к вложенным подкаталогам
          "собирается" из полного пути к текущему каталогу,
          символа слэша и имени подкаталога (<tt class="VARNAME">*it</tt>). Класс <tt class="CLASSNAME">QDir</tt>
          интерпретирует символ "/" как разделитель имен
          каталогов независимо от используемой операционной системы.
          Перед выводом полного пути перед пользователем, можно вызвать
          функцию <tt class="METHODNAME">QDir::convertSeparators()</tt>, которая
          преобразует символ "/" в корректное представление,
          в зависимости от используемой платформы.</p>

          <p>Добавим в нашу программу функцию <tt class="METHODNAME">main()</tt>:</p>
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  QString path = QDir::currentDirPath(); 
  if (argc &gt; 1) 
    path = argv[1]; 
  
  cerr &lt;&lt; "Space used by images in " &lt;&lt; endl 
       &lt;&lt; path.ascii() &lt;&lt; endl 
       &lt;&lt; "and its subdirectories is " 
       &lt;&lt; (imageSpace(path) / 1024) &lt;&lt; " KB" &lt;&lt; endl; 
  return 0; 
}
      
</pre>В этом примере мы не создавали объект класса <tt class="CLASSNAME">QApplication</tt>, потому что мы воспользовались только
инструментальными классами, не имеющими отношения к графическому
интерфейсу. Полный список таких классов вы найдете по адресу:
          <a href="http://doc.trolltech.com/3.2/tools.html" target="_top">http://doc.trolltech.com/3.2/tools.html</a>.<br>
          <br>

          <p>Для начальной инициализации переменной <tt class="CLASSNAME">path</tt> была использована функция <tt class="METHODNAME">QDir::currentDirPath()</tt>, которая возвращает
          полное имя текущего каталога. В качестве альтернативы можно
          было бы использовать функцию <tt class="METHODNAME">QDir::homeDirPath()</tt>, возвращающую полный
          путь к домашнему каталогу пользователя. Если путь к каталогу
          задается пользователем из командной строки, то он замещает
          значение по-умолчанию. В заключение вызывается функция
          <tt class="METHODNAME">imageSpace()</tt>, которая
          подсчитывает суммарный размер всех файлов с
          изображениями.</p>

          <p>Класс <tt class="CLASSNAME">QDir</tt> предоставляет ряд
          других функций, для работы с каталогами и файлами, среди них:
          <tt class="METHODNAME">rename(), exists(), mkdir()</tt> и
          <tt class="METHODNAME">rmdir()</tt>.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="INTERPROCESSCOMMUNICATION"></a>10.4. Взаимодействия между
          процессами.</h1>

          <p>Класс <tt class="CLASSNAME">QProcess</tt> позволяет
          запускать и взаимодействовать с другими программами.
          Экземпляры класса работают асинхронно, выполняя всю работу в
          фоновом режиме, что не приводит к "замораживанию"
          пользовательского интерфейса. <tt class="CLASSNAME">QProcess</tt> может известить приложение о
          завершении запущенной им программы или о наличии данных,
          полученных от нее, выдавая соответствующие сигналы.</p>

          <p>В демонстрационных целях напишем небольшое приложение,
          которое предоставит пользователю интерфейс с внешней
          программой преобразования графических файлов. Для данного
          примера будет использоваться программа <tt class="FILENAME">convert</tt> из пакета ImageMagick, которая
          доступна для большинства платформ.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig10.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 10.1. Внешний вид приложения Image
              Converter.</p>
            </div>
          </div><br>
          Форма приложения была разработана в среде визуального
          построителя интерфейсов <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>. Соответствующий
          <tt class="FILENAME">.ui</tt> находится на CD, сопровождающем
          книгу. Здесь же мы сконцентрируем все свое внимание на
          содержимом файла <tt class="FILENAME">.ui.h</tt>, который
          содержит исходный код. Обратите внимание: переменные
          <tt class="VARNAME">process</tt> и <tt class="VARNAME">fileFilters</tt> были объявлены в <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>, на
          вкладке <strong class="COMMAND">Members</strong> следующим
          образом:
          <pre class="SCREEN">    QProcess *process; 
    QString fileFilters;
      
</pre>Утилита <tt class="FILENAME">uic</tt> добавляет эти переменные в
класс <tt class="CLASSNAME">ConvertDialog</tt>.
          <pre class="SCREEN">void ConvertDialog::init() 
{ 
  process = 0; 
  QStringList imageFormats = QImage::outputFormatList(); 
  targetFormatComboBox-&gt;insertStringList(imageFormats); 
  fileFilters = tr("Images") + " (*." + 
                imageFormats.join(" *.").lower() + ")"; 
}
      
</pre>Переменная <tt class="VARNAME">fileFilters</tt> содержит текст
описания и один, или более, шаблонов имен файлов (например, "Text
files (*.txt)"). Функция <tt class="METHODNAME">QImage::outputFormatList()</tt> возвращает список форматов
изображений, поддерживаемых Qt. Этот список тесно связан с опциями,
выбранными при установке библиотки.
          <pre class="SCREEN">void ConvertDialog::browse() 
{ 
  QString initialName = sourceFileEdit-&gt;text(); 
  if (initialName.isEmpty()) 
    initialName = QDir::homeDirPath(); 
  QString fileName = 
          QFileDialog::getOpenFileName(initialName, fileFilters, 
                                       this); 
  fileName = QDir::convertSeparators(fileName); 
  if (!fileName.isEmpty()) { 
    sourceFileEdit-&gt;setText(fileName); 
    convertButton-&gt;setEnabled(true); 
  } 
}
      
</pre>Кнопка <strong class="COMMAND">Browse</strong> связана со слотом
<tt class="METHODNAME">browse()</tt>. Если ранее пользователь уже
выбирал файл, то путь поиска, для диалога выбора файла, назначается
исходя из полного имени предыдущего файла, в противном случае,
открывается домашний каталог.
          <pre class="SCREEN">void ConvertDialog::convert() 
{ 
  QString sourceFile = sourceFileEdit-&gt;text(); 
  targetFile = QFileInfo(sourceFile).dirPath() + QDir::separator() 
               + QFileInfo(sourceFile).baseName(); 
  targetFile += "."; 
  targetFile += targetFormatComboBox-&gt;currentText().lower(); 
  convertButton-&gt;setEnabled(false); 
  outputTextEdit-&gt;clear(); 
  process = new QProcess(this); 
  process-&gt;addArgument("convert"); 
  if (enhanceCheckBox-&gt;isChecked()) 
    process-&gt;addArgument("-enhance"); 
  if (monochromeCheckBox-&gt;isChecked()) 
    process-&gt;addArgument("-monochrome"); 
  process-&gt;addArgument(sourceFile); 
  process-&gt;addArgument(targetFile); 
  connect(process, SIGNAL(readyReadStderr()), 
          this, SLOT(updateOutputTextEdit())); 
  connect(process, SIGNAL(processExited()), 
          this, SLOT(processExited())); 
  process-&gt;start(); 
}
      
</pre>Кнопка <strong class="COMMAND">Convert</strong> связана со слотом
<tt class="METHODNAME">convert()</tt>. По сигналу от кнопки собирается
имя целевого файла, из имени исходного файла и расширения,
соответствующего заданному формату.<br>
          <br>

          <p>Затем создается экземпляр класса <tt class="CLASSNAME">QProcess</tt>. После этого собирается список
          аргументов командной строки, с помощью функции <tt class="METHODNAME">addArgument()</tt>. Первым идет имя файла
          внешней программы. Далее следуют аргументы, которые будут ей
          передаваться.</p>

          <p>После создания списка аргументов производится соединение
          сигнала <tt class="METHODNAME">readyReadStderr()</tt>, класса
          <tt class="CLASSNAME">QProcess</tt>, со слотом <tt class="METHODNAME">updateOutputTextEdit()</tt> диалогового окна,
          чтобы выводить в <tt class="CLASSNAME">QTextEdit</tt>
          сообщения от внешней программы, по мере их поступления. И
          затем соединяется сигнал <tt class="METHODNAME">processExited()</tt>, класса <tt class="CLASSNAME">QProcess</tt>, со слотом <tt class="METHODNAME">processExited()</tt> диалогового окна.</p>
          <pre class="SCREEN">void ConvertDialog::updateOutputTextEdit() 
{ 
  QByteArray data = process-&gt;readStderr(); 
  QString text = outputTextEdit-&gt;text() + QString(data); 
  outputTextEdit-&gt;setText(text); 
}
      
</pre>Как только внешняя программа выдаст что нибудь на
          <tt class="FILENAME">stderr</tt>, будет вызван слот
          <tt class="METHODNAME">updateOutputTextEdit()</tt>. Сообщение
          будет прочитано и записано в <tt class="CLASSNAME">QTextEdit</tt>.
          <pre class="SCREEN">void ConvertDialog::processExited() 
{ 
  if (process-&gt;normalExit()) { 
    outputTextEdit-&gt;append(tr("File %1 created") 
                              .arg(targetFile)); 
  } else { 
    outputTextEdit-&gt;append(tr("Conversion failed")); 
  } 
  delete process; 
  process = 0; 
  convertButton-&gt;setEnabled(true); 
}
      
</pre>По завершении внешнего процесса перед пользователем выводится
соответствующее сообщение, после чего процесс удаляется.<br>
          <br>

          <p>Создание графического интерфейса, для консольных
          приложений, подобным образом, может оказаться очень полезным,
          потому что позволяет использовать функциональность,
          заложенную в уже существующие программы и нам не нужно ломать
          голову над собственной реализацией.</p>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER11"></a>Глава 11. Контейнерные классы.</h1>

        <p>Контейнерные классы -- это универсальные шаблонные классы,
        предназначенные для хранения элементов заданного типа в смежных
        областях памяти. Стандарт C++ уже включает в себя большое
        количество контейнеров, как часть STL (Standard Template
        Library -- Стандартная Библиотека Шаблонов).</p>

        <p>Qt имеет свой набор шаблонных классов. Таким образом, при
        создании программ разработчик может использовать как
        контейнерные классы из библиотеки Qt, так и классы из STL. Если
        вы уже знакомы с контейнерами из STL, то мы не видим веских
        причин для того, чтобы насильно заставлять себя переходить на
        использование контейнеров из Qt.</p>

        <p>В этой главе мы рассмотрим наиболее важные контейнеры из STL
        и Qt. Мы так же поближе рассмотрим классы <tt class="CLASSNAME">QString</tt> и <tt class="CLASSNAME">QVariant</tt>,
        которые имеют много общего с контейнерами и в отдельных случаях
        могут использоваться как альтернатива контейнерам.</p>

        <p>Начальные сведения о классах и функциях STL вы найдете по
        адресу: <a href="http://www.sgi.com/tech/stl/" target="_top">http://www.sgi.com/tech/stl/</a>.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="VECTORS"></a>11.1. Векторы.</h1>

          <p>Классы векторов, списков и словарей (map) -- это шаблонные
          классы, параметризуемые типом объектов, которые
          предполагается хранить в контейнере. Значения, которые
          хранятся в контейнерах, могут быть базового типа (например
          <tt class="CLASSNAME">int</tt> или <tt class="CLASSNAME">double</tt>), указателями или классами, которые
          имеют конструктор по-умолчанию (конструктор, у которого нет
          входных аргументов или все входные аргументы имеют значения
          по-умолчанию), конструктор копирования и перегруженный
          оператор присваивания. Среди классов, которые отвечают этим
          требованиям, можно назвать <tt class="CLASSNAME">QDateTime,
          QRegExp, QString</tt> и <tt class="CLASSNAME">QVariant</tt>.
          Классы Qt, которые наследуют <tt class="CLASSNAME">QObject</tt>, не могут быть помещены в
          контейнеры, поскольку у них нет конструктора копирования и
          оператора присваивания. Однако, это не является большой
          проблемой, поскольку сохраняется возможность помещать в
          контейнеры указатели этих типов.</p>

          <p>В этом разделе мы рассмотрим наиболее общие операции над
          векторами, а в следующих двух разделах расскажем о списках и
          словарях (map). Большая часть примеров, рассматриваемых в
          этой главе, будет основана на классе <tt class="CLASSNAME">Film</tt>, который хранит название фильма и его
          продолжительность. (Мы отказались от более подходящего для
          этого случая названия <tt class="CLASSNAME">Movie</tt>,
          потому что это имя очень похоже на <tt class="CLASSNAME">QMovie</tt> -- класс Qt, который предназначен для
          показа анимированных изображений.)</p>

          <p>Ниже приводится определение класса <tt class="CLASSNAME">Film</tt>:</p>
          <pre class="SCREEN">class Film 
{ 
public: 
  Film(int id = 0, const QString &amp;title = "", int duration = 0); 
  
  int id() const { return myId; } 
  void setId(int catalogId) { myId = catalogId; } 
  QString title() const { return myTitle; } 
  void setTitle(const QString &amp;title) { myTitle = title; } 
  int duration() const { return myDuration; } 
  void setDuration(int minutes) { myDuration = minutes; } 
  
private: 
  int myId; 
  QString myTitle; 
  int myDuration; 
};

int operator==(const Film &amp;film1, const Film &amp;film2); 
int operator&lt;(const Film &amp;film1, const Film &amp;film2);
      
</pre>Мы не включили в класс явное определение конструктора копирования
и оператора присваивания, потому что они предоставляются C++
автоматически. Если бы наш класс выполнял дополнительное резервирование
памяти, под данные-члены, тогда нам пришлось бы включить в него явную
реализацию конструктора копирования и оператора присваивания.<br>

          <br>

          <p>В дополнение к классу мы реализовали два оператора
          сравнения -- "равно" и "меньше". Оператор
          "равно" используется для поиска элемента в
          контейнере. Оператор "меньше" -- используется для
          нужд сортировки. В данной ситуации нет необходимости
          реализовать четыре других оператора сравнения
          ("!=", "&lt;=", "&gt;",
          "&gt;="), поскольку STL никогда ими не
          пользуется.</p>

          <p>Ниже приводится исходный код трех функций:</p>
          <pre class="SCREEN">Film::Film(int id, const QString &amp;title, int duration) 
{ 
  myId = id; 
  myTitle = title; 
  myDuration = duration; 
} 

int operator==(const Film &amp;film1, const Film &amp;film2) 
{ 
  return film1.id() == film2.id(); 
} 

int operator&lt;(const Film &amp;film1, const Film &amp;film2) 
{ 
  return film1.id() &lt; film2.id(); 
}
      
</pre>При сравнивании экземпляров <tt class="CLASSNAME">Film</tt>,
используются их числовые идентификаторы, а не названия, поскольку к
названию фильма не предъявляется требование уникальности.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig11.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 11.1. Вектор экземпляров класса <tt class="CLASSNAME">Film</tt>.</p>
            </div>
          </div><br>
          Вектор -- это структура данных, которая хранит элементы,
          подобно обычному массиву. Главное отличие вектора от массива
          C++ состоит в том, что вектор всегда "знает",
          сколько элементов он хранит, и может динамически изменять
          свой размер. Добавление новых элементов в конец вектора
          выполняется очень быстро, но операция по вставке новых
          элементов в начало или в середину вектора требует
          значительных затрат по времени.<br>
          <br>

          <p>В STL, класс вектора носит имя <tt class="CLASSNAME">std::vector&lt;T&gt;</tt> и определен в заголовке
          <tt class="FILENAME">&lt;vector&gt;</tt>. Объявить вектор,
          который будет хранить массив экземпляров класса <tt class="CLASSNAME">Film</tt>, можно так:</p>
          <pre class="SCREEN">vector&lt;Film&gt; films;
      
</pre>Эквивалентное объявление, использующее класс Qt --
          <tt class="CLASSNAME">QValueVector&lt;T&gt;</tt>:
          <pre class="SCREEN">QValueVector&lt;Film&gt; films;
      
</pre>Вектор, созданный подобным образом, изначально имеет размер 0.
Если заранее известно количество элементов в векторе, можно явно
указать начальный размер в определении и с помощью оператора "[
]" присвоить значения его элементам.<br>
          <br>

          <p>Очень удобно заполнять вектор с помощью функции <tt class="METHODNAME">push_back()</tt>. Она добавляет указанный
          элемент в конец вектора, увеличивая его размер на 1:</p>
          <pre class="SCREEN">films.push_back(Film(4812, "A Hard Day's Night", 85)); 
films.push_back(Film(5051, "Seven Days to Noon", 94)); 
films.push_back(Film(1301, "Day of Wrath", 105)); 
films.push_back(Film(9227, "A Special Day", 110)); 
films.push_back(Film(1817, "Day for Night", 116));
      
</pre>Как правило, Qt предоставляет функции с теми же именами, что и
STL, но в некоторых случаях Qt добавляет к классам дополнительные
методы, с более интуитивно понятными именами. Например, классы Qt могут
добавлять элементы как с помощью метода <tt class="METHODNAME">
          push_back()</tt>, так и с помощью дополнительного метода
          <tt class="METHODNAME">append()</tt>.<br>
          <br>

          <p>Еще один способ заполнения вектора состоит в том, чтобы
          задать при объявлении его начальный размер, а потом выполнить
          инициализацию отдельных элементов:</p>
          <pre class="SCREEN">vector&lt;Film&gt; films(5);

films[0] = Film(4812, "A Hard Day's Night", 85); 
films[1] = Film(5051, "Seven Days to Noon", 94); 
films[2] = Film(1301, "Day of Wrath", 105); 
films[3] = Film(9227, "A Special Day", 110); 
films[4] = Film(1817, "Day for Night", 116);
      
</pre>Элементы вектора, которые не были инициализированы явно,
приобретают значения, присвоенные конструктором по-умолчанию. В случае
базовых типов языка C++ и указателей, начальные значения элементов
вектора не определены, аналогично локальным переменным, размещаемым на
стеке.<br>
          <br>

          <p>Векторы допускают обход всех элементов в цикле, с
          использованием оператора "[ ]":</p>
          <pre class="SCREEN">  for (int i = 0; i &lt; (int)films.size(); ++i) 
    cerr &lt;&lt; films[i].title().ascii() &lt;&lt; endl;
      
</pre>В качестве альтернативы -- можно использовать итератор:
          <pre class="SCREEN">  vector&lt;Film&gt;::const_iterator it = films.begin(); 
  while (it != films.end()) { 
    cerr &lt;&lt; (*it).title().ascii() &lt;&lt; endl; 
    ++it; 
  }
      
</pre>Каждый контейнерный класс имеет два типа итераторов:
          <tt class="CLASSNAME">iterator</tt> и <tt class="CLASSNAME">const_iterator</tt>. Различие между ними
          заключается в том, что <tt class="CLASSNAME">const_iterator</tt> не позволяет модифицировать
          элементы вектора.<br>
          <br>

          <p>Функция-член контейнера -- <tt class="METHODNAME">begin()</tt> возвращает итератор, который
          ссылается на первый элемент в контейнере (например,
          <tt class="VARNAME">films[0]</tt>). Функция-член контейнера
          -- <tt class="METHODNAME">end()</tt> возвращает итератор,
          который ссылается на элемент "следующий за
          последним" (например, <tt class="VARNAME">films[5]</tt>). Если контейнер пуст, значения,
          возвращаемые функциями <tt class="METHODNAME">begin()</tt> и
          <tt class="METHODNAME">end()</tt>, эквивалентны. Это
          обстоятельство может использоваться для проверки наличия
          элементов в контейнере, хотя для этой цели гораздо удобнее
          использовать функцию <tt class="METHODNAME">empty()</tt>.</p>

          <p>Итераторы обладают интуитивно понятным синтаксисом,
          который напоминает синтаксис указателей языка C++. Для
          перемещения к следующему или предыдущему элементу, можно
          использовать операторы "++" b "--", а
          унарный "*" -- для получения доступа к элементу
          контейнера, находящемуся в позиции итератора.</p>

          <p>Если необходимо отыскать некоторый элемент в векторе,
          можно воспользоваться функцией STL -- <tt class="METHODNAME">find()</tt>:</p>
          <pre class="SCREEN">  vector&lt;Film&gt;::iterator it = find(films.begin(), films.end(), 
                                      Film(4812)); 
  if (it != films.end()) 
    films.erase(it);
      
</pre>Она возвращает итератор, указывающий на первый встретившийся
элемент вектора, отвечающий критериям поиска (элементы контейнера
сравниваются перегруженным <tt class="METHODNAME">operator==()</tt> с
последним аргументом функции). Определение функции находится в
заголовке <tt class="FILENAME">&lt;algorithm&gt;</tt>, где вы найдете
множество других шаблонных функций. Qt предоставляет аналоги некоторых
из них, правда под другими именами (например, <tt class="METHODNAME">
          qFind()</tt>). Вы можете использовать их, если не желаете
          пользоваться библиотекой STL.<br>
          <br>

          <p>Сортировка элементов вектора может быть произведена
          функцией <tt class="METHODNAME">sort()</tt>:</p>
          <pre class="SCREEN">  sort(films.begin(), films.end());
      
</pre>Для сравнения элементов вектора она использует оператор
"&lt;", если явно не указывается другая функция сравнения. На
отсортированных векторах, для поиска некоторого элемента может
использоваться функция <tt class="METHODNAME">binary_search()</tt>. Она
дает результат, аналогичный <tt class="METHODNAME">find()</tt> (при
условии, что в векторе нет двух фильмов с одинаковыми числовыми
идентификаторами), но при этом работает намного быстрее.
          <pre class="SCREEN">  int id = 1817; 
  if (binary_search(films.begin(), films.end(), Film(id))) 
    cerr &lt;&lt; "Found " &lt;&lt; id &lt;&lt; endl;
      
</pre>В позицию итератора, с помощью функции <tt class="METHODNAME">
          insert()</tt>, может быть вставлен новый элемент или удален
          существующий, с помощью функции <tt class="METHODNAME">erase()</tt>:
          <pre class="SCREEN">  films.erase(it);
      
</pre>Элементы, которые следуют за удаляемым будут перемещены на одну
позицию влево (или выше, если хотите) и размер вектора будет уменьшен
на 1 элемент.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="LISTS"></a>11.2. Списки.</h1>

          <p>Список (если быть более точным -- связанный список) -- это
          структура данных, которая может хранить элементы списка в
          областях памяти с произвольным размещением. В отличие от
          векторов, списки не предоставляют такого количества способов
          произвольного доступа к своим элементам, как векторы, но с
          другой стороны, функции <tt class="METHODNAME">insert()</tt>
          и <tt class="METHODNAME">erase()</tt> исполняются очень
          быстро.</p>

          <p>Большинство алгоритмов работы с векторами не применимы к
          спискам, в особенности это относится к функциям <tt class="METHODNAME">sort()</tt> и <tt class="METHODNAME">binary_search()</tt>, по причине того, что
          списки не обладают возможностью быстрого доступа к
          произвольному элементу. Сортировка STL-списков выполняется
          функцией <tt class="METHODNAME">sort()</tt>.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig11.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 11.2. Список экземпляров класса <tt class="CLASSNAME">Film</tt>.</p>
            </div>
          </div><br>
          Класс списка в STL называется как <tt class="CLASSNAME">std::list&lt;T&gt;</tt>, и определен в заголовке
          <tt class="FILENAME">&lt;list&gt;</tt>. Например:
          <pre class="SCREEN">  list&lt;Film&gt; films;
      
</pre>Эквивалентный класс в Qt -- <tt class="CLASSNAME">QValueList&lt;T&gt;;</tt>:
          <pre class="SCREEN">  QValueList&lt;Film&gt; films;
      
</pre>Новый элемент может быть добавлен в список вызовом функции
<tt class="METHODNAME">push_back()</tt> или <tt class="METHODNAME">
          insert()</tt>. В отличие от векторов, вставка элемента в
          начало или в середину списка выполняется так же быстро, как и
          добавление элемента в конец списка.<br>
          <br>

          <p>В STL, списки не имеют оператора "[ ]", поэтому,
          для выбора нужного элемента приходится использовать
          итераторы. (Списки Qt поддерживают оператор "[ ]",
          но на больших списках он может работать очень медленно.)
          Синтаксис и порядок использования аналогичен векторам,
          например:</p>
          <pre class="SCREEN">  list&lt;Film&gt;::const_iterator it = films.begin(); 
  while (it != films.end()) { 
    cerr &lt;&lt; (*it).title().ascii() &lt;&lt; endl; 
    ++it; 
  }
      
</pre>Списки предоставляют практически тот же набор функций, что и
векторы, включая <tt class="METHODNAME">empty(), size(), erase()</tt> и
<tt class="METHODNAME">clear()</tt>. Функция <tt class="METHODNAME">
          find()</tt> так же имеется.<br>
          <br>

          <p>Некоторые функции Qt возвращают <tt class="CLASSNAME">QValueList&lt;T&gt;</tt>. Если есть необходимость
          пройти в цикле по списку, то нужно создать копию списка и
          выполнить проход по копии. Ниже представлен пример корректной
          работы со списком <tt class="CLASSNAME">QValueList&lt;int&gt;</tt>, который возвращает
          <tt class="METHODNAME">QSplitter::sizes()</tt>:</p>
          <pre class="SCREEN">  QValueList&lt;int&gt; list = splitter-&gt;sizes(); 
  QValueList&lt;int&gt;::const_iterator it = list.begin(); 
  while (it != list.end()) { 
    do_something(*it); 
    ++it; 
  }
      
</pre>Следующий код -- неправильный:
          <pre class="SCREEN">  // НЕВЕРНО!
  QValueList&lt;int&gt;::const_iterator it = splitter-&gt;sizes().begin(); 
  while (it != splitter-&gt;sizes().end()) { 
    do_something(*it); 
    ++it; 
  }
      
</pre>Это происходит потому, что <tt class="METHODNAME">QSplitter::sizes()</tt> возвращает результат по значению.
Если не сохранить его копию, C++ автоматически удалит его еще до того
как начнется итерация. Всегда создавайте копию контейнера,
возвращаемого по значению, когда требуется получить для него
итератор.<br>
          <br>

          <p>На первый взгляд, операция создания копии может показаться
          ресурсоемкой, но это не так, благодаря тому, что Qt
          использует оптимизацию, которая называется <span class="emphasis"><em class="EMPHASIS">implicit sharing</em></span>
          (неявное совместное использование данных). Суть оптимизации
          заключается в том, что фактически, операция копирования может
          и не производиться, не смотря на то, что программа запросила
          ее.</p>

          <p>Класс <tt class="CLASSNAME">QStringList</tt>, широко
          используемый в Qt, это дочерний класс <tt class="CLASSNAME">QValueList&lt;QString&gt;</tt>. Он расширяет
          набор методов предка своими, дополнительными функциями,
          которые делают этот класс очень мощным инструментом. Более
          подробно мы расскажем о нем в последнем разделе этой
          главы.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="MAPS"></a>11.3. Словари
          (map).</h1>

          <p>Словари предназначены для хранения произвольного
          количества элементов, в виде пар "ключ-значение".
          Причем к "ключам" предъявляется требование
          уникальности. Словари обладают широкими возможностями доступа
          к произвольным элементам и незначительными накладными
          расходами на операцию добавления нового элемента. Если в
          словарь вставляется новое значение по существующему ключу, то
          оно затирает старое значение в паре
          "ключ-значение".</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig11.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 11.3. Словарь экземпляров класса <tt class="CLASSNAME">Film</tt>.</p>
            </div>
          </div><br>
          Поскольку словари хранят элементы в виде
          "ключ-значение", то принципы работы со словарями
          несколько отличаются от тех, что используются при работе со
          списками и векторами. Ниже приводится версия класса
          <tt class="CLASSNAME">Film</tt>, которая будет использоваться
          для иллюстрации работы со словарем:
          <pre class="SCREEN">class Film 
{ 
public: 
  Film(const QString &amp;title = "", int duration = 0); 
  
  QString title() const { return myTitle; } 
  void setTitle(const QString &amp;title) { myTitle = title; } 
  int duration() const { return myDuration; } 
  void setDuration(int minutes) { myDuration = minutes; } 
  
private: 
  QString myTitle; 
  int myDuration; 
};

Film::Film(const QString &amp;title, int duration) 
{ 
  myTitle = title; 
  myDuration = duration; 
}
      
</pre>В этой версии отсутствует числовой идентификатор фильма,
поскольку теперь он будет использоваться в качестве "ключа" в
словаре. Кроме того, здесь отсутствуют операторы сравнения -- словари
изначально упорядочивают элементы по ключу, но не по значению.<br>

          <br>

          <p>Класс словаря в STL определен под именем <tt class="CLASSNAME">std::map&lt;K, T&gt;</tt>, в файле заголовка
          <tt class="FILENAME">&lt;map&gt;</tt>. Ниже приводится пример
          объявления словаря, с целыми значениями в качестве ключей и
          <tt class="CLASSNAME">Film</tt> -- в качестве значения:</p>
          <pre class="SCREEN">  map&lt;int, Film&gt; films;
      
</pre>Эквивалент в Qt -- <tt class="CLASSNAME">QMap&lt;K, T&gt;</tt>:
          <pre class="SCREEN">  QMap&lt;int, Film&gt; films;
      
</pre>Наиболее естесственный способ заполнения словарей -- присваивать
значение по заданному ключу:
          <pre class="SCREEN">  films[4812] = Film("A Hard Day's Night", 85); 
  films[5051] = Film("Seven Days to Noon", 94); 
  films[1301] = Film("Day of Wrath", 105); 
  films[9227] = Film("A Special Day", 110); 
  films[1817] = Film("Day for Night", 116);
      
</pre>Итератор словаря предоставляет возможность доступа к паре
"ключ-значение". Ключ извлекается с помощью
          <tt class="METHODNAME">(*it).first</tt>, а значение --
          <tt class="METHODNAME">(*it).second</tt>:
          <pre class="SCREEN">  map&lt;int, Film&gt;::const_iterator it = films.begin(); 
  while (it != films.end()) { 
    cerr &lt;&lt; (*it).first &lt;&lt; ": " 
         &lt;&lt; (*it).second.title().ascii() &lt;&lt; endl; 
    ++it; 
  }
      
</pre>Большинство компиляторов допускают запись в виде
          <tt class="METHODNAME">it-&gt;first</tt> и <tt class="METHODNAME">it-&gt;second</tt>, но более переносимый
          вариант, все таки: <tt class="METHODNAME">(*it).first</tt> и
          <tt class="METHODNAME">(*it).second</tt>.<br>
          <br>

          <p>Итераторы словарей в Qt несколько отличаются от итераторов
          словарей в STL. В Qt ключ можно получить с помощью <tt class="METHODNAME">it.key()</tt>, а значение -- <tt class="METHODNAME">it.data()</tt>:</p>
          <pre class="SCREEN">  QMap&lt;int, Film&gt;::const_iterator it = films.begin(); 
  while (it != films.end()) { 
    cerr &lt;&lt; it.key() &lt;&lt; ": " &lt;&lt; it.data().title().ascii() &lt; endl; 
    ++it; 
  }
      
</pre>При обходе словаря в цикле, элементы словаря всегда упорядочены
по значению ключа.<br>
          <br>

          <p>Для доступа к значениям словаря и их изменения может
          использоваться оператор "[ ]", однако, при попытке
          получить значение по несуществующему в словаре ключу, будет
          создан новый элемент словаря с заданным ключом и пустым
          значением. Чтобы избежать случайного создания пустых
          элементов, используйте функцию <tt class="METHODNAME">find()</tt>, чтобы получить искомый элемент:</p>
          <pre class="SCREEN">  map&lt;int, Film&gt;::const_iterator it = films.find(1817); 
  if (it != films.end()) 
    cerr &lt;&lt; "Found " &lt;&lt; (*it).second.title().ascii() &lt;&lt; endl;
      
</pre>Эта функция вернет итератор <tt class="METHODNAME">end()</tt>,
если ключ отсутствует в словаре.<br>
          <br>

          <p>В примере выше, в качестве ключа использовались целые
          числа, однако, для этих целей могут использоваться и другие
          типы. Наиболее популярный -- <tt class="CLASSNAME">QString</tt>, например:</p>
          <pre class="SCREEN">  map&lt;QString, QString&gt; actorToNationality; 
  actorToNationality["Doris Day"] = "American"; 
  actorToNationality["Greta Garbo"] = "Swedish";
      
</pre>Если необходимо хранить несколько значений с одинаковыми ключами,
используйте <tt class="CLASSNAME">multimap&lt;K, T&gt;</tt>. Если
необходимо хранить одни только ключи, используйте <tt class="CLASSNAME">set&lt;K&gt;</tt> или <tt class="CLASSNAME">multiset&lt;K&gt;</tt>. Qt не имеет классов, эквивалентных
приведенным.<br>
          <br>

          <p>Класс <tt class="CLASSNAME">QMap&lt;K, T&gt;</tt> имеет
          несколько дополнительных функций, особенно удобных при работе
          с небольшими наборами данных. Функции <tt class="METHODNAME">QMap&lt;K, T&gt;::keys()</tt> и <tt class="METHODNAME">QMap&lt;K, T&gt;::values()</tt> возвращают
          списки <tt class="CLASSNAME">QValueList</tt> ключей и
          значений словаря.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="POINTERBASEDCONTAINERS"></a>11.4. Контейнеры
          указателей.</h1>

          <p>Кроме STL-подобных контейнеров, Qt предоставляет еще целый
          ряд контейнерных классов. Они были разработаны в начале 90-х
          годов прошлого века для Qt 1.0, еще до того, как STL стала
          частью C++, и потому имеют свой характерный синтаксис.
          Поскольку эти классы оперируют указателями на объекты, их
          часто называют контейнерами указателей (pointer-based
          containers), в противоположность более современным
          контейнерам значений (value-based containers) Qt и STL. В Qt
          4 контейнеры указателей еще останутся, для сохранения
          совместимости, но их использование не будет
          приветствоваться.</p>

          <p>Контейнеры указателей сохраняют свою актуальность лишь
          благодаря тому, что в Qt 3 еще имеется ряд немаловажных
          функций, которые работают с ними. Один пример мы приводили в
          <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">Главе 3</a>, когда выполняли <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P66">итерации по виджетам</a>, второй -- в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER6">Главе 6</a>, когда выполняли <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P156">итерации по окнам</a> в MDI-приложении.</p>

          <p>Основными контейнерами указателей являются классы
          <tt class="CLASSNAME">QPtrVector&lt;T&gt;, QPtrList&lt;T&gt;,
          QDict&lt;T&gt;, QAsciiDict&lt;T&gt;, QIntDict&lt;T&gt;</tt> и
          <tt class="CLASSNAME">QPtrDict&lt;T&gt;</tt>.</p>

          <p>Класс <tt class="CLASSNAME">QPtrVector&lt;T&gt;</tt>
          предназначен для хранения вектора указателей. Ниже приводится
          пример создания <tt class="CLASSNAME">QPtrVector&lt;Film&gt;</tt> с пятью
          элементами:</p>
          <pre class="SCREEN">  QPtrVector&lt;Film&gt; films(5); 
  films.setAutoDelete(true); 
  films.insert(0, new Film(4812, "A Hard Day's Night", 85)); 
  films.insert(1, new Film(5051, "Seven Days to Noon", 94)); 
  films.insert(2, new Film(1301, "Day of Wrath", 105)); 
  films.insert(3, new Film(9227, "A Special Day", 110)); 
  films.insert(4, new Film(1817, "Day for Night", 116));
      
</pre>Класс <tt class="CLASSNAME">QPtrVector&lt;T&gt;</tt> не имеет
функции <tt class="METHODNAME">append()</tt>, поэтому приходится явно
указывать индекс для добавляемых элементов. В этом примере использована
первая версия класса <tt class="CLASSNAME">Film</tt>, которая содержит
переменную-член -- числовой идентификатор фильма.<br>
          <br>

          <p>Контейнеры указателей в Qt обладают одним замечательным
          свойством -- "auto-delete" (автоматическое
          удаление). Если автоудаление разрешено, Qt становится
          владельцем всех объектов, вставляемых в контейнер и удаляет
          их автоматически, когда удаляется контейнер (или при вызове
          методов <tt class="METHODNAME">remove()</tt> и <tt class="METHODNAME">clear()</tt>).</p>

          <p>Для исключения элемента из вектора, должна вызываться
          функция <tt class="METHODNAME">remove()</tt>, с указанием
          индекса удаляемого элемента:</p>
          <pre class="SCREEN">  films.remove(2);
      
</pre>Эта функция не изменяет размер вектора, она просто обнуляет
указатель с заданным индексом. Если разрешено автоудаление, то
автоматически удаляется объект, на который указывал элемент
вектора.<br>
          <br>

          <p>Чтобы обойти все элементы вектора в цикле, можно просто
          использовать индексы:</p>
          <pre class="SCREEN">  for (int i = 0; i &lt; (int)films.count(); ++i) { 
    if (films[i]) 
      cerr &lt;&lt; films[i]-&gt;title().ascii() &lt;&lt; endl; 
  }
      
</pre>В данном примере сначала выполняется проверка указателя
(указатель не должен быть пустым), а затем выполняются все необходимые
действия над указателем.<br>
          <br>

          <p>Класс <tt class="CLASSNAME">QPtrList&lt;T&gt;</tt>
          предназначен для хранения списка указателей. Добавление новых
          элементов в <tt class="CLASSNAME">QPtrList&lt;T&gt;</tt>
          производится функциями <tt class="METHODNAME">append(),
          prepend()</tt> и <tt class="METHODNAME">insert()</tt>:</p>
          <pre class="SCREEN">  QPtrList&lt;Film&gt; films; 
  films.setAutoDelete(true); 
  films.append(new Film(4812, "A Hard Day's Night", 85)); 
  films.append(new Film(5051, "Seven Days to Noon", 94));
      
</pre>Список указателей имеет "текущий" элемент, значение
которого изменяется функциями навигации по списку, такими как
          <tt class="METHODNAME">first(), next(), prev()</tt> и
          <tt class="METHODNAME">last()</tt>. Один из способов
          выполнения прохода по списку:
          <pre class="SCREEN">  Film *film = films.first(); 
  while (film) { 
    cerr &lt;&lt; film-&gt;title().ascii() &lt;&lt; endl; 
    film = films.next(); 
  }
      
</pre>Однако списки допускают доступ к элементам по индексу:
          <pre class="SCREEN">  for (int i = 0; i &lt; (int)films.count(); ++i) 
    cerr &lt;&lt; films.at(i)-&gt;title().ascii() &lt;&lt; endl;
      
</pre>Третий возможный вариант обхода списка, заключается в
использовании <tt class="CLASSNAME">QPtrListIterator&lt;T&gt;</tt>.<br>

          <br>

          <p>Классы <tt class="CLASSNAME">QDict&lt;T&gt;,
          QAsciiDict&lt;T&gt;, QIntDict&lt;T&gt;</tt> и <tt class="CLASSNAME">QPtrDict&lt;T&gt;</tt> являются близкими
          эквивалентами <tt class="CLASSNAME">map&lt;K, T&gt;</tt>. Эти
          классы так же хранят пары "ключ-значение". Ключ в
          них может быть представлен одним из четырех типов: <tt class="CLASSNAME">QString, const char *, int</tt> и <tt class="CLASSNAME">void *</tt>, в зависимости от типа используемого
          класса. Поскольку все четыре класса предоставляют одинаковую
          функциональность, мы рассмотрим только один из них --
          <tt class="CLASSNAME">QIntDict&lt;T&gt;</tt>.</p>

          <p>Для демонстрации воспользуемся второй версией класса
          <tt class="CLASSNAME">Film</tt>, которая использовалась
          ранее, совместно с классом <tt class="CLASSNAME">map&lt;K,
          T&gt;</tt>.</p>
          <pre class="SCREEN">  QIntDict&lt;Film&gt; films(101); 
  films.setAutoDelete(true);
      
</pre>Конструктору передается число, используемое классом для
определения количества памяти, которую нужно выделить под элементы
словаря. Для улучшения производительности, это число должно быть
простым и немного больше, чем количество элементов, которое
предполагается вставить в словарь. Список простых чисел, меньших 10
000, вы найдете по адресу: <a href="http://doc.trolltech.com/3.2/primes.html" target="_top">http://doc.trolltech.com/3.2/primes.html</a>.<br>
          <br>

          <p>Вставка нового элемента выполняется функцией <tt class="METHODNAME">insert()</tt>, которой передаются ключ и
          значение:</p>
          <pre class="SCREEN">  films.insert(4812, new Film("A Hard Day's Night", 85)); 
  films.insert(5051, new Film("Seven Days to Noon", 94));
      
</pre>Для доступа к элементу словаря можно использовать функцию
<tt class="METHODNAME">find()</tt> или оператор "[ ]". Для
удаления элемента -- функцию <tt class="METHODNAME">remove()</tt>. Для
изменения значения, ассоциированного с заданным ключом --
          <tt class="METHODNAME">replace()</tt>.<br>
          <br>

          <p>Если функция <tt class="METHODNAME">insert()</tt>
          вызывается несколько раз с одним и тем же ключом, доступ
          будет иметься только к значению, которое было вставлено
          последним. При вызове <tt class="METHODNAME">remove()</tt>,
          элементы удаляются в обратном порядке. Чтобы избежать вставки
          нескольких значений с одим и тем же ключом, используйте
          <tt class="METHODNAME">replace()</tt> вместо <tt class="METHODNAME">insert()</tt>.</p>

          <p>Обход элементов контейнера может быть выполнен с помощью
          итератора:</p>
          <pre class="SCREEN">  QIntDictIterator&lt;Film&gt; it(films); 
  while (it.current()) { 
    cerr &lt;&lt; it.currentKey() &lt;&lt; ": " 
         &lt;&lt; it.current()-&gt;title().ascii() &lt;&lt; endl; 
    ++it; 
  }
      
</pre>Текущий ключ итератора может быть получен вызовом
          <tt class="METHODNAME">currentKey()</tt>, а текущее значение
          -- функцией <tt class="METHODNAME">current()</tt>. Порядок
          следования элементов в словаре не определен.<br>
          <br>

          <p>Для хранения элементов базовых типов языка C++ (<tt class="CLASSNAME">int, double</tt> и т.п) и структур, Qt
          предоставляет специальный, вектор-подобный класс <tt class="CLASSNAME">QMemArray&lt;T&gt;</tt>. В некоторых приложениях
          он может использоваться напрямую, однако, чаще используются
          два производных класса <tt class="CLASSNAME">QByteArray</tt>
          (<tt class="CLASSNAME">QMemArray&lt;char&gt;</tt>) и
          <tt class="CLASSNAME">QPointArray</tt> (<tt class="CLASSNAME">QMemArray&lt;QPoint&gt;</tt>). Мы уже
          использовали их несколько раз в предыдущих главах.</p>

          <p>Ниже приводится пример создания <tt class="CLASSNAME">QByteArray</tt>:</p>
          <pre class="SCREEN">  QByteArray bytes(4); 
  bytes[0] = 'A'; 
  bytes[1] = 'C'; 
  bytes[2] = 'D'; 
  bytes[3] = 'C';
      
</pre>При создании экземпляра <tt class="CLASSNAME">QMemArray&lt;T&gt;</tt>, необходимо либо сразу указать
начальный размер будущего массива, либо вызвать функцию
          <tt class="METHODNAME">resize()</tt> после создания. Доступ к
          элементам массива выполняется с помощью оператора "[
          ]":
          <pre class="SCREEN">  for (int i = 0; i &lt; (int)bytes.size(); ++i) 
    cerr &lt;&lt; bytes[i] &lt;&lt; endl;
      
</pre>Поиск элемента в массиве осуществляется с помощью функции
<tt class="METHODNAME">QMemArray&lt;T&gt;::find()</tt>:
          <pre class="SCREEN">  if (bytes.find( A ) != -1) 
    cerr &lt;&lt; "Found" &lt; endl;
      
</pre>Иногда программисты забывают об одной особенности класса
<tt class="CLASSNAME">QMemArray&lt;T&gt;</tt> и его производных -- они
используют то, что называется <span class="emphasis"><em class="EMPHASIS">explicitly shared</em></span>
          (явное совместное использование данных). Это означает, что
          созданные копии объекта (с помощью конструктора копирования
          или оператором присваивания) ссылаются на одни и те же
          данные. Когда данные модифицируются с помощью одного объекта,
          изменения будут видны в другом. Не следует путать явное
          совместное использование данных (<span class="emphasis"><em class="EMPHASIS">explicitly
          shared</em></span>) с неявным совместным использованием
          данных (<span class="emphasis"><em class="EMPHASIS">implicitly shared</em></span>), которое лишено
          данной проблемы.<br>
          <br>

          <p>Избежать описанной проблемы несложно, для этого достаточно
          выполнить полное копирование объекта вызовом <tt class="METHODNAME">copy()</tt>:</p>
          <pre class="SCREEN">  duplicate = bytes.copy();
      
</pre>Теперь два объекта будут ссылаться на различные наборы
данных.<br>
          <br>

          <p>Скорее всего, в Qt 4, предпочтение будет отдано классу
          <tt class="CLASSNAME">QValueVector&lt;T&gt;</tt>, а классы
          <tt class="CLASSNAME">QByteArray</tt> и <tt class="CLASSNAME">QPointArray</tt> станут его производными.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="QSTRINGANDQVARIANT"></a>11.5.
          Классы QString и QVariant.</h1>

          <p>Строки используются практически во всех программах ничуть
          не реже других типов.</p>

          <p>Язык C++ предоставляет два типа строк: традиционные строки
          языка C -- массивы символов, завершающиеся символом
          '\0' и класс <tt class="CLASSNAME">string</tt>. Qt
          предоставляет гораздо более мощный класс <tt class="CLASSNAME">QString</tt>. Он предназначен для хранения строк
          с 16-ти битными символами Unicode. Unicode содержит наборы
          символов ASCII и Latin-1 с их обычными числовыми значениями.
          Но поскольку каждый символ в <tt class="CLASSNAME">QString</tt> представлен 16-ю битами, он может
          содержать тысячи других символов. Дополнительную информацию
          об Unicode вы найдете в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER15">Главе
          15</a>.</p>

          <p>Конкатенация двух строк <tt class="CLASSNAME">QString</tt>
          может выполняться двухместным оператором "+" или
          оператором "+=". Ниже приводится пример
          использования обоих операторов:</p>
          <pre class="SCREEN">  QString str = "User: "; 
  str += userName + "\n";
      
</pre>Кроме того, имеется функция <tt class="METHODNAME">QString::append()</tt>, которая идентична по своему
действию оператору "+=":
          <pre class="SCREEN">  str = "User: "; 
  str.append(userName); 
  str.append("\n");
      
</pre>И совершенно иной подход к объединению строк состоит в
использовании функции <tt class="METHODNAME">QString::sprintf()</tt>:
          <pre class="SCREEN">  str.sprintf("%s %.1f%%", "perfect competition", 100.0);
      
</pre>Она поддерживает тот же набор спецификаторов формата, что и
библиотечная функция <tt class="METHODNAME">sprintf()</tt>. В примере
выше, в строку <tt class="VARNAME">str</tt> будет записана строка
"perfect competition 100.0%".<br>
          <br>

          <p>Еще один способ "сборки" строки из других строк
          и чисел -- использовать <tt class="METHODNAME">arg()</tt>:</p>
          <pre class="SCREEN">  str = QString("%1 %2 (%3s-%4s)") 
        .arg("permissive").arg("society").arg(1950).arg(1970);
      
</pre>В этом примере "%1" будет заменено словом
"permissive", "%2" -- "society",
"%3" -- "1950" и "%4" --
"1970". В результате получится строка "permissive
society (1950s-1970s)". Класс имеет несколько перегруженных
функций <tt class="METHODNAME">arg()</tt> для обработки различных типов
данных. Некоторые из них имеют дополнительные параметры, управляющие
длиной выходной строки, базой системы счисления и точностью
представления чисел с плавющей точкой. В большинстве случаев
          <tt class="METHODNAME">arg()</tt> представляет лучшее
          решение, чем <tt class="METHODNAME">sprintf()</tt>, потому
          что она более безопасна, полностью поддерживает Unicode и
          позволяет переводчикам изменять порядок следования параметров
          <span class="emphasis"><em class="EMPHASIS">"%n"</em></span>.<br>
          <br>

          <p><tt class="CLASSNAME">QString</tt> позволяет
          преобразовывать числа в их строковое представление, с помощью
          статической функции <tt class="METHODNAME">QString::number()</tt>:</p>
          <pre class="SCREEN">  str = QString::number(59.6);   
      
</pre>или с помощью <tt class="METHODNAME">QString::setNum()</tt>:
          <pre class="SCREEN">  str.setNum(59.6);
      
</pre>Обратное преобразование может быть выполнено функциями
          <tt class="METHODNAME">toInt(), toLongLong(), toDouble()</tt>
          и т.д., например:
          <pre class="SCREEN">  bool ok; 
  double d = str.toDouble(&amp;ok);
      
</pre>Эти функции могут принимать необязательный аргумент типа
<tt class="CLASSNAME">bool</tt>, в котором возвращается признак успеха
преобразования. Если преобразование не может быть выполнено, они всегда
возвращают 0.<br>
          <br>

          <p>Зачастую возникает ситуация, когда необходимо извлечь
          часть строки. Функция <tt class="METHODNAME">mid()</tt>
          возвращает подстроку заданной длины, начиная с заданной
          позиции в исходной строке. Например, следующий код выводит
          строку "pays":</p>
          <pre class="SCREEN">  QString str = "polluter pays principle"; 
  cerr &lt;&lt; str.mid(9, 4).ascii() &lt;&lt; endl;
      
</pre>Если опустить второй аргумент (или передать в качестве второго
аргумента число -1), функция вернет подстроку, начиная с заданной
позиции и до конца исходной строки. Например, следующий код выведет
строку "pays principle":
          <pre class="SCREEN">  QString str = "polluter pays principle"; 
  cerr &lt;&lt; str.mid(9).ascii() &lt;&lt; endl;
      
</pre>Дополнительно имеются функции <tt class="METHODNAME">left()</tt>
и <tt class="METHODNAME">right()</tt>. Они обе принимают количество
символов <tt class="VARNAME">n</tt> и возвращают первые или последние
<tt class="VARNAME">n</tt> символов исходной строки, соответственно.
Например, следующий код выведет строку "polluter principle":
          <pre class="SCREEN">  QString str = "polluter pays principle"; 
  cerr &lt;&lt; str.left(8).ascii() &lt;&lt; " " &lt;&lt; str.right(9).ascii() 
       &lt;&lt; endl;
      
</pre>Если нужно выполнить проверку -- начинается ли или заканчивается
ли строка определенной комбинацией символов, для этих целей существуют
функции <tt class="METHODNAME">startsWith()</tt> и <tt class="METHODNAME">endsWith()</tt>:
          <pre class="SCREEN">  if (uri.startsWith("http:") &amp;&amp; uri.endsWith(".png"))
    ...
      
</pre>Это гораздо быстрее и проще, чем:
          <pre class="SCREEN">  if (uri.left(5) == "http:" &amp;&amp; uri.right(4) == ".png")
    ...
      
</pre>Оператор сравнения строк "==" чувствителен к регистру
символов. Для выполнения регистронезависимого сравнения, можно
воспользоваться функциями <tt class="METHODNAME">upper()</tt> или
<tt class="METHODNAME">lower()</tt>, например:
          <pre class="SCREEN">  if (fileName.lower() == "readme.txt")
    ...
      
</pre>Для замены одной подстроки в строке другой подстрокой,
используйте функцию <tt class="METHODNAME">replace()</tt>:
          <pre class="SCREEN">  QString str = "a sunny day"; 
  str.replace(2, 5, "cloudy");
      
</pre>в результате получится строка "a cloudy day". То же
самое действие может выполнено с помощью функций <tt class="METHODNAME">remove()</tt> и <tt class="METHODNAME">insert()</tt>:
          <pre class="SCREEN">  str.remove(2, 5); 
  str.insert(2, "cloudy");
      
</pre>В первой строке удаляется пять символов, начиная со 2-й позиции,
в результате получается строка "a day" (с двумя пробелами),
затем, во второую позицию вставляется слово "cloudy".<br>

          <br>

          <p>Существуют перегруженные версии функции <tt class="METHODNAME">replace()</tt>, которые заменяют все вхождения
          первого аргумента на второй. Например, чтобы заменить все
          символы '&amp;' в строке на
          "&amp;amp;":</p>
          <pre class="SCREEN">  str.replace("&amp;", "&amp;amp;");
      
</pre>Очень часто возникает необходимость выбросить из начала и конца
строки все лишние пробельные символы (такие как: пробелы, символы
табуляции, символы перевода строки). Для этой цели существует функция
<tt class="METHODNAME">stripWhiteSpace()</tt>:
          <pre class="SCREEN">  QString str = " BOB \t THE \nDOG \n"; 
  cerr &lt;&lt; str.stripWhiteSpace().ascii() &lt;&lt; endl;
      
</pre>Строка <tt class="VARNAME">str</tt> может быть изображена как:

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig11.01.png"></p>
          </div>А результат, возвращаемый функцией <tt class="METHODNAME">stripWhiteSpace()</tt>, как:

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig11.02.png"></p>
          </div>Для удаления лишних пробельных символов, как на концах
          строки, так и внутри, предназначена функция <tt class="METHODNAME">simplifyWhiteSpace()</tt>:
          <pre class="SCREEN">  QString str = " BOB \t THE \nDOG \n"; 
  cerr &lt;&lt; str.simplifyWhiteSpace().ascii() &lt;&lt; endl;
      
</pre>Результат работы функции будет выглядеть так:

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig11.03.png"></p>
          </div>Строки могут быть разбиты на подстроки с помощью
          функции <tt class="METHODNAME">QStringList::split()</tt>:
          <pre class="SCREEN">  QString str = "polluter pays principle"; 
  QStringList words = QStringList::split(" ", str);
      
</pre>В этом примере, строка "polluter pays principle"
разбивается на три подстроки; "polluter", "pays" и
"principle". Функция <tt class="METHODNAME">split()</tt>
может принимать третий необязательный параметр типа
          <tt class="CLASSNAME">bool</tt>, который определяет -- должны
          ли игнорироваться пустые подстроки (по-умолчанию) или
          нет.<br>
          <br>

          <p>Элементы списка <tt class="CLASSNAME">QStringList</tt>
          могут быть объединены в одну строку, с помощью функции
          <tt class="METHODNAME">join()</tt>. В качестве аргумента ей
          передается строка, которая должна быть вставлена между
          объединяемыми строками. Например, следующий код
          демонстрирует, как можно объединить все строки в списке,
          отсортированном по алфавиту, в единую строку, причем
          подстроки отделяются друг от друга символом перевода
          строки:</p>
          <pre class="SCREEN">  words.sort(); 
  str = words.join("\n");
      
</pre>Еще одна немаловажная операция над строками -- определение длины
строки. Для этого предназначена функция <tt class="METHODNAME">
          length()</tt> и, как вариант, <tt class="METHODNAME">isEmpty()</tt>, которая возвращает <tt class="PARAMETER"><em>true</em></tt>, если длина строки равна
          0.<br>
          <br>

          <p><tt class="CLASSNAME">QString</tt> различает пустые строки
          и несуществующие (NULL) строки. Эти различия корнями уходят в
          язык программирования C. Чтобы проверить -- существует ли
          строка, можно вызывать функцию <tt class="METHODNAME">isNull()</tt>. Для большинства приложений очень
          важно знать -- содержит ли строка хотя бы один символ.
          Функция <tt class="METHODNAME">isEmpty()</tt> вернет
          <tt class="PARAMETER"><em>true</em></tt>, если строка не
          содержит ни одного символа (пустая или несуществующая
          строка).</p>

          <p>Преобразования, между <tt class="CLASSNAME">const char
          *</tt> и <tt class="CLASSNAME">QString</tt>, в большинстве
          случаев выполняются автоматически:</p>
          <pre class="SCREEN">  str += " (1870)";
      
</pre>Этот код добавляет строку типа <tt class="CLASSNAME">const char
*</tt> к строке типа <tt class="CLASSNAME">QString</tt>.<br>
          <br>

          <p>В некоторых ситуациях возникает необходимость явно
          выполнять преобразование между <tt class="CLASSNAME">const
          char *</tt> и <tt class="CLASSNAME">QString</tt>. Чтобы
          преобразовать строку <tt class="CLASSNAME">QString</tt> в
          <tt class="CLASSNAME">const char *</tt>, используйте функцию
          <tt class="METHODNAME">ascii()</tt> или <tt class="METHODNAME">latin1()</tt>. Обратное преобразование может
          быть выполнено за счет операции приведения типа.</p>

          <p>Когда вызываются функции <tt class="METHODNAME">ascii()</tt> или <tt class="METHODNAME">latin1()</tt>, или когда выполняется
          автоматическое преобразование к типу <tt class="CLASSNAME">const char *</tt>, возвращаемая строка
          принадлежит объекту <tt class="CLASSNAME">QString</tt>. Это
          означает, что нас не должна беспокоить проблема утечки памяти
          -- Qt самостоятельно утилизирует память, по мере
          необходимости. С другой стороны, необходимо проявлять большую
          осторожность при работе с указателями. Например, если
          оригинальная версия строки <tt class="CLASSNAME">QString</tt>
          будет изменена, то ранее полученный указатель на <tt class="CLASSNAME">const char *</tt> может оказаться недопустимым.
          Если же необходимо сохранить предыдущий вариант строки, то
          для этих целей можно воспользоваться услугами класса
          <tt class="CLASSNAME">QByteArray</tt> или <tt class="CLASSNAME">QCString</tt>. Они хранят полную копию
          данных.</p>

          <p>Класс <tt class="CLASSNAME">QString</tt> поддерживает
          <span class="emphasis"><em class="EMPHASIS">implicit
          sharing</em></span> (неявное совместное использование
          данных). Это означает, что на копирование строки уходит
          времени не больше, чем необходимо для копирования указателя
          на строку. Собственно копирование производится только тогда,
          когда выполняется попытка изменить одну из копий. Все это
          делается автоматически и незаметно для нас.</p>

          <p>Вся прелесть неявного совместного использования данных
          состоит в том, что таким образом оптимизируется скорость
          выполнения операций и при этом нам не нужно постоянно помнить
          об этом -- это просто работает!</p>

          <p>Qt использует это метод оптимизации и для других классов,
          включая: <tt class="CLASSNAME">QBrush, QFont, QPen, QPixmap,
          QMap&lt;K, T&gt;, QValueList&lt;T&gt;</tt> и <tt class="CLASSNAME">QValueVector&lt;T&gt;</tt>. Что повышает
          эффективность передачи экземпляров классов по значению, как в
          виде аргументов функций, так и в виде возвращаемых
          значений.</p>

          <p>C++ -- это строго типизированный язык, однако, иногда
          возникает необходимость сохранять данные в более общем виде.
          Самый простой способ -- использовать строки. Например, строки
          могут хранить текстовые или числовые данные. Qt предоставляет
          более простой способ работы с переменными -- класс <tt class="CLASSNAME">QVariant</tt>.</p>

          <p>Класс <tt class="CLASSNAME">QVariant</tt> может хранить
          значения многих типов Qt: <tt class="CLASSNAME">QBrush,
          QColor, QCursor, QDateTime, QFont, QKeySequence, QPalette,
          QPen, QPixmap, QPoint, QRect, QRegion, QSize</tt> и
          <tt class="CLASSNAME">QString.</tt>. Он так же может хранить
          контейнеры: <tt class="CLASSNAME">QMap&lt;QString,
          QVariant&gt;, QStringList</tt> и <tt class="CLASSNAME">QValueList&lt;QVariant&gt;.</tt>. Мы уже
          использовали <tt class="CLASSNAME">QVariant</tt>, когда
          разрабатывали приложение Spreadsheet, в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER4">Главе 4</a>, для хранения содержимого ячейки.</p>

          <p>Одно из обычных применений класса <tt class="CLASSNAME">QVariant</tt> -- создание словарей (map), в
          которых в качестве ключа используются строки, а в качестве
          значений -- экземпляры класса <tt class="CLASSNAME">QVariant</tt>. Как правило, информация о
          конфигурации приложения сохраняется и загружается с помощью
          <tt class="CLASSNAME">QSettings</tt>, но иногда приложения
          могут обслуживать настройки напрямую, например, сохраняя их в
          базе данных. <tt class="CLASSNAME">QMap&lt;QString,
          QVariant&gt;</tt> идеально подходит в таких ситуациях:</p>
          <pre class="SCREEN">  QMap&lt;QString, QVariant&gt; config; 
  config["Width"] = 890; 
  config["Height"] = 645; 
  config["ForegroundColor"] = black; 
  config["BackgroundColor"] = lightGray; 
  config["SavedDate"] = QDateTime::currentDateTime(); 
  QStringList files; 
  files &lt;&lt; "2003-05.dat" &lt;&lt; "2003-06.dat" &lt;&lt; "2003-07.dat"; 
  config["RecentFiles"] = files;
      
</pre><br>
          <br>

          <div class="INFORMALTABLE">
            <a name="AEN5651"></a>

            <table border="0" class="CALSTABLE" cellspacing="0">
              <thead style="background:black; color:white">
                <tr>
                  <th width="100%" align="center" valign="middle">
                    <pre class="SCREEN">            
</pre>Принцип Действия Неявного Совместного Использования Данных
                    <pre class="SCREEN">            
</pre>
                  </th>
                </tr>
              </thead>

              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="100%" align="left" valign="top">
                    <p>Механизм неявного совместного использования
                    данных работает полностью автоматически и незаметно
                    для нас. Таким образом, когда мы используем классы,
                    поддерживающие этот механизм, мы не должны писать
                    дополнительный код, который поддерживал бы его
                    работу. Но знать принцип его действия вам все таки
                    необходимо, поэтому рассмотрим простенький пример и
                    исследуем -- что же скрыто от наших глаз.</p>
                    <pre class="SCREEN">  QString str1 = "Humpty"; 
  QString str2 = str1;
            
</pre>Здесь в переменную <tt class="VARNAME">str1</tt> записывается
строка "Humpty" и затем выполняется присваивание переменной
<tt class="VARNAME">str2</tt>. С этого момента обе переменные указывают
на одну и ту же структуру данных в памяти (типа <tt class="CLASSNAME">
                    QStringData</tt>). Вместе с символами строки она
                    хранит счетчик ссылок, который содержит количество
                    объектов, ссылающихся на нее. Поскольку и
                    <tt class="VARNAME">str1</tt>, и <tt class="VARNAME">str2</tt> ссылаются на одни и те же
                    данные, то счетчик ссылок равен 2.
                    <pre class="SCREEN">  str2[0] = 'D';
              
</pre>Когда выполняется изменение содержимого переменной
                    <tt class="VARNAME">str2</tt>, то прежде всего
                    создается полная копия данных, таким образом,
                    теперь <tt class="VARNAME">str1</tt> и <tt class="VARNAME">str2</tt> ссылаются на различные
                    структуры и все изменения будут производиться над
                    их собственными копиями данных. Счетчик ссылок
                    переменной <tt class="VARNAME">str1</tt>
                    ("Humpty") теперь стал равен 1 и счетчик
                    ссылок переменной <tt class="VARNAME">str2</tt>
                    ("Dumpty") так же стал равен 1. Когда
                    счетчик ссылок равен 1, это означает, что данные
                    используются только одним объектом.
                    <pre class="SCREEN">  str2.truncate(4);
              
</pre>Если теперь выполнить модификацию переменной <tt class="VARNAME">
                    str2</tt>, то никакого копирования производиться
                    уже не будет, потому что счетчик ссылок равен 1.
                    Функция <tt class="METHODNAME">truncate()</tt>
                    будет оперировать с данными, принадлежащими
                    переменной <tt class="VARNAME">str2</tt>, и счетчик
                    ссылок останется равным 1.
                    <pre class="SCREEN">  str1 = str2;
              
</pre>После такого присваивания, счетчик ссылок переменной
                    <tt class="VARNAME">str1</tt> станет равным 0, это
                    означает, что строка "Humpty" больше не
                    нужна. В этом случае память, ранее занимаемая
                    переменной <tt class="VARNAME">str1</tt>, будет
                    освобождена. Теперь обе переменные будут ссылаться
                    на строку "Dump", а счетчик ссылок станет
                    равным 2.<br>
                    <br>

                    <p>Создание классов, использующих оптимизацию
                    неявного совместного использования данных,
                    выполняется довольно просто. В ежеквартальнике
                    <span class="emphasis"><em class="EMPHASIS">Qt
                    Quarterly</em></span>, в статье "Data Sharing
                    with Class" ( <a href="http://doc.trolltech.com/qq/qq02-data-sharing-with-class.html" target="_top">http://doc.trolltech.com/qq/qq02-data-sharing-with-class.html</a>)
                       описывается -- как это сделать.</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>Обход в цикле элементов словаря, который хранит значения в
          вариантном виде, может оказаться не такой простой задачей,
          если некоторые из значений являются контейнерами. Чтобы
          проверить тип вариантного значения вам придется
          воспользоваться функцией <tt class="METHODNAME">type()</tt>:</p>
          <pre class="SCREEN">  QMap&lt;QString, QVariant&gt;::const_iterator it = config.begin(); 
  while (it != config.end()) { 
    QString str; 
    if (it.data().type() == QVariant::StringList) 
      str = it.data().toStringList().join(", "); 
    else 
      str = it.data().toString(); 
    cerr &lt;&lt; it.key().ascii() &lt;&lt; ": " &lt;&lt; str.ascii() &lt;&lt; endl;
    ++it; 
  }
      
</pre>С помощью <tt class="CLASSNAME">QVariant</tt> можно создавать
довольно сложные структуры данных, хранящие значения контейнерного
типа:
          <pre class="SCREEN">  QMap&lt;QString, QVariant&gt; price; 
  price["Orange"] = 2.10; 
  price["Pear"].asMap()["Standard"] = 1.95; 
  price["Pear"].asMap()["Organic"] = 2.25; 
  price["Pineapple"] = 3.85;
      
</pre>В этом примере был создан словарь со строковыми ключами (название
продукта) и значениями типа <tt class="CLASSNAME">double</tt> (цена)
или типа <tt class="CLASSNAME">QMap</tt>. Словарь верхнего уровня
содержит три ключа: "Orange", "Pear" и
"Pineapple". Значение, связанные с ключом "Pear" --
это словарь с двумя ключами ("Standard" и
"Organic").<br>
          <br>

          <p>Возможность создания структур данных, подобных этой, может
          показаться очень соблазнительной, так как можно
          структурировать данные по своему усмотрению. Но удобство
          <tt class="CLASSNAME">QVariant</tt> -- вещь дорогостоящая.
          Ради удобочитаемости придется пожертвовать
          быстродействием.</p>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER12"></a>Глава 12. Базы данных.</h1>

        <p>Модуль SQL, в библиотеке Qt, предоставляет независимый от
        типа платформы и базы данных интерфейс, для доступа к базам
        данных SQL, и набор классов, обеспечивающих взаимодействие
        пользовательского интерфейса с базами данных.</p>

        <p>Глава начинается с демонстрационного примера, который
        показывает, как установить соединение с базой данных и как
        выполнить произвольный SQL-код. Во втором и третьем разделах мы
        подробнее остановимся на том, как предоставить пользователю
        возможность просматривать и изменять наборы данных, используя
        <tt class="CLASSNAME">QDataTable</tt> -- для просмотра данных в
        табличном виде, и <tt class="CLASSNAME">QSqlForm</tt> -- в виде
        формы.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="CONNECTINGANDQUERYING"></a>12.1.
          Установление соединения и выполнение запроса.</h1>

          <p>Прежде чем выполнить запрос к базе данных, для начала
          необходимо установить с ней соединение. Как правило,
          установление соединения с базой данных выполняется в виде
          отдельной функции, которую приложение вызывает на запуске,
          например:</p>
          <pre class="SCREEN">bool createConnection() 
{ 
  QSqlDatabase *db = QSqlDatabase::addDatabase("QOCI8"); 
  db-&gt;setHostName("mozart.konkordia.edu"); 
  db-&gt;setDatabaseName("musicdb"); 
  db-&gt;setUserName("gbatstone"); 
  db-&gt;setPassword("T17aV44"); 
  if (!db-&gt;open()) { 
    db-&gt;lastError().showMessage(); 
    return false; 
  } 
  return true; 
}
      
</pre>Первым делом, вызовом <tt class="METHODNAME">QSqlDatabase::addDatabase()</tt>, создается экземпляр
класса <tt class="CLASSNAME">QSqlDatabase</tt>. Аргумент функции
определяет драйвер базы данных, используемый для доступа к ней. В
данном случае -- это драйвер Oracle. Коммерческая версия Qt включает в
себя следующий набор драйверов: QODBC3 (ODBC), QOCI8 (Oracle), QTDS7
(Sybase Adaptive Server), QPSQL7 (PostgreSQL), QMYSQL3 (MySQL), and
QDB2 (IBM DB2). В некоммерческие версии Qt входит только часть этого
набора. <a name="AEN5706" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#FTN.AEN5706"><span class="footnote">[7]</span></a><br>
          <br>

          <p>Затем указывается сетевое имя сервера баз данных, имя базы
          данных, имя пользователя и пароль, после чего выполняется
          попытка установить соединение. Если функция <tt class="METHODNAME">open()</tt> завершилась неудачей -- выводится
          сообщение об ошибке, с помощью <tt class="METHODNAME">QSqlError::showMessage()</tt>.</p>

          <p>Обычно функция, подобная <tt class="METHODNAME">createConnection()</tt> вызывается из функции
          <tt class="METHODNAME">main()</tt>:</p>
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  if (!createConnection()) 
    return 1; 
  ... 
  return app.exec(); 
}
      
</pre>После установления соединения, посредством <tt class="CLASSNAME">
          QSqlQuery</tt>, можно выполнять SQL-запросы к базе данных.
          Например, следующий код выполняет SQL-предложение -- SELECT:
          <pre class="SCREEN">  QSqlQuery query; 
  query.exec("SELECT title, year FROM cd WHERE year &gt;= 1998");
      
</pre>После вызова функции <tt class="METHODNAME">exec()</tt>, можно
просматривать полученный набор данных:
          <pre class="SCREEN">  while (query.next()) { 
    QString title = query.value(0).toString(); 
    int year = query.value(1).toInt(); 
    cerr &lt;&lt; title.ascii() &lt;&lt; ": " &lt;&lt; year &lt;&lt; endl; 
  }
      
</pre>Первый вызов <tt class="METHODNAME">next()</tt> позиционирует
<tt class="CLASSNAME">QSqlQuery</tt> на <span class="emphasis">
          <em class="EMPHASIS">первую</em></span> запись в наборе
          данных. Последующие вызовы <tt class="METHODNAME">next()</tt>
          передвигают указатель на следующую запись и так до тех пор,
          пока не будет достигнут конец набора. В этой точке <tt class="METHODNAME">next()</tt> вернет <tt class="PARAMETER"><em>false</em></tt>.<br>
          <br>

          <p>Функция <tt class="METHODNAME">value()</tt> возвращает
          значение поля в виде <tt class="CLASSNAME">QVariant</tt>.
          Поля нумеруются, начиная с 0, в порядке их следования в
          предложении SELECT. Класс <tt class="CLASSNAME">QVariant</tt>
          может хранить огромное количество типов языка C++ и Qt, в том
          числе <tt class="CLASSNAME">int</tt> и <tt class="CLASSNAME">QString</tt>. Различные типы данных, которые
          могут храниться в базе данных переводятся в соответствующие
          типы C++ и Qt, и сохраняются в виде <tt class="CLASSNAME">QVariant</tt>. Например, <tt class="CLASSNAME">VARCHAR</tt> представляется в виде <tt class="CLASSNAME">QString</tt>, а <tt class="CLASSNAME">DATETIME</tt> -- как <tt class="CLASSNAME">QDateTime</tt>.</p>

          <p>Класс <tt class="CLASSNAME">QSqlQuery</tt> предоставляет
          целый набор функций для навигации по набору данных:
          <tt class="METHODNAME">first(), last(), prev(), seek()</tt> и
          <tt class="METHODNAME">at()</tt>. Они очень удобны в
          использовании, но на некоторых базах данных могут оказаться
          довольно медлительными и ресурсоемкими. С целью оптимизациии,
          при работе с большими наборами данных, можно вызвать
          <tt class="METHODNAME">QSqlQuery::setForwardOnly(true)</tt>,
          перед <tt class="METHODNAME">exec()</tt>, а затем выполнять
          просмотр набора данных с помощью <tt class="METHODNAME">next()</tt>, правда в этом случае мы получаем,
          так называемые, однонаправленные наборы данных, т.е. такие
          наборы, навигация по которым может осуществляться только
          вперед, с помощью <tt class="METHODNAME">next()</tt>.</p>

          <p>Чуть выше говорилось о том, что SQL-запрос передается как
          аргумент функции <tt class="METHODNAME">exec()</tt>, но текст
          запроса может передаваться напрямую, конструктору <tt class="CLASSNAME">QSqlQuery</tt>:</p>
          <pre class="SCREEN">  QSqlQuery query("SELECT title, year FROM cd WHERE year &gt;= 1998");
      
</pre>Проверка на наличие ошибок и выдача сообщения могут быть
выполнены таким образом:
          <pre class="SCREEN">  if (!query.isActive()) 
    query.lastError().showMessage();
      
</pre>Выполнение предложения INSERT ничуть не сложнее, чем SELECT:
          <pre class="SCREEN">  QSqlQuery query("INSERT INTO cd (id, artistid, title, year) " 
                  "VALUES (203, 102, 'Living in America', 2002)");
      
</pre>После выполнения такого запроса, <tt class="METHODNAME">
          QSqlQuery::numRowsAffected()</tt> возвращает количество
          записей, подвергшихся изменению (или -1, если база данных не
          предусматривает поставку такой информации).<br>
          <br>

          <p>В случае необходимости вставить в запрос значения
          переменных или когда нежелательно, или невозможно перевести
          аргументы предложения INSERT в строковый вид, можно построить
          <span class="emphasis"><em class="EMPHASIS">параметризованный
          запрос</em></span>, с помощью функции <tt class="METHODNAME">prepare()</tt>. Текст параметризованного
          запроса, вместо реальных значений содержит параметры, которые
          заполняются фактическими значениями после создания запроса.
          Qt поддерживает Oracle-подобный и ODBC-подобный стили
          именования параметров для всех типов баз данных. В примере
          ниже показано использование Oracle-подобного стиля
          именования:</p>
          <pre class="SCREEN">  QSqlQuery query(db); 
  query.prepare("INSERT INTO cd (id, artistid, title, year) " 
                "VALUES (:id, :artistid, :title, :year)"); 
  query.bindValue(":id", 203); 
  query.bindValue(":artistid", 102); 
  query.bindValue(":title", QString("Living in America")); 
  query.bindValue(":year", 2002); 
  query.exec();
      
</pre>Теперь тот же самый пример, но в стиле ODBC:
          <pre class="SCREEN">  QSqlQuery query(db); 
  query.prepare("INSERT INTO cd (id, artistid, title, year) " 
                "VALUES (?, ?, ?, ?)"); 
  query.addBindValue(203); 
  query.addBindValue(102); 
  query.addBindValue(QString("Living in America")); 
  query.addBindValue(2002); 
  query.exec();
      
</pre>После создания запроса, вызовом <tt class="METHODNAME">prepare()</tt>, параметры запроса заполняются фактическими
значениями, с помощью функции <tt class="METHODNAME">bindValue()</tt>
или <tt class="METHODNAME">addBindValue()</tt>, после чего запрос
исполняется вызовом <tt class="METHODNAME">exec()</tt>.
Параметризованные запросы можно выполнять в цикле. Перед началом цикла
создается запрос, а в теле цикла производится заполнение параметров
новыми значениями и исполнение запроса.<br>
          <br>

          <p>Параметризованные запросы очень часто используются в тех
          случаях, когда в базу данных нужно записать двоичные данные
          или строки, которые содержат символы из наборов, не
          принадлежащих диапазону ASCII или Latin-1. Для баз данных,
          которые поддерживают Unicode, Qt использует эту кодировку
          символов, в других случаях выполняется преобразование строк в
          соответствующую кодировку.</p>

          <p>Qt поддерживает механизм транзакций для баз данных, в
          которых он присутствует. Для запуска транзакции вызывается
          метод объекта <tt class="CLASSNAME">QSqlDatabase</tt> --
          <tt class="METHODNAME">transaction()</tt>. Для завершения
          транзакции вызывается либо функция <tt class="METHODNAME">commit()</tt>, либо <tt class="METHODNAME">rollback()</tt>. Например, выполним поиск по
          внешнему ключу и вставим запись в таблицу в рамках
          транзакции:</p>
          <pre class="SCREEN">  QSqlDatabase::database()-&gt;transaction(); 
  QSqlQuery query; 
  query.exec("SELECT id FROM artist WHERE name = 'Gluecifer'"); 
  if (query.next()) { 
    int artistId = query.value(0).toInt(); 
    query.exec("INSERT INTO cd (id, artistid, title, year) " 
               "VALUES (201, " + QString::number(artistId) 
               + ", 'Riding the Tiger', 1997)"); 
  } 
  QSqlDatabase::database()-&gt;commit();
      
</pre>Функция <tt class="METHODNAME">QSqlDatabase::database()</tt>
возвращает указатель на объект <tt class="CLASSNAME">QSqlDatabase</tt>,
который был создан в <tt class="METHODNAME">createConnection()</tt>.
Если транзакция не может быть запущена, <tt class="METHODNAME">
          QSqlDatabase::transaction()</tt> возвращает <tt class="PARAMETER"><em>false</em></tt>.<br>
          <br>

          <p>Некоторые базы данных не поддерживают механизм транзакций.
          В этом случае, функции <tt class="METHODNAME">transaction(),
          commit()</tt> и <tt class="METHODNAME">rollback()</tt> не
          выполняют никаких действий. Наличие поддержки механизма
          транзакций, той или иной базой данных, можно проверить с
          помощью метода <tt class="METHODNAME">hasFeature()</tt>,
          объекта <tt class="CLASSNAME">QSqlDriver</tt>,
          ассоциированного с базой данных:</p>
          <pre class="SCREEN">  QSqlDriver *driver = QSqlDatabase::database()-&gt;driver(); 
  if (driver-&gt;hasFeature(QSqlDriver::Transactions)) 
    ...
      
</pre>В примерах выше рассматривались случаи с единственным
подключением к базе данных. Однако ничто не мешает нам создать и
второе, и третье и т.д. соединения. В этом случае необходимо просто
передать имя соединения, вторым аргументом в функцию
          <tt class="METHODNAME">addDatabase()</tt>:
          <pre class="SCREEN">  QSqlDatabase *db = QSqlDatabase::addDatabase("QPSQL7", "OTHER"); 
  db-&gt;setHostName("saturn.mcmanamy.edu"); 
  db-&gt;setDatabaseName("starsdb"); 
  db-&gt;setUserName("gilbert"); 
  db-&gt;setPassword("ixtapa6");
      
</pre>Чтобы потом получить указатель на объект <tt class="CLASSNAME">
          QSqlDatabase</tt>, достаточно просто передать имя соединения
          в функцию <tt class="METHODNAME">QSqlDatabase::database()</tt>:
          <pre class="SCREEN">  QSqlDatabase *db = QSqlDatabase::database("OTHER");
      
</pre>Для исполнения запросов через эти соединения, необходимо передать
объект <tt class="CLASSNAME">QSqlDatabase</tt> конструктору
          <tt class="CLASSNAME">QSqlQuery</tt>:
          <pre class="SCREEN">  QSqlQuery query(db); 
  query.exec("SELECT id FROM artist WHERE name = 'Mando Diao'");
      
</pre>Каждое соединение с базой данных может поддерживать только одну
активную транзакцию, поэтому множественные подключения могут оказаться
полезными в том случае, когда необходимо одновременно запустить
несколько транзакций. При использовании нескольких соединений, в
приложении по прежнему имеется одно неименованное соединение, которое
используется по-умолчанию объектами <tt class="CLASSNAME">QSqlQuery</tt>, если им явно не указать с каким соединением
они должны работать.<br>
          <br>

          <p>В дополнение к <tt class="CLASSNAME">QSqlQuery</tt>, Qt
          предоставляет класс <tt class="CLASSNAME">QSqlCursor</tt>,
          производный от <tt class="CLASSNAME">QSqlQuery</tt>. Этот
          класс расширяет функциональность предка большим числом
          дополнительных методов, которые позволяют отказаться от
          написания SQL-запросов для наиболее употребимых SQL-операций,
          таких как: SELECT, INSERT, UPDATE и DELETE. Кроме того
          <tt class="CLASSNAME">QSqlCursor</tt> выступает в роли
          посредника между <tt class="CLASSNAME">QDataTable</tt> и
          базой данных. Далее, в этом разделе мы будем говорить о
          <tt class="CLASSNAME">QSqlCursor</tt>, а в следующем разделе
          покажем, как можно использовать <tt class="CLASSNAME">QDataTable</tt>, для представления наборов данных
          в табличной форме.</p>

          <p>Следующий пример демонстрирует выполнение SQL-запроса --
          SELECT:</p>
          <pre class="SCREEN">  QSqlCursor cursor("cd"); 
  cursor.select("year &gt;= 1998");
      
</pre>Эквивалентный вариант с использованием <tt class="CLASSNAME">
          QSqlQuery</tt>:
          <pre class="SCREEN">  QSqlQuery query("SELECT id, artistid, title, year FROM cd " 
                  "WHERE year &gt;= 1998");
      
</pre>Навигация по набору данных выполняется точно так же, как и в
<tt class="CLASSNAME">QSqlQuery</tt>, за одним маленьким исключением --
теперь, вместо порядкового номера поля, функции <tt class="METHODNAME">
          value()</tt> можно передать его имя:
          <pre class="SCREEN">  while (cursor.next()) { 
    QString title = cursor.value("title").toString(); 
    int year = cursor.value("year").toInt(); 
    cerr &lt;&lt; title.ascii() &lt;&lt; ": " &lt;&lt; year &lt;&lt; endl; 
  }
      
</pre>Для вставки записи в таблицу, предварительно нужно создать новую
запись <tt class="CLASSNAME">QSqlRecord</tt>, вызовом
          <tt class="METHODNAME">primeInsert()</tt>, а затем, для
          каждого из полей, вызвать <tt class="METHODNAME">setValue()</tt>. После всего этого можно
          выполнить вставку функцией <tt class="METHODNAME">insert()</tt>:
          <pre class="SCREEN">  QSqlCursor cursor("cd"); 
  QSqlRecord *buffer = cursor.primeInsert(); 
  buffer-&gt;setValue("id", 113); 
  buffer-&gt;setValue("artistid", 224); 
  buffer-&gt;setValue("title", "Shanghai My Heart"); 
  buffer-&gt;setValue("year", 2003); 
  cursor.insert();
      
</pre>Чтобы изменить запись -- нужно позиционировать
          <tt class="CLASSNAME">QSqlCursor</tt> на запись, которая
          должна подвергнуться изменениям (например, с помощью
          <tt class="METHODNAME">select()</tt> и <tt class="METHODNAME">next()</tt>). Получить указатель на <tt class="CLASSNAME">QSqlRecord</tt>, вызовом <tt class="METHODNAME">primeUpdate()</tt>. После этого записать новые
          значения функцией <tt class="METHODNAME">setValue()</tt> и
          вызвать <tt class="METHODNAME">update()</tt>, чтобы отправить
          сделанные изменения в базу данных:
          <pre class="SCREEN">  QSqlCursor cursor("cd"); 
  cursor.select("id = 125");
  if (cursor.next()) { 
    QSqlRecord *buffer = cursor.primeUpdate(); 
    buffer-&gt;setValue("title", "Melody A.M."); 
    buffer-&gt;setValue("year", buffer-&gt;value("year").toInt() + 1); 
    cursor.update(); 
  }
      
</pre>Процедура удаления записи похожа на процедуру изменения:
          <pre class="SCREEN">  QSqlCursor cursor("cd"); 
  cursor.select("id = 128"); 
  if (cursor.next()) { 
    cursor.primeDelete(); 
    cursor.del(); 
  }
      
</pre>Классы <tt class="CLASSNAME">QSqlQuery</tt> и
          <tt class="CLASSNAME">QSqlCursor</tt> реализуют интерфейс
          между Qt и базами данных SQL. В следующих двух разделах мы
          покажем как они могут использоваться в приложениях с
          графическим интерфейсом, которые позволяют пользователю
          просматривать и изменять наборы данных, хранящиеся в базе.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="PRESENTINGDATAINTABULARFORM"></a>12.2. Представление данных
          в табличной форме.</h1>

          <p>Класс <tt class="CLASSNAME">QDataTable</tt> -- это
          ориентированный на работу с базами данных виджет, наследник
          <tt class="CLASSNAME">QTable</tt>. Взаимодействие <tt class="CLASSNAME">QDataTable</tt> с базой данных осуществляется
          посредством <tt class="CLASSNAME">QSqlCursor</tt>. В этом
          разделе мы рассмотрим два диалога, которые используют виджет
          <tt class="CLASSNAME">QDataTable</tt>. Диалоги, работающие с
          <tt class="CLASSNAME">QSqlForm</tt> будут представлены в
          следующем разделе.</p>

          <p>Приложение, рассматриваемое здесь, работает с тремя
          таблицами, которые определены следующим образом:</p>
          <pre class="SCREEN">  CREATE TABLE artist ( 
      id INTEGER PRIMARY KEY, 
      name VARCHAR(40) NOT NULL, 
      country VARCHAR(40)); 
      
  CREATE TABLE cd ( 
      id INTEGER PRIMARY KEY, 
      artistid INTEGER NOT NULL, 
      title VARCHAR(40) NOT NULL, 
      year INTEGER NOT NULL, 
      FOREIGN KEY (artistid) REFERENCES artist); 
    
  CREATE TABLE track ( 
      id INTEGER PRIMARY KEY, 
      cdid INTEGER NOT NULL, 
      number INTEGER NOT NULL, 
      title VARCHAR(40) NOT NULL, 
      duration INTEGER NOT NULL, 
      FOREIGN KEY (cdid) REFERENCES cd);
      
</pre>Некоторые базы данных не поддерживают внешние ключи. В этом
случае вам следует удалить предложения FOREIGN KEY. Пример останется
работоспособным, но база данных не сможет соблюдать ссылочную
целостность данных.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig12.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 12.1. Таблицы приложения CD Collection.</p>
            </div>
          </div><br>
          Первым будет класс диалога, который позволит пользователю
          редактировать список исполнителей. С его помощью пользователь
          сможет добавлять, изменять или удалять сведения об
          исполнителях, выбирая соответствующие пункты контекстного
          меню <tt class="CLASSNAME">QDataTable</tt>. Внесенные
          изменения будут записываться в базу данных, по нажатию кнопки
          <strong class="COMMAND">Update</strong>.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig12.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 12.2. Диалог <tt class="CLASSNAME">ArtistForm</tt>.</p>
            </div>
          </div><br>
          Определение класса диалога:
          <pre class="SCREEN">class ArtistForm : public QDialog 
{ 
  Q_OBJECT 
public: 
  ArtistForm(QWidget *parent = 0, const char *name = 0); 
  
protected slots: 
  void accept(); 
  void reject(); 
  
private slots: 
  void primeInsertArtist(QSqlRecord *buffer); 
  void beforeInsertArtist(QSqlRecord *buffer); 
  void beforeDeleteArtist(QSqlRecord *buffer); 
  
private: 
  QSqlDatabase *db; 
  QDataTable *artistTable; 
  QPushButton *updateButton;
  QPushButton *cancelButton; 
};
      
</pre>Слоты <tt class="METHODNAME">accept()</tt> и <tt class="METHODNAME">reject()</tt> унаследованы от <tt class="CLASSNAME">
          QDialog</tt>.
          <pre class="SCREEN">ArtistForm::ArtistForm(QWidget *parent, const char *name) 
    : QDialog(parent, name) 
{ 
  setCaption(tr("Update Artists")); 
  
  db = QSqlDatabase::database("ARTIST"); 
  db-&gt;transaction(); 
  
  QSqlCursor *artistCursor = new QSqlCursor("artist", true, db); 
  artistTable = new QDataTable(artistCursor, false, this); 
  artistTable-&gt;addColumn("name", tr("Name")); 
  artistTable-&gt;addColumn("country", tr("Country")); 
  artistTable-&gt;setAutoDelete(true); 
  artistTable-&gt;setConfirmDelete(true); 
  artistTable-&gt;setSorting(true); 
  artistTable-&gt;refresh(); 
  
  updateButton = new QPushButton(tr("Update"), this); 
  updateButton-&gt;setDefault(true); 
  cancelButton = new QPushButton(tr("Cancel"), this);
      
</pre>В конструкторе <tt class="CLASSNAME">ArtistForm</tt> запускается
транзакция для соединения под именем "ARTIST". Затем
создается <tt class="CLASSNAME">QSqlCursor</tt>, для таблицы
          <tt class="CLASSNAME">artist</tt> в базе данных, и <tt class="CLASSNAME">QDataTable</tt>, которая будет отображать
          содержимое таблицы.<br>
          <br>

          <p>Второй аргумент конструктора <tt class="CLASSNAME">QSqlCursor</tt> -- это флаг
          "автозаполнение". Если в этом аргументе передать
          <tt class="PARAMETER"><em>true</em></tt>, <tt class="CLASSNAME">QSqlCursor</tt> будет загружать информацию о
          каждом из полей в таблице.</p>

          <p>Второй аргумент конструктора <tt class="CLASSNAME">QDataTable</tt> -- так же флаг
          "автозаполнение". В случае <tt class="PARAMETER"><em>true</em></tt>, <tt class="CLASSNAME">QDataTable</tt> будет автоматически создавать
          колонки для каждого из полей в <tt class="CLASSNAME">QSqlCursor</tt>. В нашем примере этот флаг
          передается со значением <tt class="PARAMETER"><em>false</em></tt> и с помощью <tt class="METHODNAME">addColumn()</tt> в виджет добавляются две
          колонки, соответствующие полям <tt class="METHODNAME">name</tt> и <tt class="METHODNAME">country</tt>.</p>

          <p>Владение объектом <tt class="CLASSNAME">QSqlCursor</tt>
          передается виджету <tt class="CLASSNAME">QDataTable</tt>.
          Вызовом <tt class="METHODNAME">setAutoDelete()</tt>
          устанавливается режим автоматического удаления записей,
          средствами <tt class="CLASSNAME">QDataTable</tt>, таким
          образом нам не нужно будет писать дополнительный код,
          удаляющий записи из таблицы. Вызовом <tt class="METHODNAME">setConfirmDelete()</tt> устанавливается режим
          подтверждения удаления, теперь <tt class="CLASSNAME">QDataTable</tt> будет выкидывать перед
          пользователем окно с запросом на подтверждение выполнения
          операции удаления. Функция <tt class="METHODNAME">setSorting(true)</tt> позволит пользователю
          выполнять сортировку данных в виджете, щелчком мыши по
          заголовкам колонок. В заключение вызывается функция
          <tt class="METHODNAME">refresh()</tt>, которая заполняет
          <tt class="CLASSNAME">QDataTable</tt> данными.</p>

          <p>Затем создаются кнопки <strong class="COMMAND">Update</strong> и <strong class="COMMAND">Cancel</strong>.</p>
          <pre class="SCREEN">  connect(artistTable, SIGNAL(beforeDelete(QSqlRecord *)), 
          this, SLOT(beforeDeleteArtist(QSqlRecord *))); 
  connect(artistTable, SIGNAL(primeInsert(QSqlRecord *)), 
          this, SLOT(primeInsertArtist(QSqlRecord *))); 
  connect(artistTable, SIGNAL(beforeInsert(QSqlRecord *)), 
          this, SLOT(beforeInsertArtist(QSqlRecord *))); 
  connect(updateButton, SIGNAL(clicked()), 
          this, SLOT(accept())); 
  connect(cancelButton, SIGNAL(clicked()), 
          this, SLOT(reject()));
      
</pre>Здесь подключаются три сигнала от <tt class="CLASSNAME">
          QDataTable</tt> к трем приватным слотам. Кнопка
          <strong class="COMMAND">Update</strong> соединяется со слотом
          <tt class="METHODNAME">accept()</tt>, кнопка <strong class="COMMAND">Cancel</strong> -- со слотом <tt class="METHODNAME">reject()</tt>.
          <pre class="SCREEN">  QHBoxLayout *buttonLayout = new QHBoxLayout; 
  buttonLayout-&gt;addStretch(1); 
  buttonLayout-&gt;addWidget(updateButton); 
  buttonLayout-&gt;addWidget(cancelButton); 
  QVBoxLayout *mainLayout = new QVBoxLayout(this); 
  mainLayout-&gt;setMargin(11); 
  mainLayout-&gt;setSpacing(6); 
  mainLayout-&gt;addWidget(artistTable); 
  mainLayout-&gt;addLayout(buttonLayout); 
}
      
</pre>В заключение кнопки передаются менеджеру размещения по
горизонтали, а <tt class="CLASSNAME">QDataTable</tt> и менеджер
размещения по горизонтали -- менеджеру размещения по вертикали.
          <pre class="SCREEN">void ArtistForm::accept() 
{ 
  db-&gt;commit(); 
  QDialog::accept(); 
}
      
</pre>Когда пользователь нажимает кнопку <strong class="COMMAND">
          Update</strong>, выполняется подтверждение транзакции и
          вызывается унаследованный метод <tt class="METHODNAME">accept()</tt> предка.
          <pre class="SCREEN">void ArtistForm::reject() 
{ 
  db-&gt;rollback(); 
  QDialog::reject(); 
}
      
</pre>Когда пользователь нажимает кнопку <strong class="COMMAND">
          Cancel</strong>, выполняется откат транзакции и вызывается
          унаследованный метод <tt class="METHODNAME">reject()</tt>
          предка.
          <pre class="SCREEN">void ArtistForm::beforeDeleteArtist(QSqlRecord *buffer) 
{ 
  QSqlQuery query(db); 
  query.exec("DELETE FROM track WHERE track.id IN " 
             "(SELECT track.id FROM track, cd " 
             "WHERE track.cdid = cd.id AND cd.artistid = " 
             + buffer-&gt;value("id").toString() + ")"); 
  query.exec("DELETE FROM cd WHERE artistid = " 
             + buffer-&gt;value("id").toString()); 
}
      
</pre>Слот <tt class="METHODNAME">beforeDeleteArtist()</tt> связан с
сигналом <tt class="METHODNAME">beforeDelete()</tt>, виджета
          <tt class="CLASSNAME">QDataTable</tt>, который выдается
          непосредственно перед удалением записи. Здесь выполняется
          каскадное удаление записей, запуском двух запросов: первый
          удаляет все записи о дорожках на CD по исполнителю, второй --
          все CD по исполнителю. Эти операции не нарушают целостность
          базы данных, потому что выполняются в контексте одной
          транзакции, которая была запущена в конструкторе формы.
          <pre class="SCREEN">void ArtistForm::primeInsertArtist(QSqlRecord *buffer) 
{ 
  buffer-&gt;setValue("country", "USA"); 
}
      
</pre>Слот <tt class="METHODNAME">primeInsertArtist()</tt> связан с
сигналом <tt class="METHODNAME">primeInsert()</tt>, виджета
          <tt class="CLASSNAME">QDataTable</tt>, который выдается
          непосредственно перед созданием новой записи. Здесь
          устанавливается значение по-умолчанию для поля <tt class="VARNAME">country</tt>.<br>
          <br>

          <p>Это один из способов установки значений по-умолчанию.
          Другой способ состоит в создании производного класса от
          <tt class="CLASSNAME">QSqlCursor</tt> и перекрытии метода
          <tt class="METHODNAME">primeInsert()</tt>, но такая метода
          имеет смысл только в том случае, если один и тот же класс
          <tt class="CLASSNAME">QSqlCursor</tt> используется в
          нескольких местах в приложении и обеспечивает
          непротиворечивость интерфейса. Третий вариант -- сделать это
          на уровне базы данных, с помощью предложения DEFAULT в блоке
          CREATE TABLE.</p>
          <pre class="SCREEN">void ArtistForm::beforeInsertArtist(QSqlRecord *buffer) 
{ 
  buffer-&gt;setValue("id", generateId("artist", db)); 
}
      
</pre>Слот <tt class="METHODNAME">beforeInsertArtist()</tt> связан с
сигналом <tt class="METHODNAME">beforeInsert()</tt>, виджета
          <tt class="CLASSNAME">QDataTable</tt>, который выдается в тот
          момент, когда пользователь завершает редактирование записи и
          нажимает клавишу <strong class="COMMAND">Enter</strong>,
          чтобы подтвердить изменения. Здесь устанавливается значение
          поля <tt class="VARNAME">id</tt>. Функция <tt class="METHODNAME">generateId()</tt> генерирует уникальное значение
          для первичного ключа.<br>
          <br>

          <p>Так как эта функция будет использоваться в разных местах
          приложения, она определена как <tt class="PARAMETER"><em>inline</em></tt> в заголовочном файле ,
          который будет подключаться к файлам с исходными текстами по
          мере необходимости. Ниже приводится быстрый (но
          малоэффективный) вариант функции:</p>
          <pre class="SCREEN">inline int generateId(const QString &amp;table, QSqlDatabase *db) 
{ 
  QSqlQuery query(db); 
  query.exec("SELECT max(id) FROM " + table); 
  query.next(); 
  return query.value(0).toInt() + 1; 
}
      
</pre>Функция <tt class="METHODNAME">generateId()</tt> гарантирует
корректную работу только в контексте той же самой транзакции, где
исполняется соответствующее выражение INSERT.<br>
          <br>

          <p>Некоторые типы баз данных поддерживают автоматическую
          генерацию значений полей. В этом случае нужно просто
          настроить базу данных на автоматическую генерацию значений
          поля <tt class="VARNAME">id</tt> и вызвать <tt class="METHODNAME">setGenerated("id", false)</tt> класса
          <tt class="CLASSNAME">QSqlCursor</tt>, чтобы сообщить ему,
          что <span class="emphasis"><em class="EMPHASIS">не</em></span> нужно генерировать значения для
          поля <tt class="VARNAME">id</tt>.</p>

          <p>Теперь рассмотрим другой диалог, который использует
          <tt class="CLASSNAME">QDataTable</tt>. Этот диалог реализует
          просмотр таблиц, связанных отношением
          "мастер-деталь". Мастер-таблица -- это список
          компакт дисков (CD). Деталь-таблица -- список дорожек на
          текущем диске. Этот диалог является главным окном приложения
          CD Collection.</p>

          <p>На этот раз, вместо контекстного меню, на форму диалога
          положены кнопки <strong class="COMMAND">Add, Edit</strong> и
          <strong class="COMMAND">Delete</strong>, которые позволяют
          пользователю вносить изменения в список компакт дисков. Когда
          пользователь нажимает на кнопку <strong class="COMMAND">Add</strong> или <strong class="COMMAND">Edit</strong>, перед ним появляется диалог
          <tt class="VARNAME">CDForm</tt>. (Описание формы будет
          приведено в следующем разделе.)</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig12.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 12.3. Диалог <tt class="CLASSNAME">MainForm</tt>.</p>
            </div>
          </div><br>
          Еще одно отличие этого примера от предыдущего заключается в
          том, что теперь придется работать с внешними ключами, чтобы
          вместо числового идентификатора исполнителя вывести его имя и
          название страны. Чтобы добиться этого, необходимо
          использовать класс <tt class="CLASSNAME">QSqlSelectCursor</tt>, производный от класса
          <tt class="CLASSNAME">QSqlCursor</tt>.<br>
          <br>

          <p>Определение класса главного окна:</p>
          <pre class="SCREEN">class MainForm : public QDialog 
{ 
  Q_OBJECT 
public: 
  MainForm(QWidget *parent = 0, const char *name = 0); 
  
private slots: 
  void addCd(); 
  void editCd(); 
  void deleteCd(); 
  void currentCdChanged(QSqlRecord *record); 
  
private: 
  QSplitter *splitter; 
  QDataTable *cdTable; 
  QDataTable *trackTable; 
  QPushButton *addButton;
  ...
  QPushButton *quitButton; 
};
      
</pre>Класс <tt class="CLASSNAME">MainForm</tt> -- производный от
класса <tt class="CLASSNAME">QDialog</tt>.
          <pre class="SCREEN">MainForm::MainForm(QWidget *parent, const char *name) 
    : QDialog(parent, name) 
{ 
  setCaption(tr("CD Collection")); 
  
  splitter = new QSplitter(Vertical, this); 
  
  QSqlSelectCursor *cdCursor = new QSqlSelectCursor( 
                  "SELECT cd.id, title, name, country, year " 
                  "FROM cd, artist WHERE cd.artistid = artist.id"); 
  if (!cdCursor-&gt;isActive()) { 
    QMessageBox::critical(this, tr("CD Collection"), 
            tr("The database has not been created.\n" 
            "Run the cdtables example to create a sample " 
            "database, then copy cdcollection.dat into " 
            "this directory and restart this application.")); 
    qApp-&gt;quit(); 
  }

  cdTable = new QDataTable(cdCursor, false, splitter); 
  cdTable-&gt;addColumn("title", tr("CD")); 
  cdTable-&gt;addColumn("name", tr("Artist")); 
  cdTable-&gt;addColumn("country", tr("Country")); 
  cdTable-&gt;addColumn("year", tr("Year")); 
  cdTable-&gt;setAutoDelete(true); 
  cdTable-&gt;refresh();
      
</pre>В конструкторе создается <tt class="CLASSNAME">QDataTable</tt>
для таблицы <tt class="VARNAME">cd</tt> и связанный с ней курсор.
Курсор основан на запросе, который соединяет таблицы
          <tt class="VARNAME">cd</tt> и <tt class="VARNAME">artist</tt>. <tt class="CLASSNAME">QDataTable</tt>
          работает в режиме "только для чтения", потому что
          взаимодействует с объектом класса <tt class="CLASSNAME">QSqlSelectCursor</tt>. Виджет таблицы, работающий
          "только на чтение" не имеет контекстного меню.<br>
          <br>

          <p>Если попытка выполнения запроса терпит неудачу, перед
          пользователем выводится окно, с сообщением об ошибке, и на
          этом работа приложения завершается.</p>
          <pre class="SCREEN">  QSqlCursor *trackCursor = new QSqlCursor("track"); 
  trackCursor-&gt;setMode(QSqlCursor::ReadOnly); 
  trackTable = new QDataTable(trackCursor, false, splitter); 
  trackTable-&gt;setSort(trackCursor-&gt;index("number")); 
  trackTable-&gt;addColumn("title", tr("Track")); 
  trackTable-&gt;addColumn("duration", tr("Duration"));
      
</pre>Здесь создается второй виджет <tt class="CLASSNAME">QDataTable</tt> и его курсор. Вызовом <tt class="METHODNAME">setMode(QSqlCursor::ReadOnly)</tt> таблица переводится в
режим "только для чтения", а вызовом <tt class="METHODNAME">
          setSort()</tt> выполняется сортировка по полю с номером
          дорожки.
          <pre class="SCREEN">  addButton = new QPushButton(tr("&amp;Add"), this); 
  editButton = new QPushButton(tr("&amp;Edit"), this); 
  deleteButton = new QPushButton(tr("&amp;Delete"), this); 
  refreshButton = new QPushButton(tr("&amp;Refresh"), this); 
  quitButton = new QPushButton(tr("&amp;Quit"), this);
  
  connect(addButton, SIGNAL(clicked()), 
          this, SLOT(addCd())); 
  ... 
  connect(quitButton, SIGNAL(clicked()), 
          this, SLOT(close())); 
  connect(cdTable, SIGNAL(currentChanged(QSqlRecord *)), 
          this, SLOT(currentCdChanged(QSqlRecord *))); 
  connect(cdTable, SIGNAL(doubleClicked(int, int, int, const QPoint &amp;)), 
          this, SLOT(editCd())); 
  ... 
} 
      
</pre>Здесь настраивается остальная часть пользовательского интерфейса
и создаются необходимые соединения "сигнал-слот".
          <pre class="SCREEN">void MainForm::addCd() 
{ 
  CdForm form(this); 
  if (form.exec()) { 
    cdTable-&gt;refresh(); 
    trackTable-&gt;refresh(); 
  } 
}
      
</pre>Когда пользователь нажимает на кнопку <strong class="COMMAND">
          Add</strong>, вызывается модальный диалог <tt class="VARNAME">CdForm</tt> и, если пользователь в этом диалоге
          нажмет на кнопку <strong class="COMMAND">Update</strong>,
          выполняется обновление таблиц <tt class="CLASSNAME">QDataTable</tt>.
          <pre class="SCREEN">void MainForm::editCd() 
{ 
  QSqlRecord *record = cdTable-&gt;currentRecord(); 
  if (record) { 
    CdForm form(record-&gt;value("id").toInt(), this); 
    if (form.exec()) { 
      cdTable-&gt;refresh(); 
      trackTable-&gt;refresh(); 
    } 
  } 
}
      
</pre>Когда пользователь нажимает на кнопку <strong class="COMMAND">
          Edit</strong>, вызывается модальный диалог <tt class="VARNAME">CdForm</tt>, конструктору которого, передается
          идентификатор текущего компакт диска. В этом случае диалог
          запускается с заполненными полями, соответствующими заданному
          CD.<br>
          <br>

          <p>При таком варианте параметризации формы диалога, возможна
          ситуация, когда к моменту появления окна диалога,
          идентификатор диска уже будет отсутствовать в базе данных.
          Например, пользователь мог нажать кнопку <strong class="COMMAND">Edit</strong> за доли секунды до того, как другой
          пользователь удалил запрашиваемый компакт диск из базы
          данных. Для решения этой проблемы мы могли бы в <tt class="VARNAME">CdForm</tt> выполнить запрос SELECT по заданному
          идентификатору диска и продолжать работу только в том случае,
          если диск еще присутствует в базе. Однако здесь мы полностью
          полагаемся на сообщение об ошибке от базы данных.</p>
          <pre class="SCREEN">void MainForm::deleteCd() 
{ 
  QSqlRecord *record = cdTable-&gt;currentRecord();
  
  if (record) { 
    QSqlQuery query; 
    query.exec("DELETE FROM track WHERE cdid = " 
               + record-&gt;value("id").toString()); 
    query.exec("DELETE FROM cd WHERE id = " 
               + record-&gt;value("id").toString()); 
    cdTable-&gt;refresh(); 
    trackTable-&gt;refresh(); 
  } 
}
      
</pre>Когда пользователь нажимает на кнопку <strong class="COMMAND">
          Delete</strong>, выполняется удаление всех дорожек диска из
          таблицы <tt class="VARNAME">track</tt>, после чего удаляется
          запись из таблицы <tt class="VARNAME">cd</tt>. В завершение
          обновляются обе таблицы-виджеты.
          <pre class="SCREEN">void MainForm::currentCdChanged(QSqlRecord *record) 
{ 
  trackTable-&gt;setFilter("cdid = " 
                        + record-&gt;value("id").toString()); 
  trackTable-&gt;refresh(); 
}
      
</pre>Слот <tt class="METHODNAME">currentCdChanged()</tt> связан с
сигналом <tt class="METHODNAME">currentChanged()</tt> объекта
          <tt class="VARNAME">cdTable</tt>, который выдается, когда
          пользователь вносит изменения в текущую запись о CD или
          перемещается к другой записи. Всякий раз, когда это
          происходит, вызывается функция <tt class="METHODNAME">setFilter()</tt> и обновляется таблица
          <tt class="VARNAME">trackTable</tt>. Таким образом она всегда
          будет отображать только те дорожки, которые относятся к
          текущему CD.<br>
          <br>

          <p>По сути -- это весь код, реализующий функциональность
          <tt class="CLASSNAME">MainForm</tt>. Однако тут следует
          упомянуть об одном небольшом улучшении, которое можно
          добавить. Суть его заключается в том, чтобы показывать
          длительность звучания дорожки не в секундах (например,
          "155"), как это делается сейчас, а в минутах и
          секундах (например, "02:35"). С этой целью
          необходимо создать производный класс от <tt class="CLASSNAME">QSqlCursor</tt> и перекрыть в нем метод
          <tt class="METHODNAME">calculateField()</tt>, для
          преобразования значения поля <tt class="VARNAME">duration</tt> в <tt class="CLASSNAME">QString</tt>
          с заданным форматом представления:</p>
          <pre class="SCREEN">QVariant TrackSqlCursor::calculateField(const QString &amp;name) 
{ 
  if (name == "duration") { 
    int duration = value("duration").toInt(); 
    return QString("%1:%2").arg(duration / 60, 2) 
                           .arg(duration % 60, 2); 
  } 
  return QVariant(); 
}
      
</pre>Кроме того, в этом случае необходимо вызвать метод курсора
<tt class="METHODNAME">setCalculated("duration", true)</tt>,
чтобы <tt class="CLASSNAME">QDataTable</tt> использовала значение поля
<tt class="VARNAME">duration</tt>, возвращаемое функцией
          <tt class="METHODNAME">calculateField()</tt>.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="CREATINGDATAAWAREFORMS"></a>12.3. Разработка форм,
          ориентированных на работу с базами данных.</h1>

          <p>Qt предлагает инновационный подход к организации
          взаимодействий форм с базами данных. Вместо того, чтобы
          создавать отдельные версии встроенных виджетов, для работы с
          данными, Qt делает любой виджет ориентированным на работу с
          базами данных, с помощью класов <tt class="CLASSNAME">QSqlForm</tt> и <tt class="CLASSNAME">QSqlPropertyMap</tt>, которые выступают
          посредниками между базой данных и виджетами. Любой виджет, не
          зависимо от того -- стандартный он или нет, сможет работать с
          базами данных, при использовании этих классов.</p>

          <p>Класс <tt class="CLASSNAME">QSqlForm</tt>, производный от
          <tt class="CLASSNAME">QObject</tt>, облегчает создание форм
          для просмотра и изменения отдельных записей. В общем случае,
          порядок создания формы диалога выглядит следующим
          образом:</p>

          <ol type="1">
            <li>
              <p>Создаются виджеты-редакторы (<tt class="CLASSNAME">QLineEdit, QComboBox, QSpinBox</tt> и т.п.)
              для каждого из полей записи.</p>
            </li>

            <li>
              <p>Создается экземпляр <tt class="CLASSNAME">QSqlCursor</tt>.</p>
            </li>

            <li>
              <p>Создается экземпляр <tt class="CLASSNAME">QSqlForm</tt>.</p>
            </li>

            <li>
              <p>Выполняется настройка <tt class="CLASSNAME">QSqlForm</tt>, которая заключается в
              связывании полей записи с виджетами.</p>
            </li>

            <li>
              <p>Вызывается метод <tt class="METHODNAME">QSqlForm::readFields()</tt>, который
              заполняет виджеты данными.</p>
            </li>

            <li>
              <p>Диалог выводится перед пользователем.</p>
            </li>

            <li>
              <p>По завершении работы диалога, Вызывается метод
              <tt class="METHODNAME">QSqlForm::writeFields()</tt>,
              чтобы скопировать измененные значения обратно в базу
              данных.</p>
            </li>
          </ol>Все эти действия мы продемонстрируем на примере диалога
          <tt class="CLASSNAME">CdForm</tt>. Он предназначен для
          создания и изменения записи о компакт диске. Пользователь
          может задать название диска, исполнителя и год выпуска, а так
          же название и продолжительность каждого произведения на
          диске.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig12.4.png"></p>

            <div class="CAPTION">
              <p>Рисунок 12.4. Диалог <tt class="CLASSNAME">CdForm</tt>.</p>
            </div>
          </div><br>
          Начнем с определения класса:
          <pre class="SCREEN">class CdForm : public QDialog 
{
  Q_OBJECT 
public: 
  CdForm(QWidget *parent = 0, const char *name = 0); 
  CdForm(int id, QWidget *parent = 0, const char *name = 0); 
  ~CdForm(); 
  
protected slots: 
  void accept(); 
  void reject(); 
  
private slots: 
  void addNewArtist(); 
  void moveTrackUp(); 
  void moveTrackDown(); 
  void beforeInsertTrack(QSqlRecord *buffer); 
  void beforeDeleteTrack(QSqlRecord *buffer); 
  
private: 
  void init(); 
  void createNewRecord(); 
  void swapTracks(int trackA, int trackB); 
  
  QLabel *titleLabel; 
  QLabel *artistLabel;
  ...
  QDataTable *trackTable; 
  QSqlForm *sqlForm; 
  QSqlCursor *cdCursor; 
  QSqlCursor *trackCursor; 
  int cdId; 
  bool newCd; 
};
      
</pre>В классе объявлены два конструктора: один вставляет новую запись
в базу данных, другой -- обновляет существующую запись. Слоты
          <tt class="METHODNAME">accept()</tt> и <tt class="METHODNAME">reject()</tt> унаследованы от <tt class="CLASSNAME">QDialog</tt>.
          <pre class="SCREEN">CdForm::CdForm(QWidget *parent, const char *name) 
    : QDialog(parent, name) 
{ 
  setCaption(tr("Add a CD")); 
  cdId = -1; 
  init(); 
}
      
</pre>Первый конструктор записывает в заголовок диалога строку
"Add a CD" ("добавить диск") и вызывает приватную
функцию <tt class="METHODNAME">init()</tt>, которая выполняет остальную
часть работы.
          <pre class="SCREEN">CdForm::CdForm(int id, QWidget *parent, const char *name) 
    : QDialog(parent, name) 
{ 
  setCaption(tr("Edit a CD")); 
  cdId = id; 
  init(); 
}
      
</pre>Второй конструктор записывает в заголовок диалога строку
"Edit a CD" ("изменить сведения о диске") и так же
вызывает функцию <tt class="METHODNAME">init()</tt>.
          <pre class="SCREEN">void CdForm::init() 
{ 
  db = QSqlDatabase::database("CD"); 
  db-&gt;transaction(); 
  if (cdId == -1) 
    createNewRecord();
      
</pre>В функции <tt class="METHODNAME">init()</tt> запускается
транзакция для соединения под именем "CD". Для диалогов
<tt class="CLASSNAME">CdForm</tt> и <tt class="CLASSNAME">ArtistForm</tt> используются различные соединения,
поскольку оба они могут отображаться одновременно и при этом нельзя
допустить, чтобы операция <strong class="COMMAND">Cancel</strong> в
одной форме выполняла откат транзакции, запущенной в другой форме.<br>

          <br>

          <p>Если идентификатор диска не задан, вызывается функция
          <tt class="METHODNAME">createNewRecord()</tt>, которая
          вставляет пустую запись в таблицу. Это позволит использовать
          <tt class="VARNAME">cdId</tt> как внешний ключ для <tt class="CLASSNAME">QDataTable</tt> с дорожками. Если пользователь
          нажмет на кнопку <strong class="COMMAND">Cancel</strong>, все
          изменения, произведенные в контексте транзакции, будут
          отменены, в том числе и операция вставки новой записи.</p>

          <p>В этом диалоге используется еще одно соединение с базой
          данных, отличное от того, что используется в <tt class="CLASSNAME">ArtistForm</tt>. Сделано это так потому, что в
          соединении, активной может быть только одна транзакция, а в
          данном приложении может сложиться ситуация, когда потребуется
          иметь две активных транзакции одновременно, например, в
          случае, когда пользователь нажимает кнопку <strong class="COMMAND">Add New</strong> и открывает диалог <tt class="CLASSNAME">ArtistForm</tt>.</p>
          <pre class="SCREEN">  titleLabel = new QLabel(tr("&amp;Title:"), this); 
  artistLabel = new QLabel(tr("&amp;Artist:"), this); 
  yearLabel = new QLabel(tr("&amp;Year:"), this); 
  titleLineEdit = new QLineEdit(this); 
  yearSpinBox = new QSpinBox(this); 
  yearSpinBox-&gt;setRange(1900, 2100); 
  yearSpinBox-&gt;setValue(QDate::currentDate().year()); 
  artistComboBox = new ArtistComboBox(db, this); 
  artistButton = new QPushButton(tr("Add &amp;New..."), this); 
  ... 
  cancelButton = new QPushButton(tr("Cancel"), this);
      
</pre>На форме диалога размещаются текстовые метки, поле ввода,
счетчик, выпадающий список и кнопки. Выпадающий список принадлежит к
классу <tt class="CLASSNAME">ArtistComboBox</tt>, о котором мы
поговорим немного ниже.
          <pre class="SCREEN">  trackCursor = new QSqlCursor("track", true, db); 
  trackTable = new QDataTable(trackCursor, false, this); 
  trackTable-&gt;setFilter("cdid = " + QString::number(cdId)); 
  trackTable-&gt;setSort(trackCursor-&gt;index("number")); 
  trackTable-&gt;addColumn("title", tr("Track")); 
  trackTable-&gt;addColumn("duration", tr("Duration")); 
  trackTable-&gt;refresh();
      
</pre>Далее создается и настраивается <tt class="CLASSNAME">QDataTable</tt>, которая позволит пользователю
просматривать и изменять сведения о дорожках на текущем компакт диске.
Очень напоминает то, что мы делали с классом <tt class="CLASSNAME">
          ArtistForm</tt>, в предыдущем разделе.
          <pre class="SCREEN">  cdCursor = new QSqlCursor("cd", true, db); 
  cdCursor-&gt;select("id = " + QString::number(cdId)); 
  cdCursor-&gt;next();
      
</pre>Создается <tt class="CLASSNAME">QSqlCursor</tt> и текущей, для
него, делается запись, содержащая идентификатор требуемого диска.
          <pre class="SCREEN">  QSqlPropertyMap *propertyMap = new QSqlPropertyMap; 
  propertyMap-&gt;insert("ArtistComboBox", "artistId"); 
  sqlForm = new QSqlForm(this); 
  sqlForm-&gt;installPropertyMap(propertyMap); 
  sqlForm-&gt;setRecord(cdCursor-&gt;primeUpdate()); 
  sqlForm-&gt;insert(titleLineEdit, "title"); 
  sqlForm-&gt;insert(artistComboBox, "artistid"); 
  sqlForm-&gt;insert(yearSpinBox, "year"); 
  sqlForm-&gt;readFields();
      
</pre>Класс <tt class="CLASSNAME">QSqlPropertyMap</tt> хранит сведения,
благодаря которым <tt class="CLASSNAME">QSqlForm</tt> "знает"
-- значения какого типа, в каком свойстве, может хранить тот или иной
виджет-редактор. Класс <tt class="CLASSNAME">QSqlForm</tt> уже
"знает", что <tt class="CLASSNAME">QLineEdit</tt> запоминает
свое значение в свойстве <tt class="VARNAME">text</tt>, а
          <tt class="CLASSNAME">QSpinBox</tt> -- в свойстве <tt class="VARNAME">value</tt>. Но он ничего не знает о нестандартных
          виджетах, коим является <tt class="CLASSNAME">ArtistComboBox</tt>. Поэтому мы должны вставить
          название класса и имя свойства класса
          ("ArtistComboBox", "artistId") в карту
          свойств и вызвать <tt class="METHODNAME">installPropertyMap()</tt>, чтобы указать
          <tt class="CLASSNAME">QSqlForm</tt>, что при работе с
          виджетом класса <tt class="CLASSNAME">ArtistComboBox</tt>
          следует использовать свойство <tt class="VARNAME">artistId</tt>.<br>
          <br>

          <p>Кроме того экземпляру класса <tt class="CLASSNAME">QSqlForm</tt> нужно передать буфер, с которым он
          будет работать, а так же сообщить о том, какой виджет, какому
          полю в таблице соответствует. В заключение, вызовом
          <tt class="METHODNAME">readFields()</tt>, данные считываются
          из базы и переносятся в виджеты.</p>
          <pre class="SCREEN">  connect(artistButton, SIGNAL(clicked()), 
          this, SLOT(addNewArtist())); 
  connect(moveUpButton, SIGNAL(clicked()), 
          this, SLOT(moveTrackUp())); 
  connect(moveDownButton, SIGNAL(clicked()), 
          this, SLOT(moveTrackDown())); 
  connect(updateButton, SIGNAL(clicked()), 
          this, SLOT(accept())); 
  connect(cancelButton, SIGNAL(clicked()), 
          this, SLOT(reject())); 
  connect(trackTable, SIGNAL(beforeInsert(QSqlRecord *)), 
          this, SLOT(beforeInsertTrack(QSqlRecord *))); 
  ... 
}
      
</pre>На последней стадии выполнения функции производится соединение
сигналов и слотов, которые будут описаны несколько ниже.
          <pre class="SCREEN">void CdForm::accept() 
{ 
  sqlForm-&gt;writeFields(); 
  cdCursor-&gt;update(); 
  db-&gt;commit(); 
  QDialog::accept(); 
}
      
</pre>Когда пользователь нажимает на кнопку <strong class="COMMAND">
          Update</strong>, производится запись новых значений полей в
          буфер редактирования объекта <tt class="CLASSNAME">QSqlCursor</tt>. Затем выполняется
          SQL-предложение UPDATE, вызовом функции <tt class="METHODNAME">update()</tt>, вызовом <tt class="METHODNAME">commit()</tt> подтверждается транзакция и в
          заключение вызывается метод <tt class="METHODNAME">accept()</tt>, унаследованный от <tt class="CLASSNAME">QDialog</tt>.
          <pre class="SCREEN">void CdForm::reject() 
{ 
  db-&gt;rollback(); 
  QDialog::reject(); 
}
      
</pre>Когда пользователь нажимает на кнопку <strong class="COMMAND">
          Cancel</strong>, производится откат произведенных изменений и
          форма диалога закрывается.
          <pre class="SCREEN">void CdForm::addNewArtist() 
{ 
  ArtistForm form(this); 
  if (form.exec()) { 
    artistComboBox-&gt;refresh(); 
    updateButton-&gt;setEnabled(artistComboBox-&gt;count() &gt; 0); 
  } 
}
      
</pre>Когда пользователь нажимает на кнопку <strong class="COMMAND">
          Add New</strong>, запускается модальный диалог <tt class="CLASSNAME">ArtistForm</tt>. Этот диалог позволяет добавлять
          нового исполнителя в базу данных, удалять или изменять
          сведения об исполнителях. Если пользователь нажмет кнопку
          <strong class="COMMAND">Update</strong>, будет вызвана
          функция <tt class="METHODNAME">ArtistComboBox::refresh()</tt>, которая обновит
          список исполнителей в виджете.<br>
          <br>

          <p>Если в списке нет ни одного исполнителя, кнопка
          <strong class="COMMAND">Update</strong> будет запрещена,
          поскольку необходимо избежать создания записи о CD, без
          указания имени исполнителя.</p>
          <pre class="SCREEN">void CdForm::beforeInsertTrack(QSqlRecord *buffer) 
{ 
  buffer-&gt;setValue("id", generateId("track", db)); 
  buffer-&gt;setValue("number", trackCursor-&gt;size() + 1); 
  buffer-&gt;setValue("cdid", cdId); 
}
      
</pre>Слот <tt class="METHODNAME">beforeInsertTrack()</tt> связан с
сигналом <tt class="METHODNAME">beforeInsert()</tt>. Он заполняет поля
<tt class="VARNAME">id, number</tt> и <tt class="VARNAME">cdid</tt>.
          <pre class="SCREEN">void CdForm::beforeDeleteTrack(QSqlRecord *buffer) 
{ 
  QSqlQuery query(db); 
  query.exec("UPDATE track SET number = number - 1 " 
             "WHERE track.number &gt; " 
             + buffer-&gt;value("number").toString()); 
}
      
</pre>Слот <tt class="METHODNAME">beforeDeleteTrack()</tt> связан с
сигналом <tt class="METHODNAME">beforeDelete()</tt>. Он выполняет
перенумерацию дорожек на диске, чьи номера больше номера удаляемой
дорожки, чтобы сохранить неразрывность последовательности номеров
дорожек. Например, допустим, что диск содержит 6 дорожек и пользователь
удаляет 4-ю, тогда 5-я дорожка получит номер 4, а 6-я -- 5.<br>

          <br>

          <p>Имеется еще 4 функции, описание которых мы не привели:
          <tt class="METHODNAME">moveTrackUp(), moveTrackDown(),
          swapTracks()</tt> и <tt class="METHODNAME">createNewRecord()</tt>. Они совершенно
          необходимы, чтобы сделать приложение более-менее удобным, но
          их реализация не содержит ничего нового для вас, поэтому мы
          не будем их рассматривать. Исходные тексты функций вы найдете
          на CD, сопровождающем книгу.</p>

          <p>Теперь, после того как мы рассмотрели все классы диалогов
          в приложении, можно перейти к описанию нестандартного класса
          <tt class="CLASSNAME">ArtistComboBox</tt>. Как обычно, начнем
          с определения класса:</p>
          <pre class="SCREEN">class ArtistComboBox : public QComboBox 
{ 
  Q_OBJECT 
  Q_PROPERTY(int artistId READ artistId WRITE setArtistId) 
public: 
  ArtistComboBox(QSqlDatabase *database, QWidget *parent = 0, 
                 const char *name = 0); 
  void refresh(); 
  int artistId() const; 
  void setArtistId(int id); 
  
private: 
  void populate(); 
  
  QSqlDatabase *db; 
  QMap&lt;int, int&gt; idFromIndex; 
  QMap&lt;int, int&gt; indexFromId; 
};
      
</pre>Класс <tt class="CLASSNAME">ArtistComboBox</tt> порожден от
класса <tt class="CLASSNAME">QComboBox</tt>. В него добавлено свойство
<tt class="VARNAME">artistId</tt> и несколько функций.<br>
          <br>

          <p>В приватной секции объявлены две переменные-члены типа
          <tt class="CLASSNAME">QMap&lt;int, int&gt;</tt>. Первая
          отвечает за соответствие идентификатора исполнителя индексу в
          списке виджета. Вторая отвечает за соответствие индекса в
          списке -- идентификатору исполнителя.</p>
          <pre class="SCREEN">ArtistComboBox::ArtistComboBox(QSqlDatabase *database, 
                               QWidget *parent, const char *name) 
    : QComboBox(parent, name) 
{ 
  db = database; 
  populate(); 
}
      
</pre>В конструкторе вызывается функция <tt class="METHODNAME">
          populate()</tt>, которая заполняет список виджета именами и
          идентификаторами из таблицы <tt class="VARNAME">artist</tt>.
          <pre class="SCREEN">void ArtistComboBox::refresh() 
{ 
  int oldArtistId = artistId(); 
  clear(); 
  idFromIndex.clear(); 
  indexFromId.clear(); 
  populate(); 
  setArtistId(oldArtistId); 
}
      
</pre>Функция <tt class="METHODNAME">refresh()</tt> очищает и повторно
заполняет список виджета самыми свежими данными из базы. При этом,
после обновления списка выбранным остается тот же исполнитель, который
был выбран до обновления.
          <pre class="SCREEN">void ArtistComboBox::populate() 
{ 
  QSqlCursor cursor("artist", true, db); 
  cursor.select(cursor.index("name")); 
  
  int index = 0; 
  while (cursor.next()) { 
    int id = cursor.value("id").toInt(); 
    insertItem(cursor.value("name").toString(), index); 
    idFromIndex[index] = id; 
    indexFromId[id] = index; 
    ++index; 
  } 
}
      
</pre>Функция <tt class="METHODNAME">populate()</tt> переносит список
исполнителей из базы данных в список виджета, попутно обновляя словари
<tt class="VARNAME">idFromIndex</tt> и <tt class="VARNAME">indexFromId</tt>.
          <pre class="SCREEN">int ArtistComboBox::artistId() const 
{ 
  return idFromIndex[currentItem()]; 
}
      
</pre>Функция <tt class="METHODNAME">artistId()</tt> возвращает
идентификатор текущего исполнителя.
          <pre class="SCREEN">void ArtistComboBox::setArtistId(int id) 
{ 
  if (indexFromId.contains(id)) 
    setCurrentItem(indexFromId[id]); 
}
      
</pre>Функция <tt class="METHODNAME">setArtistId()</tt> делает текущим
исполнителя с заданным идентификатором.<br>
          <br>

          <p>В приложении, часто использующем виджет выпадающего
          списка, который предназначен для отображения внешнего ключа,
          вероятно было бы более удобным создать универсальный
          <tt class="CLASSNAME">DatabaseComboBox</tt>, в конструктор
          которого можно было бы передать имя таблицы, имя поля,
          которое должно отображаться в списке и имя поля, которое
          должно использоваться в качестве идентификатора.</p>

          <p>Закончим обзор приложения "CD Collection"
          рассмотрением реализации функций <tt class="METHODNAME">createConnections()</tt> и <tt class="METHODNAME">main()</tt>.</p>
          <pre class="SCREEN">inline bool createOneConnection(const QString &amp;name) 
{ 
  QSqlDatabase *db; 
  if (name.isEmpty()) 
    db = QSqlDatabase::addDatabase("QSQLITEX"); 
  else 
    db = QSqlDatabase::addDatabase("QSQLITEX", name); 
  db-&gt;setDatabaseName("cdcollection.dat"); 
  if (!db-&gt;open()) { 
    db-&gt;lastError().showMessage(); 
    return false; 
  } 
  return true; 
}

inline bool createConnections() 
{ 
  return createOneConnection("") 
          &amp;&amp; createOneConnection("ARTIST") 
          &amp;&amp; createOneConnection("CD"); 
}
      
</pre>Функция <tt class="METHODNAME">createConnections()</tt> создает
три идентичных соединения с базой данных. Первое соединение создается
безымянным, оно будет использоваться по-умолчанию, когда имя соединения
не задано явно. Два других соединения создаются с именами
"ARTIST" и "CD" -- они используются диалогами
<tt class="CLASSNAME">ArtistForm</tt> и <tt class="CLASSNAME">
          CdForm</tt>, соответственно.
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  if (!createConnections()) 
    return 1; 
  
  MainForm mainForm; 
  app.setMainWidget(&amp;mainForm); 
  mainForm.resize(480, 320); 
  mainForm.show(); 
  return app.exec(); 
}
      
</pre>Функция <tt class="METHODNAME">main()</tt> практически ничем не
отличается от аналогичных функций, которые мы до сих пор видели, за
одним маленьким исключением -- она вызывает <tt class="METHODNAME">
          createConnections()</tt>.<br>
          <br>

          <p>Как мы уже говорили в конце предыдущего раздела,
          приложение можно было бы несколько улучшить, если показывать
          длительность звучания дорожки не в секундах, а в минутах и
          секундах. Но, кроме перекрытия метода <tt class="METHODNAME">QSqlCursor::calculateField()</tt>, это повлекло
          бы за собой еще и создание класса -- редактора времени
          звучания дорожки, производного от <tt class="CLASSNAME">QSqlEditorFactory</tt>. А затем необходимо было
          бы с помощью <tt class="CLASSNAME">QSqlPropertyMap</tt>
          сообщить <tt class="CLASSNAME">QDataTable</tt> о том, как
          получить измененное значение от класса-редактора. За
          дополнительной информацией обращайтесь к сопроводительной
          документации по функциям <tt class="METHODNAME">installEditorFactory()</tt> и <tt class="METHODNAME">installPropertyMap()</tt>, класса <tt class="CLASSNAME">QDataTable</tt>.</p>

          <p>Еще одно из возможных улучшений приложения -- добавить
          возможность хранения в базе данных изображения обложки диска
          и отображения его в <tt class="CLASSNAME">CdForm</tt>.
          Реализовать это можно за счет добавления в базу данных поля
          типа <tt class="CLASSNAME">BLOB</tt>, в котором можно хранить
          изображения. Получать изображения из базы данных можно в виде
          <tt class="CLASSNAME">QByteArray</tt> и затем передавать их в
          конструктор <tt class="CLASSNAME">QImage</tt>.</p>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER13"></a>Глава 13. Работа с сетью.</h1>

        <p>Для работы с протоколами FTP и HTTP в библиотеке Qt имеются
        классы <tt class="CLASSNAME">QFtp</tt> и <tt class="CLASSNAME">QHttp</tt>. Они достаточно удобны для организации
        обмена файлами по сети.</p>

        <p>Классы <tt class="CLASSNAME">QFtp</tt> и <tt class="CLASSNAME">QHttp</tt> основаны на низкоуровневом классе
        <tt class="CLASSNAME">QSocket</tt>, который реализует
        представление сокетов TCP. Протокол TCP работает в терминах
        потоков данных, передаваемых между узлами сети. Класс
        <tt class="CLASSNAME">QSocket</tt>, в свою очередь, реализован
        поверх <tt class="CLASSNAME">QSocketDevice</tt> -- тонкой
        "обертки" вокруг платформо-зависимого сетевого API
        операционной системы. Класс <tt class="CLASSNAME">QSocketDevice</tt> поддерживает протоколы TCP и
        UDP.</p>

        <p>В этой главе мы будем говорить об этих 4-х, и некоторых
        других классах, и покажем -- как с ними работать. Расскажем,
        как организовать обмен файлами по сети. Протокол TCP будет
        использоваться нами при написании приложений-серверов и
        соответствующих им приложений-клиентов. Аналогично, протокол
        UDP будет использоваться для написания передающей и принимающей
        части приложений. Понимание принципов работы классов <tt class="CLASSNAME">QFtp</tt> и <tt class="CLASSNAME">QHttp</tt> обычно
        ни у кого не вызывает затруднений, даже у новичков, однако, для
        понимания принципов работы с классами <tt class="CLASSNAME">QSocket</tt> и <tt class="CLASSNAME">QSocketDevice</tt>, желательно иметь некоторый опыт
        работы с сетями.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="USINGQFTP"></a>13.1. Класс
          QFtp.</h1>

          <p>Класс <tt class="CLASSNAME">QFtp</tt> предназначен для
          создания клиентских приложений, работающих с протоколом FTP.
          Он реализует набор функций, для выполнения наиболее
          распространенных операций этого протокола, включая <tt class="METHODNAME">get(), put(), remove()</tt> и <tt class="METHODNAME">mkdir()</tt>.</p>

          <p>Все операции выполняются асинхронно. Когда вызывается
          функция, такая как <tt class="METHODNAME">get()</tt> или
          <tt class="METHODNAME">put()</tt>, управление сразу же
          возвращается программе, а собственно передача данных начинает
          производиться, когда управление опять переходит в цикл
          обработки событий Qt. Благодаря этому, во время исполнения
          FTP-команд, не возникает эффекта "замораживания"
          интерфейса с пользователем.</p>

          <p>Демонстрацию возсможностей <tt class="CLASSNAME">QFtp</tt>
          начнем с показа того, как скачать файл с сервера, используя
          функцию <tt class="METHODNAME">get()</tt>. Предположим, что
          основной класс приложения <tt class="CLASSNAME">MainWindow</tt> должен скачать прейскурант с
          FTP-сайта. <a name="P284"></a></p>
          <pre class="SCREEN">class MainWindow : public QMainWindow 
{ 
  Q_OBJECT 
public: 
  MainWindow(QWidget *parent = 0, const char *name = 0); 
  
  void getPriceList(); 
  ... 

private slots: 
  void ftpDone(bool error); 
  
private: 
  QFtp ftp; 
  QFile file; 
  ... 
};
      
</pre>Класс определяет публичную функцию <tt class="METHODNAME">
          getPriceList()</tt>, которая отвечает за получение файла с
          прейскурантом, и приватный слот <tt class="METHODNAME">ftpDone(bool)</tt>, который вызывается по
          окончании приема файла. Так же в классе определены две
          переменные: <tt class="VARNAME">ftp</tt>, ответственную за
          взаимодействие с FTP-сервером, и <tt class="VARNAME">file</tt>, используемую для записи файла на диск.
          <pre class="SCREEN">MainWindow::MainWindow(QWidget *parent, const char *name) 
    : QMainWindow(parent, name) 
{ 
  ... 
  connect(&amp;ftp, SIGNAL(done(bool)), this, SLOT(ftpDone(bool))); 
}
      
</pre>В конструкторе выполняется соединение между сигналом
          <tt class="METHODNAME">done(bool)</tt>, экземпляра класса
          <tt class="CLASSNAME">QFtp</tt>, и слотом <tt class="METHODNAME">ftpDone(bool)</tt>. Объекты класса <tt class="CLASSNAME">QFtp</tt> выдают этот сигнал по завершении
          обработки всех запросов. Параметр <tt class="VARNAME">bool</tt> указывает на наличие возможных ошибок.
          <pre class="SCREEN">void MainWindow::getPriceList() 
{ 
  file.setName("price-list.csv"); 
  if (!file.open(IO_WriteOnly)) { 
    QMessageBox::warning(this, tr("Sales Pro"), 
                         tr("Cannot write file %1\n%2.") 
                         .arg(file.name()) 
                         .arg(file.errorString())); 
    return; 
  } 
  
  ftp.connectToHost("ftp.trolltech.com"); 
  ftp.login(); 
  ftp.cd("/topsecret/csv"); 
  ftp.get("price-list.csv", &amp;file); 
  ftp.close(); 
}
      
</pre>Функция <tt class="METHODNAME">getPriceList()</tt> загружает файл
<tt class="FILENAME">ftp://ftp.trolltech.com/topsecret/csv/price-list.csv</tt> и
сохраняет его под именем <tt class="FILENAME">price-list.csv</tt> в
текущем каталоге.<br>
          <br>

          <p>Начинается функция с попытки открыть на запись файл в
          текущем каталоге. Затем выполняется последовательность из
          пяти FTP-команд. Второй аргумент функции <tt class="METHODNAME">get()</tt> задает устройство, в которое будет
          осуществляться запись принимаемых данных.</p>

          <p>Команды FTP ставятся в очередь и исполняются в цикле
          обработки событий Qt. По завершении обработки всех команд,
          объект <tt class="CLASSNAME">QFtp</tt> выдает сигнал
          <tt class="METHODNAME">done(bool)</tt>, который подключен к
          слоту <tt class="METHODNAME">ftpDone(bool)</tt>.</p>
          <pre class="SCREEN">void MainWindow::ftpDone(bool error) 
{ 
  if (error) 
    QMessageBox::warning(this, tr("Sales Pro"), 
                         tr("Error while retrieving file with " "FTP: %1.") 
                         .arg(ftp.errorString())); 
  file.close(); 
}
      
</pre>После выполнения FTP-команд, файл закрывается. Если возникла
какая либо ошибка, перед пользователем выводится соответствующее
сообщение.<br>
          <br>

          <p>Класс <tt class="CLASSNAME">QFtp</tt> предоставляет
          следующие операции: <tt class="METHODNAME">connectToHost(),
          login(), close(), list(), cd(), get(), put(), remove(),
          mkdir(), rmdir()</tt> и <tt class="METHODNAME">rename()</tt>.
          Все эти функции ставят соответствующие команды в очередь и
          возвращают идентификационный номер команды. Любые команды FTP
          могут быть испольнены с помощью функции <tt class="METHODNAME">rawCommand()</tt>. Например, так выглядит
          исполнение команды <tt class="METHODNAME">SITE
          CHMOD</tt>:</p>
          <pre class="SCREEN">    ftp.rawCommand("SITE CHMOD 755 fortune");
      
</pre>Объекты <tt class="CLASSNAME">QFtp</tt>, перед исполнением
команды, выдают сигнал <tt class="METHODNAME">commandStarted(int)</tt>,
а по завершении -- <tt class="METHODNAME">commandFinished(int,
bool)</tt>. Аргумент <tt class="CLASSNAME">int</tt> -- это
идентификационный номер команды. Если вас интересует ход выполнения
отдельных команд, то вам придется сохранять их идентификационные
номера, при вызове соответствующей функции. Благодаря этому появится
возможность предоставить пользователю более детальную информацию о ходе
процесса. Например:
          <pre class="SCREEN">void MainWindow::getPriceList() 
{ 
  ... 
  connectId = ftp.connectToHost("ftp.trolltech.com"); 
  loginId = ftp.login(); 
  cdId = ftp.cd("/topsecret/csv"); 
  getId = ftp.get("price-list.csv", &amp;file); 
  closeId = ftp.close(); 
} 

void MainWindow::commandStarted(int id) 
{ 
  if (id == connectId) { 
    statusBar()-&gt;message(tr("Connecting..."));
  } else if (id == loginId) { 
    statusBar()-&gt;message(tr("Logging in...")); 
  ... 
}
      
</pre>Другой способ обеспечения пользователя обратной связью с
процессом -- использовать сигнал <tt class="METHODNAME">stateChanged()</tt>.<br>
          <br>

          <p>Однако, в большинстве приложений нас интересует только
          результат выполнения всей последовательности команд. В этом
          случае мы просто соединяемся с сигналом <tt class="METHODNAME">done(bool)</tt>, который выдается послк
          выполнения последней команды в последовательности.</p>

          <p>При возникновении ошибки, <tt class="CLASSNAME">QFtp</tt>
          автоматически очищает очередь команд. Это означает, что если
          ошибка произошла во время установления соединения или во
          время авторизации на сервере, следующие за ними команды
          никогда не будут выполнены. Но если после возникновения
          ошибки в очередь будут поставлены другие команды, то они
          будут исполнены как ни в чем не бывало.</p>

          <p>Теперь рассмотрим более сложный пример:</p>
          <pre class="SCREEN">class Downloader : public QObject 
{ 
  Q_OBJECT 
public: 
  Downloader(const QUrl &amp;url); 
  
signals: 
  void finished(); 
  
private slots: 
  void ftpDone(bool error); 
  void listInfo(const QUrlInfo &amp;urlInfo); 
  
private: 
  QFtp ftp; 
  std::vector&lt;QFile *&gt; openedFiles; 
};
      
</pre>Экземпляр класса <tt class="CLASSNAME">Downloader</tt> попытается
скачать все файлы из каталога FTP. Имя каталога задается как
          <tt class="CLASSNAME">QUrl</tt>, при вызове конструктора.
          Класс <tt class="CLASSNAME">QUrl</tt> -- это стандартный
          класс из библиотеки Qt, который реализует интерфейс для
          работы со строками URL и выделения их них отдельных частей,
          таких как имя файла, путь к файлу, протокол и порт.
          <pre class="SCREEN">Downloader::Downloader(const QUrl &amp;url) 
{ 
  if (url.protocol() != "ftp") { 
    QMessageBox::warning(0, tr("Downloader"), 
                         tr("Protocol must be  ftp .")); 
    emit finished(); 
    return; 
  } 
  
  int port = 21; 
  if (url.hasPort()) 
    port = url.port();
  
  connect(&amp;ftp, SIGNAL(done(bool)), 
          this, SLOT(ftpDone(bool))); 
  connect(&amp;ftp, SIGNAL(listInfo(const QUrlInfo &amp;)), 
          this, SLOT(listInfo(const QUrlInfo &amp;))); 
  
  ftp.connectToHost(url.host(), port); 
  ftp.login(url.user(), url.password()); 
  ftp.cd(url.path()); 
  ftp.list(); 
}
      
</pre>В конструкторе прежде всего выполняется проверка строки URL --
она должна начинаться с комбинации символов: "ftp:". Затем из
URL извлекается номер порта, если порт не указан, то предполагается
использование стандартного FTP-порта -- 21.<br>
          <br>

          <p>Затем выполняются соединения сигнал-слот и в очередь
          помещаются 4 FTP-команды. Последняя из них запрашивает у
          сервера список файлов и выдает сигнал <tt class="METHODNAME">listInfo(const QUrlInfo &amp;)</tt>, когда от
          сервера приходит очередное имя файла. Этот сигнал связан со
          слотом <tt class="METHODNAME">listInfo()</tt>, отвечающим за
          скачивание файла.</p>
          <pre class="SCREEN">void Downloader::listInfo(const QUrlInfo &amp;urlInfo) 
{ 
  if (urlInfo.isFile() &amp;&amp; urlInfo.isReadable()) { 
    QFile *file = new QFile(urlInfo.name()); 
    if (!file-&gt;open(IO_WriteOnly)) { 
      QMessageBox::warning(0, tr("Downloader"), 
                           tr("Error: Cannot open file " "%1:\n%2.") 
                           .arg(file-&gt;name()) 
                           .arg(file-&gt;errorString())); 
      emit finished(); 
      return; 
    } 
    ftp.get(urlInfo.name(), file); 
    openedFiles.push_back(file); 
  } 
}
      
</pre>Аргумент типа <tt class="VARNAME">QUrlInfo</tt> предоставляет
подробную информацию о файле. Если это обычный файл (не каталог) и
доступен на чтение, то производится попытка скачать его, вызовом
<tt class="METHODNAME">get()</tt>. Объект <tt class="CLASSNAME">
          QFile</tt> используется для сохранения локальной копии файла,
          он создается оператором <tt class="METHODNAME">new</tt>, а
          указатель на него сохраняется в динамическом массиве
          (векторе) <tt class="VARNAME">openedFiles</tt>.
          <pre class="SCREEN">void Downloader::ftpDone(bool error) 
{ 
  if (error) 
    QMessageBox::warning(0, tr("Downloader"), 
                         tr("Error: %1.") 
                         .arg(ftp.errorString())); 
  
  for (int i = 0; i &lt; (int)openedFiles.size(); ++i) 
    delete openedFiles[i]; 
  emit finished(); 
}
      
</pre>Слот <tt class="METHODNAME">ftpDone()</tt> вызывается по
завершении выполнения последовательности команд или в случае
возникновения ошибки. Функция удаляет все объекты <tt class="CLASSNAME">QFile</tt>, попутно закрывая все файлы. (Файлы закрываются
автоматически деструктором класса <tt class="CLASSNAME">QFile</tt>.)<br>
          <br>

          <p>Если ошибок не возникло, то порядок выполнения команд и
          выдачи сигналов будет следующим:</p>
          <pre class="SCREEN">  connectToHost(host) 
  login() 
  cd(path) 
  list() 
    emit listInfo(file_1) 
      get(file_1) 
    emit listInfo(file_2) 
      get(file_2) 
    ... 
    emit listInfo(file_N) 
      get(file_N) 
  emit done()
      
</pre>Если ошибка возникла, например, во время скачивания пятого файла
из двадцати имевшихся, то оставшиеся пятнадуать файлов не будут
скачиваться. Если вас это не устраивает, то можно попробовать выполнять
скачивание файлов по одному -- запускать команду <tt class="METHODNAME">GET</tt>, ждать появления сигнала <tt class="METHODNAME">
          done(bool)</tt> и только после этого запускать <tt class="METHODNAME">GET</tt> для очередного файла. А в функции
          <tt class="METHODNAME">listInfo()</tt> -- просто создавать
          список имен файлов в каталоге сервера. В этом случае порядок
          выполнения команд и выдачи сигналов будет следующим:
          <pre class="SCREEN">  connectToHost(host) 
  login() 
  cd(path) 
  list() 
    emit listInfo(file_1) 
    emit listInfo(file_2) 
    ... 
    emit listInfo(file_N) 
  emit done() 
  get(file_1) 
    emit done() 
  get(file_2) 
    emit done() 
  ... 
  get(file_N) 
    emit done()
      
</pre>Другой вариант решения проблемы состоит в использовании
отдельного объекта <tt class="CLASSNAME">QFtp</tt> для каждого из
файлов. Это позволит выполнять параллельную загрузку нескольких файлов
через различные FTP-соединения.
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv);
  
  QUrl url("ftp://ftp.example.com/"); 
  if (argc &gt;= 2) 
    url = argv[1]; 
  Downloader downloader(url); 
  QObject::connect(&amp;downloader, SIGNAL(finished()), 
                   &amp;app, SLOT(quit())); 
  return app.exec(); 
}
      
</pre>Реализацией функции <tt class="METHODNAME">main()</tt> мы
завершаем рассмотрение программы. Если пользователь указывает URL в
командной строке, то файлы скачиваются из указанного каталога, в
противном случае -- из каталога <tt class="FILENAME">ftp://ftp.example.com/</tt>.<br>
          <br>

          <p>В обоих вышеприведенных примерах, файл скачивается с
          помощью функции <tt class="METHODNAME">get()</tt> и
          записывается на диск посредством объекта <tt class="CLASSNAME">QFile</tt>. В случае же, если принятый файл нужно
          сохранить в памяти, то для этого прекрасно подойдет класс
          <tt class="CLASSNAME">QBuffer</tt>, производный от класса
          <tt class="CLASSNAME">QIODevice</tt> -- обертки вокруг класса
          <tt class="CLASSNAME">QByteArray</tt>. Например:</p>
          <pre class="SCREEN">  QBuffer *buffer = new QBuffer(byteArray); 
  buffer-&gt;open(IO_WriteOnly); 
  ftp.get(urlInfo.name(), buffer);
      
</pre>В функции <tt class="METHODNAME">get()</tt> мы могли бы опустить
второй аргумент или передать в место него "пустой" (NULL)
указатель. В этом случае <tt class="CLASSNAME">QFtp</tt> будет выдавать
сигнал <tt class="METHODNAME">readyRead()</tt> всякий раз, при
поступлении очередной порции данных, которые могут быть прочитаны
вызовом <tt class="METHODNAME">readBlock()</tt> или
          <tt class="METHODNAME">readAll()</tt>.<br>
          <br>

          <p>Если необходимо отображать ход выполнения скачивания
          файла, то можно связать сигнал <tt class="METHODNAME">dataTransferProgress(int, int)</tt>, класса
          <tt class="CLASSNAME">QFtp</tt>, со слотом <tt class="METHODNAME">setProgress(int, int)</tt> класса <tt class="CLASSNAME">QProgressBar</tt> или <tt class="CLASSNAME">QProgressDialog</tt>. Кроме того, можно привязать
          сигнал <tt class="METHODNAME">canceled()</tt>, класса
          <tt class="CLASSNAME">QProgressBar</tt> или <tt class="CLASSNAME">QProgressDialog</tt> со слотом <tt class="METHODNAME">abort()</tt>, класса <tt class="CLASSNAME">QFtp</tt>.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="USINGQHTTP"></a>13.2. Класс
          QHttp.</h1>

          <p>Класс <tt class="CLASSNAME">QHttp</tt> предназначен для
          создания клиентских приложений, работающих с протоколом HTTP.
          Он реализует набор функций, для выполнения наиболее
          распространенных операций этого протокола, включая <tt class="METHODNAME">get()</tt> и <tt class="METHODNAME">post()</tt>.
          Если вы прочитали предыдущий раздел, то обнаружите, что класс
          <tt class="CLASSNAME">QHttp</tt> очень похож на <tt class="CLASSNAME">QFtp</tt>.</p>

          <p>Как и <tt class="CLASSNAME">QFtp</tt>, объекты класса
          <tt class="CLASSNAME">QHttp</tt> работают асинхронно. Функции
          <tt class="METHODNAME">get()</tt> и <tt class="METHODNAME">post()</tt> сразу же возвращают управление
          вызывающей программе, а собственно передача данных
          осуществляется в цикле обработки событий.</p>

          <p>Рассмотрим принцип действия <tt class="METHODNAME">QHttp</tt> на примере приложения, которое
          пытается получить HTML-файл с сайта Trolltech. Мы не будем
          здесь приводить содержимое заголовочного файла, т.к. он очень
          похож на <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P284">тот</a>, который использовался в
          предыдущем разделе. Различие состоит лишь в том, что теперь
          приватный слот объявлен под именем <tt class="METHODNAME">httpDone(bool)</tt> и изменено объявление одной
          приватной переменной (<tt class="VARNAME">http</tt> типа
          <tt class="CLASSNAME">QHttp</tt>).</p>
          <pre class="SCREEN">MainWindow::MainWindow(QWidget *parent, const char *name) 
    : QMainWindow(parent, name) 
{ 
  ...
  connect(&amp;http, SIGNAL(done(bool)), this, SLOT(httpDone(bool))); 
}
      
</pre>В конструкторе выполняется соединение сигнала
          <tt class="METHODNAME">done(bool)</tt>, объекта <tt class="CLASSNAME">QHttp</tt>, со слотом главного окна -- <tt class="METHODNAME">httpDone(bool)</tt>.
          <pre class="SCREEN">void MainWindow::getFile() 
{ 
  file.setName("aboutqt.html"); 
  if (!file.open(IO_WriteOnly)) { 
    QMessageBox::warning(this, tr("HTTP Get"), 
                         tr("Cannot write file %1\n%2.") 
                         .arg(file.name()) 
                         .arg(file.errorString())); 
    return; 
  } 
  
  http.setHost("doc.trolltech.com"); 
  http.get("/3.2/aboutqt.html", &amp;file); 
  http.closeConnection(); 
}
      
</pre>Функция <tt class="METHODNAME">getFile()</tt> загружает файл
<tt class="FILENAME">http://doc.trolltech.com/3.2/aboutqt.html</tt> и
сохраняет его в текущем каталоге, под именем <tt class="FILENAME">
          aboutqt.html</tt>.<br>
          <br>

          <p>Объект <tt class="CLASSNAME">QFile</tt> пытается открыть
          файл на запись, после этого в очередь помещается
          последовательность из трех HTTP-команд. Второй аргумент
          функции <tt class="METHODNAME">get()</tt> определяет
          устройство, куда будут записаны полученные данные.</p>

          <p>HTTP-запросы исполняются в цикле обработки событий. По
          завершении заданной последовательности команд, объект
          <tt class="CLASSNAME">Qhttp</tt> выдает сигнал <tt class="METHODNAME">done(bool)</tt>, который поступает в слот
          <tt class="METHODNAME">httpDone(bool)</tt>.</p>
          <pre class="SCREEN">void MainWindow::httpDone(bool error) 
{ 
  if (error) 
    QMessageBox::warning(this, tr("HTTP Get"), 
                         tr("Error while fetching file with " 
                           "HTTP: %1.") 
                         .arg(http.errorString())); 
  file.close(); 
}
      
</pre>После того, как запрос будет выполнен, файл закрывается. При
возникновении ошибки перед пользователем выводится соответствующее
сообщение.<br>
          <br>

          <p>Среди всего прочего, <tt class="CLASSNAME">QHttp</tt>
          предоставляет в распоряжение программиста следующие функции:
          <tt class="METHODNAME">setHost(), get(), post()</tt> и
          <tt class="METHODNAME">head()</tt>. Ниже приводится пример
          передачи списка пар <span class="emphasis"><em class="EMPHASIS">"имя = значение"</em></span> в
          CGI-скрипт:</p>
          <pre class="SCREEN">    http.setHost("www.example.com"); 
    http.post("/cgi/somescript.py", QCString("x=200&amp;y=320"), &amp;file);
      
</pre>Для выполнения произвольных HTTP-запросов можно использовать
более универсальную функцию <tt class="METHODNAME">request()</tt>,
например:
          <pre class="SCREEN">  QHttpRequestHeader header("POST", "/search.html"); 
  header.setValue("Host", "www.trolltech.com"); 
  header.setContentType("application/x-www-form-urlencoded"); 
  http.setHost("www.trolltech.com"); 
  http.request(header, QCString("qt-interest=on&amp;search=opengl"));
      
</pre>Перед началом выполнения очередной операции, <tt class="CLASSNAME">QHttp</tt> выдает сигнал <tt class="METHODNAME">requestStarted(int)</tt>, а после окончания --
          <tt class="METHODNAME">requestFinished(int, bool)</tt>.
          Аргумент <tt class="VARNAME">int</tt> определяет
          идентификационный номер запроса. Если вас интересует ход
          выполнения отдельных команд, то вам придется сохранять их
          идентификационные номера, при вызове соответствующей функции.
          Благодаря этому появится возможность предоставить
          пользователю более детальную информацию о ходе процесса.<br>
          <br>

          <p>Однако, в большинстве приложений нас интересует только
          результат выполнения всей последовательности команд. В этом
          случае мы просто соединяемся с сигналом <tt class="METHODNAME">done(bool)</tt>, который выдается после
          выполнения последней команды в последовательности.</p>

          <p>При возникновении ошибки, очередь команд автоматически
          очищается. Это означает, что все последующие команды никогда
          не будут выполнены. Но если в очередь будут поставлены другие
          команды уже после возникновения ошибки, то они будут
          исполнены как ни в чем не бывало.</p>

          <p>Подобно <tt class="CLASSNAME">QFtp</tt>, объекты класса
          <tt class="CLASSNAME">QHttp</tt> имеют в своем распоряжении
          сигнал <tt class="METHODNAME">readyRead()</tt>, и функции
          <tt class="METHODNAME">readBlock()</tt> и <tt class="METHODNAME">readAll()</tt>, которые могут использоваться в
          том случае, когда функции <tt class="METHODNAME">get()</tt>
          не передается устройство для записи. Кроме того, этот класс
          так же имет сигнал <tt class="METHODNAME">dataTransferProgress(int, int)</tt>, который
          может быть напрвлен в слот <tt class="METHODNAME">setProgress(int, int)</tt> класса <tt class="CLASSNAME">QProgressBar</tt> или <tt class="CLASSNAME">QProgressDialog</tt>.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="TCPNETWORKINGWITHQSOCKET"></a>13.3. Класс QSocket.</h1>

          <p>Класс <tt class="CLASSNAME">QSocket</tt> может
          использоваться при разработке приложений серверов и клиентов,
          работающих по протоколу TCP. TCP -- это протокол
          транспортного уровня, который является базой для множества
          других протоколов Интернет, включая FTP и HTTP, а так же
          может служить основой для разработки нестандартных протоколов
          обмена данными.</p>

          <p>Протокол TCP ориентирован на потоки. Протоколы более
          высокого уровня, работающие поверх TCP, обычно подразделяются
          на строко-ориентированные и блочно-ориентированные:</p>

          <ul>
            <li>
              <p>Строко-ориентированные протоколы передают данные в
              виде текстовых строк, каждая из которых завершается
              символом перевода строки.</p>
            </li>

            <li>
              <p>Блочно-ориентированные протоколы передают данные в
              виде блоков. Размер каждого блока содержится в отдельном
              поле, внутри блока.</p>
            </li>
          </ul>Класс <tt class="CLASSNAME">QSocket</tt> порожден от
          класса <tt class="CLASSNAME">QIODevice</tt>, поэтому он в
          состоянии читать и писать данные из/в экземпляры классов
          <tt class="CLASSNAME">QDataStream</tt> или <tt class="CLASSNAME">QTextStream</tt>. Одно важное отличие чтения
          данных из сети от чтения данных из файла состои в том, что
          перед вызовом оператора "&gt;&gt;" необходимо
          убедиться в том, что от удаленного хоста получены все данные.
          В случае ошибки мы можем получить непредсказуемый
          результат.<br>
          <br>

          <p>В этом разделе мы рассмотрим исходный код клиентского и
          серверного приложений, которые используют собственный,
          блочно-ориентированный протокол обмена. Приложение-клиент
          называется Trip Planner. Оно позволяет пользователю
          планировать поездку по железной дороге. Приложение-сервер
          называется Trip Server. Оно предоставляет клиенту информацию
          о расписании движения поездов. Начнем с приложения Trip
          Planner.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig13.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 13.1. Внешний вид приложения Trip Planner.</p>
            </div>
          </div><br>
          На форме приложения находятся поля ввода <strong class="COMMAND">From</strong> (Из), <strong class="COMMAND">To</strong> (В), <strong class="COMMAND">Date</strong> (Дата), <strong class="COMMAND">Approximate Time</strong> (Примерное время) и две
          кнопки с зависимой фиксацией (radio buttons), которые
          уточняют смысл поля <strong class="COMMAND">pproximate
          Time</strong> -- время отправления или время прибытия. Когда
          пользователь нажимает кнопку <strong class="COMMAND">Search</strong>, приложение передает запрос серверу
          и получает список поездов, которые отвечают заданным
          критериям. Этот список отображается в виджете <tt class="CLASSNAME">QListView</tt>. В самом низу формы находятся
          <tt class="CLASSNAME">QLabel</tt>, для отображения
          результатов выполнения последнего запроса, и <tt class="CLASSNAME">QProgressBar</tt>.<br>
          <br>

          <p>Пользовательский интерфейс приложения был разработан в
          среде визуального построителя <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>.
          Поэтому, все свое внимание мы сконцентрируем на содержимом
          файла <tt class="FILENAME">.ui.h</tt>. Обратите внимание:
          следующие четыре переменные-члены были объявлены на вкладке
          <span class="emphasis"><em class="EMPHASIS">Members</em></span>, в построителе <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>,
          как:</p>
          <pre class="SCREEN">    QSocket socket; 
    QTimer connectionTimer; 
    QTimer progressBarTimer; 
    Q_UINT16 blockSize;
      
</pre>Переменная <tt class="VARNAME">socket</tt> отвечает за работу с
TCP-соединением. Переменная <tt class="VARNAME">connectionTimer</tt>
используется для отслеживания тайм аута соединения. Переменная
<tt class="VARNAME">progressBarTimer</tt> предназначена для
периодического обновления индикатора хода выполнения запроса. И наконец
переменная <tt class="VARNAME">blockSize</tt> используется при анализе
блока данных, полученных от сервера.
          <pre class="SCREEN">void TripPlanner::init() 
{ 
  connect(&amp;socket, SIGNAL(connected()), 
          this, SLOT(sendRequest())); 
  connect(&amp;socket, SIGNAL(connectionClosed()), 
          this, SLOT(connectionClosedByServer())); 
  connect(&amp;socket, SIGNAL(readyRead()), 
          this, SLOT(updateListView()));
  connect(&amp;socket, SIGNAL(error(int)), 
          this, SLOT(error(int))); 
  connect(&amp;connectionTimer, SIGNAL(timeout()), 
          this, SLOT(connectionTimeout())); 
  connect(&amp;progressBarTimer, SIGNAL(timeout()), 
          this, SLOT(advanceProgressBar())); 
  
  QDateTime dateTime = QDateTime::currentDateTime(); 
  dateEdit-&gt;setDate(dateTime.date()); 
  timeEdit-&gt;setTime(QTime(dateTime.time().hour(), 0)); 
}
      
</pre>Функция <tt class="METHODNAME">init()</tt> связывает сигналы
объекта <tt class="CLASSNAME">QSocket</tt> -- <tt class="METHODNAME">
          connected(), connectionClosed(), readyRead()</tt> и
          <tt class="METHODNAME">error(int)</tt>, и сигналы <tt class="METHODNAME">timeout()</tt> от таймеров, с соответствующими
          слотами. Поля ввода <strong class="COMMAND">Date</strong> и
          <strong class="COMMAND">Approximate Time</strong> заполняются
          значениями по-умолчанию -- текущими датой и временем.
          <pre class="SCREEN">void TripPlanner::advanceProgressBar() 
{ 
  progressBar-&gt;setProgress(progressBar-&gt;progress() + 2); 
}
      
</pre>Слот <tt class="METHODNAME">advanceProgressBar()</tt> связан с
сигналом <tt class="METHODNAME">timeout()</tt>, объекта
          <tt class="CLASSNAME">progressBarTimer</tt>.
          <pre class="SCREEN">void TripPlanner::connectToServer() 
{ 
  listView-&gt;clear(); 
  
  socket.connectToHost("tripserver.zugbahn.de", 6178); 
  
  searchButton-&gt;setEnabled(false); 
  stopButton-&gt;setEnabled(true); 
  statusLabel-&gt;setText(tr("Connecting to server...")); 
  connectionTimer.start(30 * 1000, true); 
  progressBarTimer.start(200, false); 
  blockSize = 0; 
}
      
</pre>Слот <tt class="METHODNAME">connectToServer()</tt> вызывается по
нажатию на кнопку <strong class="COMMAND">Search</strong>. Функция
вызывает <tt class="METHODNAME">connectToHost()</tt> для установления
соединения с мифическим сервером tripserver.zugbahn.de, который ожидает
поступления запросов на порту с номером 6178. (Если вы планируете
опробовать пример на своей машине, замените имя удаленного сервера на
localhost.) Функция <tt class="METHODNAME">connectToHost()</tt>
работает асинхронно -- она всегда сразу же возвращает управление
вызывающей программе. Само соединение устанавливается немного позже, в
этот момент <tt class="CLASSNAME">QSocket</tt> выдает сигнал
          <tt class="METHODNAME">connected()</tt>. В случае
          возникновении ошибки, выдается сигнал <tt class="METHODNAME">error(int)</tt> (с кодом ошибки).<br>
          <br>

          <p>После этого обновляется интерфейсная часть приложения и
          запускаются два таймера. Первый из них, <tt class="VARNAME">connectionTimer</tt> -- это таймер с однократным
          срабатыванием. Он выдает сигнал <tt class="METHODNAME">timeout()</tt> через 30 секунд после запуска.
          Второй таймер, <tt class="VARNAME">progressBarTimer</tt>,
          отрабатывает через каждые 200 миллисекунд. С его помощью
          выполняется обновление индикатора хода процесса.</p>

          <p>И в заключении в переменную <tt class="VARNAME">blockSize</tt> записывается значение 0. Она хранит
          размер очередного блока данных, принятого от сервера.
          <a name="P294"></a></p>
          <pre class="SCREEN">void TripPlanner::sendRequest() 
{ 
  QByteArray block; 
  QDataStream out(block, IO_WriteOnly); 
  out.setVersion(5); 
  out &lt;&lt; (Q_UINT16)0 &lt;&lt; (Q_UINT8)'S'
      &lt;&lt; fromComboBox-&gt;currentText() 
      &lt;&lt; toComboBox-&gt;currentText() 
      &lt;&lt; dateEdit-&gt;date() 
      &lt;&lt; timeEdit-&gt;time(); 
  if (departureRadioButton-&gt;isOn()) 
    out &lt;&lt; (Q_UINT8)'D'; 
  else 
    out &lt;&lt; (Q_UINT8)'A'; 
  out.device()-&gt;at(0); 
  out &lt;&lt; (Q_UINT16)(block.size() - sizeof(Q_UINT16)); 
  socket.writeBlock(block.data(), block.size()); 
  
  statusLabel-&gt;setText(tr("Sending request...")); 
}
      
</pre>Слот <tt class="METHODNAME">sendRequest()</tt> связан с сигнвлом
<tt class="METHODNAME">connected()</tt>, объекта <tt class="CLASSNAME">
          QSocket</tt>. При появлении сигнала, слот генерирует запрос
          серверу, передавая информацию, введенную пользователем.<br>
          <br>

          <p>Блок запроса имеет следующую структуру:</p>

          <div class="INFORMALTABLE">
            <a name="AEN6397"></a>

            <table border="1" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="200" align="left" valign="top">Q_UINT16</td>

                  <td width="400" align="left" valign="top">Размер блока в байтах (исключая это
                      поле)</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">Q_UINT8</td>

                  <td width="400" align="left" valign="top">Тип запроса (всегда
                      'S')</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">QString</td>

                  <td width="400" align="left" valign="top">Пункт отправления</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">QString</td>

                  <td width="400" align="left" valign="top">Пункт прибытия</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">QDate</td>

                  <td width="400" align="left" valign="top">Дата</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">QTime</td>

                  <td width="400" align="left" valign="top">Примерное время</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">Q_UINT8</td>

                  <td width="400" align="left" valign="top">Тип поля "Примерное
                      время": 'D' -- отправление,
                      'A' -- прибытие.</td>
                </tr>
              </tbody>
            </table>
          </div>Сначала данные записываются в объект <tt class="CLASSNAME">QByteArray</tt>, который называется <tt class="VARNAME">block</tt>. Записать данные напрямую в <tt class="CLASSNAME">QSocket</tt> не представляется возможным, потому
          что размер блока заранее не известен.<br>
          <br>

          <p>Изначально, в поле <tt class="VARNAME">size</tt>
          записывается число 0. Затем, после записи в блок всех данных,
          производится переход к началу блока, вызовом функции
          <tt class="METHODNAME">at(0)</tt> и записывается корректное
          значение размера передаваемого блока данных. После этого блок
          передается серверу, вызовом <tt class="METHODNAME">writeBlock()</tt>.</p>
          <pre class="SCREEN">void TripPlanner::updateListView() 
{ 
  connectionTimer.start(30 * 1000, true); 
  
  QDataStream in(&amp;socket); 
  in.setVersion(5); 
  for (;;) { 
    if (blockSize == 0) { 
      if (socket.bytesAvailable() &lt; sizeof(Q_UINT16)) 
        break; 
      in &gt;&gt; blockSize; 
    } 
    
    if (blockSize == 0xFFFF) { 
      closeConnection(); 
      statusLabel-&gt;setText(tr("Found %1 trip(s)") 
                              .arg(listView-&gt;childCount())); 
      break; 
    } 
    
    if (socket.bytesAvailable() &lt; blockSize) 
      break; 
      
    QDate date; 
    QTime departureTime;
    QTime arrivalTime; 
    Q_UINT16 duration; 
    Q_UINT8 changes; 
    QString trainType; 
    
    in &gt;&gt; date &gt;&gt; departureTime &gt;&gt; duration &gt;&gt; changes 
       &gt;&gt; trainType; 
    arrivalTime = departureTime.addSecs(duration * 60); 
    
    new QListViewItem(listView, 
                      date.toString(LocalDate), 
                      departureTime.toString(tr("hh:mm")), 
                      arrivalTime.toString(tr("hh:mm")), 
                      tr("%1 hr %2 min").arg(duration / 60) 
                                        .arg(duration % 60), 
                         QString::number(changes), 
                         trainType); 
    blockSize = 0; 
  } 
}
      
</pre>Слот <tt class="METHODNAME">updateListView()</tt> реагирует на
сигнал <tt class="METHODNAME">readyRead()</tt>, объекта
          <tt class="CLASSNAME">QSocket</tt>, который выдается при
          получении новых данных от сервера. Первое, что необходимо
          сделать -- это перезапустить таймер с однократным
          срабатыванием, отслеживающий тайм аут соединения. Всякий раз,
          когда от сервера приходит очередная порция данных, необходимо
          продлить срок "жизни" соединения еще на 30
          секунд.<br>
          <br>

          <p>Сервер передает расписание движения поездов, которые
          удовлетворяют заданным критериям. Каждая строка расписания
          передается в виде отдельного блока и каждый блок начинается
          полем, содержащим размер блока. Сложность обработки данных в
          цикле <tt class="METHODNAME">for</tt> заключается в том, что
          от сервера не все данные приходят одновременно. Мы можем
          получить блок целиком, или только часть блока, или полтора
          блока, или даже все блоки сразу.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig13.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 13.2. Поток данных от Trip Server, разбитый на
              блоки.</p>
            </div>
          </div><br>
          Так как же работает цикл <tt class="METHODNAME">for</tt>?
          Если значение переменной <tt class="VARNAME">blockSize</tt>
          равно 0, это означает, что размер очередного блока еще не
          прочитан. Значение 0xFFFF используется для индикации
          окончания передачи, поэтому, прочитав это значение, можно
          быть уверенным, что новых данных больше не поступит.<br>
          <br>

          <p>Если размер блока меньше 0xFFFF, то выполняется попытка
          прочитать блок, но прежде всего проверяется -- получен ли
          блок полностью. Если это не так, то цикл прерывается. При
          поступлении новой порции данных, снова будет выдан сигнал
          <tt class="METHODNAME">readyRead()</tt> и тогда можно будет
          повторить попытку.</p>

          <p>После того как блок будет получен целиком, можно безопасно
          прочитать его оператором "&gt;&gt;", выделить
          нужную информацию и записать ее в объект класса <tt class="CLASSNAME">QListViewItem</tt>. Блок, поступающий от сервера
          имеет следующую структуру:</p>

          <div class="INFORMALTABLE">
            <a name="AEN6447"></a>

            <table border="1" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="200" align="left" valign="top">Q_UINT16</td>

                  <td width="400" align="left" valign="top">Размер блока в байтах (исключая это
                      поле)</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">QDate</td>

                  <td width="400" align="left" valign="top">Дата отправления</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">QTime</td>

                  <td width="400" align="left" valign="top">Время отправления</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">Q_UINT16</td>

                  <td width="400" align="left" valign="top">Время в пути (в минутах)</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">Q_UINT8</td>

                  <td width="400" align="left" valign="top">Количество остановок</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">QString</td>

                  <td width="400" align="left" valign="top">Тип поезда</td>
                </tr>
              </tbody>
            </table>
          </div>Завершив разбор блока данных, функция записывает
          значение 0 в переменную <tt class="VARNAME">blockSize</tt>,
          говоря о том, что размер очередного блока данных неизвестен.
          <pre class="SCREEN">void TripPlanner::closeConnection() 
{ 
  socket.close(); 
  searchButton-&gt;setEnabled(true); 
  stopButton-&gt;setEnabled(false); 
  connectionTimer.stop(); 
  progressBarTimer.stop(); 
  progressBar-&gt;setProgress(0); 
}
      
</pre>Функция <tt class="METHODNAME">closeConnection()</tt> закрывает
соединение с сервером, обновляет интерфейс с пользователем и
останавливает таймеры. Она вызывается из <tt class="METHODNAME">
          updateListView()</tt>, когда будет получен блок с размером
          0xFFFF, и из некоторых других слотов, которые будут описаны
          чуть ниже.
          <pre class="SCREEN">void TripPlanner::stopSearch() 
{ 
  statusLabel-&gt;setText(tr("Search stopped")); 
  closeConnection(); 
}
      
</pre>Слот <tt class="METHODNAME">stopSearch()</tt> реагирует на нажите
кнопки <strong class="COMMAND">Stop</strong>. Суть его состоит в
закрытии соединения вызовом функции <tt class="METHODNAME">closeConnection()</tt>.
          <pre class="SCREEN">void TripPlanner::connectionTimeout() 
{ 
  statusLabel-&gt;setText(tr("Error: Connection timed out")); 
  closeConnection(); 
}
      
</pre>Слот <tt class="METHODNAME">connectionTimeout()</tt> отрабатывает
по истечении тайм аута соединения.
          <pre class="SCREEN">void TripPlanner::connectionClosedByServer() 
{ 
  if (blockSize != 0xFFFF) 
    statusLabel-&gt;setText(tr("Error: Connection closed by " 
                            "server")); 
    closeConnection(); 
  }
      
</pre>Слот <tt class="METHODNAME">connectionClosedByServer()</tt>
реагирует на сигнал <tt class="METHODNAME">connectionClosed()</tt>,
объекта <tt class="CLASSNAME">socket</tt>. Если сервер закрыл
соединение до того, как был получен маркер конца передачи (0xFFFF),
пользователю выводится сообщение об ошибке. Затем вызывается
          <tt class="METHODNAME">closeConnection()</tt>, чтобы обновить
          интерфейс и остановить таймеры.
          <pre class="SCREEN">void TripPlanner::error(int code) 
{ 
  QString message; 
  
  switch (code) { 
    case QSocket::ErrConnectionRefused: 
        message = tr("Error: Connection refused"); 
        break; 
    case QSocket::ErrHostNotFound: 
        message = tr("Error: Server not found"); 
        break; 
    case QSocket::ErrSocketRead: 
    default: 
        message = tr("Error: Data transfer failed"); 
  } 
  statusLabel-&gt;setText(message); 
  closeConnection(); 
}
      
</pre>Слот <tt class="METHODNAME">error(int)</tt> связан с сигналом
<tt class="METHODNAME">error(int)</tt> сокета. Он генерирует текст
сообщения, соответствующий полученному коду ошибки.<br>
          <br>

          <p>Функция <tt class="METHODNAME">main()</tt> не содержит
          ничего нового:</p>
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  
  TripPlanner tripPlanner; 
  app.setMainWidget(&amp;tripPlanner); 
  tripPlanner.show(); 
  return app.exec(); 
}
      
</pre>Перейдем к реализации приложения-сервера. Сервер состоит из двух
классов: <tt class="CLASSNAME">TripServer</tt> и <tt class="CLASSNAME">
          ClientSocket</tt>. Первый порожден от <tt class="CLASSNAME">QServerSocket</tt> и предназначен для приема
          входящих соединений. Второй -- наследник <tt class="CLASSNAME">QSocket</tt> предназначен для обслуживания
          одиночного соединения с клиентом. В каждый конкретный момент
          времени, в памяти приложения будет находиться столько
          экземпляров <tt class="CLASSNAME">ClientSocket</tt>, сколько
          клиентов подключено к серверу.
          <pre class="SCREEN">class TripServer : public QServerSocket 
{ 
public: 
  TripServer(QObject *parent = 0, const char *name = 0); 
  
  void newConnection(int socket); 
};
      
</pre>В классе <tt class="CLASSNAME">TripServer</tt> перекрыт
родительский метод <tt class="METHODNAME">newConnection()</tt>. Эта
функция вызывается всякий раз, когда сервер обнаруживает попытку
соединения с ним.
          <pre class="SCREEN">TripServer::TripServer(QObject *parent, const char *name) 
    : QServerSocket(6178, 1, parent, name) 
{ 
}
      
</pre>Здесь, родительскому конструктору передается номер порта (6178).
Второй аргумент, 1, это количество подключений, ожидающих обработки.
          <pre class="SCREEN">void TripServer::newConnection(int socketId) 
{ 
  ClientSocket *socket = new ClientSocket(this); 
  socket-&gt;setSocket(socketId); 
}
      
</pre>В функции <tt class="METHODNAME">newConnection()</tt> создается
новый объект класса <tt class="CLASSNAME">ClientSocket</tt>, которому
присваивается заданный идентификационный номер.
          <pre class="SCREEN">class ClientSocket : public QSocket 
{ 
  Q_OBJECT 
public: 
  ClientSocket(QObject *parent = 0, const char *name = 0);  

private slots: 
  void readClient(); 
  
private: 
  void generateRandomTrip(const QString &amp;from, const QString &amp;to, 
                          const QDate &amp;date, const QTime &amp;time); 
  
  Q_UINT16 blockSize; 
};
      
</pre>Класс <tt class="CLASSNAME">ClientSocket</tt> порожден от класса
<tt class="CLASSNAME">QSocket</tt> и отвечает за обслуживание
одиночного соединения с клиентом.
          <pre class="SCREEN">ClientSocket::ClientSocket(QObject *parent, const char *name) 
    : QSocket(parent, name) 
{ 
  connect(this, SIGNAL(readyRead()), 
          this, SLOT(readClient())); 
  connect(this, SIGNAL(connectionClosed()), 
          this, SLOT(deleteLater())); 
  connect(this, SIGNAL(delayedCloseFinished()), 
          this, SLOT(deleteLater())); 
  blockSize = 0; 
}
      
</pre>В конструкторе устанавливаются все необходимые соединения между
сигналами и слотами, и записывается значение 0 в переменную
          <tt class="VARNAME">blockSize</tt>.<br>
          <br>

          <p>Сигналы <tt class="METHODNAME">connectionClosed()</tt> и
          <tt class="METHODNAME">delayedCloseFinished()</tt> соединены
          со слотом <tt class="METHODNAME">deleteLater()</tt>. Эта
          функция унаследована от <tt class="CLASSNAME">QObject</tt>.
          Она удаляет объект, когда управление переходит в цикл
          обработки событий. Она обеспечивает удаление экземпляров
          <tt class="CLASSNAME">ClientSocket</tt> при закрытии
          соединения.</p>
          <pre class="SCREEN">void ClientSocket::readClient() 
{ 
  QDataStream in(this); 
  in.setVersion(5); 
  
  if (blockSize == 0) { 
    if (bytesAvailable() &lt; sizeof(Q_UINT16)) 
      return; 
    in &gt;&gt; blockSize; 
  } 
  if (bytesAvailable() &lt; blockSize) 
    return; 
  
  Q_UINT8 requestType; 
  QString from; 
  QString to; 
  QDate date; 
  QTime time; 
  Q_UINT8 flag; 
  in &gt;&gt; requestType;

  if (requestType == 'S') { 
    in &gt;&gt; from &gt;&gt; to &gt;&gt; date &gt;&gt; time &gt;&gt; flag; 
    
    srand(time.hour() * 60 + time.minute()); 
    int numTrips = rand() % 8; 
    for (int i = 0; i &lt; numTrips; ++i) 
      generateRandomTrip(from, to, date, time); 
      
    QDataStream out(this); 
    out &lt;&lt; (Q_UINT16)0xFFFF; 
  } 
  close(); 
  if (state() == Idle) 
    deleteLater(); 
}
      
</pre>Слот <tt class="METHODNAME">readClient()</tt> связан с сигналом
<tt class="METHODNAME">readyRead()</tt> сокета. Если переменная
<tt class="VARNAME">blockSize</tt> содержит 0, то выполняется попытка
прочитать размер очередного блока данных, в противном случае
предполагается, что размер уже прочитан и необходимо проверить --
поступил ли блок данных полностью. Если блок данных поступил целиком,
то выполняется чтение блока. Чтение производится с помощью
          <tt class="CLASSNAME">QDataStream</tt> напрямую из сокета
          (аргумент this).<br>
          <br>

          <p>После того как блок запроса прочитан, можно приступать к
          формированию ответа. Если бы это было реальное приложение,
          все необходимые сведения можно было бы брать из базы данных.
          Но здесь мы будем довольствоваться функцией <tt class="METHODNAME">generateRandomTrip()</tt>, которая генерирует
          расписание случайным образом. Функция будет вызываться
          случайное число раз и в конце передачи будет отправляться
          маркер конца передачи (0xFFFF).</p>

          <p>В заключение -- соединение закрывается. Если выходной
          буфер сокета пуст, то соединение закрывается немедленно и
          можно вызвать <tt class="METHODNAME">deleteLater()</tt>,
          чтобы удалить сокет, когда управление попадет в цикл
          обработки событий. (Вполне безопасно было бы вызвать
          <tt class="METHODNAME">delete this</tt>.) В противном случае,
          сокет продолжит передачу данных и затем закроет соединение по
          сигналу <tt class="METHODNAME">delayedCloseFinished()</tt>.</p>
          <pre class="SCREEN">void ClientSocket::generateRandomTrip(const QString &amp;, 
        const QString &amp;, const QDate &amp;date, const QTime &amp;time) 
{ 
  QByteArray block; 
  QDataStream out(block, IO_WriteOnly); 
  out.setVersion(5); 
  Q_UINT16 duration = rand() % 200; 
  out &lt;&lt; (Q_UINT16)0 &lt;&lt; date &lt;&lt; time &lt;&lt; duration 
      &lt;&lt; (Q_UINT8)1 &lt;&lt; QString("InterCity"); 
  out.device()-&gt;at(0); 
  out &lt;&lt; (Q_UINT16)(block.size() - sizeof(Q_UINT16)); 
  
  writeBlock(block.data(), block.size()); 
}
      
</pre>Функция <tt class="METHODNAME">generateRandomTrip()</tt>
показывает, как можно отправить блок данных через TCP-соединение. Это
очень похоже на то, что мы уже видели в клиентском приложении (функция
<a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P294"><tt class="METHODNAME">sendRequest()</tt></a>). Опять
же, чтобы определить размер блока, данные сначала записываются в
<tt class="CLASSNAME">QByteArray</tt>, а затем передаются сокету
вызовом <tt class="METHODNAME">writeBlock()</tt>.
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  TripServer server; 
  if (!server.ok()) { 
    qWarning("Failed to bind to port"); 
    return 1; 
  } 
  QPushButton quitButton(QObject::tr("&amp;Quit"), 0); 
  quitButton.setCaption(QObject::tr("Trip Server")); 
  app.setMainWidget(&amp;quitButton); 
  QObject::connect(&amp;quitButton, SIGNAL(clicked()), 
                   &amp;app, SLOT(quit())); 
  quitButton.show(); 
  return app.exec(); 
}
      
</pre>В функции <tt class="METHODNAME">main()</tt> создается экземпляр
класса <tt class="CLASSNAME">TripServer</tt> и кнопка
          <tt class="CLASSNAME">QPushButton</tt>, с помощью которой
          пользователь может остановить сервер.<br>
          <br>

          <p>На этом мы завершаем рассмотрение примера построения
          клиентского и серверного приложений. В данном случае мы
          реализовали обмен по своему, блочно-ориентированному
          протоколу, что позволило нам использовать <tt class="CLASSNAME">QDataStream</tt> для чтения и записи данных. Если
          бы мы занялись реализацией строково-ориентированного
          протокола, то в самом простейшем случае мы могли бы
          воспользоваться функциями класса <tt class="CLASSNAME">QSocket</tt> -- <tt class="METHODNAME">canReadLine()</tt> и <tt class="METHODNAME">readLine()</tt>, при получении сигнала
          <tt class="METHODNAME">readyRead()</tt>:</p>
          <pre class="SCREEN">    QStringList lines; 
    while (socket.canReadLine()) 
      lines.append(socket.readLine());
      
</pre>После этого можно былобы обработать каждую прочитанную строку.
Передача текстовых строк могла бы быть выполнена с помощью
          <tt class="CLASSNAME">QTextStream</tt>, связанного с
          <tt class="CLASSNAME">QSocket</tt>.<br>
          <br>

          <p>Серверное приложение, в данной реализации, довольно плохо
          масштабируется, при наличии большого числа подключений.
          Проблема состоит в том, что когда обслуживается одно
          подключение, приложение не в состоянии обслужить другие
          соединения. Более масштабируемый подход заключается в
          создании отдельного потока для каждого соединения. Но
          экземпляры класса <tt class="CLASSNAME">QSocket</tt> могут
          использоваться только в том потоке, который содержит цикл
          обработки событий (запускаемый вызовом <tt class="METHODNAME">QApplication::exec()</tt>), по причинам, которые
          более подробно будут описаны в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER17">Главе
          17</a>. Решение проблемы заключается в использовании
          низкоуровневого класса <tt class="CLASSNAME">QSocketDevice</tt>, который работает независимо
          от цикла обработки событий.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="UDPNETWORKINGWITHQSOCKETDEVICE"></a>13.4. Протокол UDP и
          класс QSocketDevice.</h1>

          <p>Класс <tt class="CLASSNAME">QSocketDevice</tt> реализует
          низкоуровневый интерфейс для работы с протоколами UDP и TCP.
          В большинстве TCP-приложений, достаточно будет
          функциональности, заложенной в <tt class="CLASSNAME">QSocket</tt>, но если в приложении необходимо
          работать с протоколом UDP, то тогда вам придется обратить
          свой взор на класс <tt class="CLASSNAME">QSocketDevice</tt>.</p>

          <p>UDP -- это протокол с негарантированной доставкой
          сообщений, ориентированный на работу с датаграммами.
          Некоторые нестандартные протоколы работают поверх UDP,
          поскольку он не такой "тяжелый" как TCP. По
          протоколу UDP, данные передаются в виде отдельных пакетов -
          датаграмм. В этом протоколе отсутствует понятие
          "соединения", если UDP-пакет теряется где-то в
          недрах сети, то система не получит уведомления об ошибке.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig13.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 13.3. Внешний вид приложения TheWeather
              Station.</p>
            </div>
          </div><br>
          Рассмотрим принципы организации сетевых взаимодействий по
          протоколу UDP, на примере приложений Weather Balloon и
          Weather Station. Приложение Weather Balloon не имеет
          графического интерфейса. Его задача -- раз в 5 секунд
          отсылать UDP-датаграмму, которая содержит информацию о
          погодных условиях. Приложение Weather Station будет принимать
          эти датаграммы и отображать полученные сведения на экране.
          Начнем с приложения Weather Balloon.
          <pre class="SCREEN">class WeatherBalloon : public QPushButton 
{ 
  Q_OBJECT 
public: 
  WeatherBalloon(QWidget *parent = 0, const char *name = 0); 
  
  double temperature() const; 
  double humidity() const; 
  double altitude() const; 

protected: 
  void timerEvent(QTimerEvent *event); 
  
private: 
  QSocketDevice socketDevice; 
  int myTimerId; 
};
      
</pre>Класс <tt class="CLASSNAME">WeatherBalloon</tt> порожден от
<tt class="CLASSNAME">QPushButton</tt>. Для взаимодествия с Weather
Station он использует <tt class="CLASSNAME">QSocketDevice</tt>.
          <pre class="SCREEN">WeatherBalloon::WeatherBalloon(QWidget *parent, const char *name) 
    : QPushButton(tr("Quit"), parent, name), 
        socketDevice(QSocketDevice::Datagram) 
{ 
  socketDevice.setBlocking(false); 
  myTimerId = startTimer(5 * 1000); 
}
      
</pre>В списке инициализаторов конструктора, вызовом
          <tt class="METHODNAME">QSocketDevice::Datagram</tt>,
          создается устройство <tt class="CLASSNAME">QSocketDevice</tt>. В теле конструктора,
          созданное устройство переводится в асинхронный режим работы,
          вызовом <tt class="METHODNAME">setBlocking(false)</tt>.
          (По-умолчанию, <tt class="CLASSNAME">QSocketDevice</tt>
          работают в синхронном режиме.)
          <pre class="SCREEN">void WeatherBalloon::timerEvent(QTimerEvent *event) 
{ 
  if (event-&gt;timerId() == myTimerId) { 
    QByteArray datagram; 
    QDataStream out(datagram, IO_WriteOnly); 
    out.setVersion(5); 
    out &lt;&lt; QDateTime::currentDateTime() &lt;&lt; temperature() 
        &lt;&lt; humidity() &lt;&lt; altitude(); 
    socketDevice.writeBlock(datagram, datagram.size(), 
                            0x7F000001, 5824); 
  } else { 
    QPushButton::timerEvent(event); 
  } 
}
      
</pre>В обработчике событий от таймера генерируется датаграмма,
содержащая текущие дату, время, температуру воздуха, влажность и высоту
над уровнем моря:

          <div class="INFORMALTABLE">
            <a name="AEN6571"></a>

            <table border="1" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="200" align="left" valign="top">QDateTime</td>

                  <td width="400" align="left" valign="top">Дата и время измерений</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">double</td>

                  <td width="400" align="left" valign="top">Температура (в градусах
                      Цельсия)</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">double</td>

                  <td width="400" align="left" valign="top">Влажность (в %)</td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">double</td>

                  <td width="400" align="left" valign="top">Высота над уровнем моря (в
                      метрах)</td>
                </tr>
              </tbody>
            </table>
          </div>Передача датаграммы осуществляется вызовом <tt class="METHODNAME">writeBlock()</tt>. Третий и четвертый аргументы
          функции <tt class="METHODNAME">writeBlock()</tt> -- это
          IP-адрес и номер порта клиентского узла (Weather Station). В
          данном случае мы исходим из предположения, что оба приложения
          работают на одной машине, поэтому IP-адрес -- 127.0.0.1
          (0x7F000001). В отличие от <tt class="CLASSNAME">QSocket</tt>, экземпляры класса <tt class="CLASSNAME">QSocketDevice</tt> не работает с сетевыми именами
          компьютеров, ему нужны IP-адреса. Если вам необходимо
          преобразовать имя хоста в его IP-адрес, это можно сделать с
          помощью класса <tt class="CLASSNAME">QDns</tt>.
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  WeatherBalloon balloon; 
  balloon.setCaption(QObject::tr("Weather Balloon")); 
  app.setMainWidget(&amp;balloon); 
  QObject::connect(&amp;balloon, SIGNAL(clicked()), 
                   &amp;app, SLOT(quit())); 
  balloon.show(); 
  return app.exec(); 
}
      
</pre>Функция <tt class="METHODNAME">main()</tt> просто создает объект
<tt class="CLASSNAME">WeatherBalloon</tt>, который выступает в двух
ипостасях: как UDP-узел и как кнопка <tt class="CLASSNAME">QPushButton</tt> на экране.<br>
          <br>

          <p>Теперь перейдем к приложению Weather Station.</p>
          <pre class="SCREEN">class WeatherStation : public QDialog 
{ 
  Q_OBJECT 
public: 
  WeatherStation(QWidget *parent = 0, const char *name = 0); 
  
private slots: 
  void dataReceived(); 
  
private: 
  QSocketDevice socketDevice; 
  QSocketNotifier *socketNotifier; 
  
  QLabel *dateLabel; 
  QLabel *timeLabel; 
  ... 
  QLineEdit *altitudeLineEdit; 
};
      
</pre>Класс <tt class="CLASSNAME">WeatherStation</tt> порожден от
<tt class="CLASSNAME">QDialog</tt>. Его назначение -- ожидать
поступления датаграмм на определенном порту, производить разбор
поступившей информации (от Weather Balloon) и отображать ее в пяти
компонентах <tt class="CLASSNAME">QLineEdit</tt>.<br>
          <br>

          <p>Класс содержит две приватные переменные, которые
          представляют для нас наибольший интерес: <tt class="CLASSNAME">socketDevice</tt> и <tt class="CLASSNAME">socketNotifier</tt>. Первая переменная имеет тип
          <tt class="CLASSNAME">QSocketDevice</tt>. Она используется
          для приема датаграмм. Вторая переменная имеет тип <tt class="CLASSNAME">QSocketNotifier</tt>. Она используется для того,
          чтобы известить приложение о поступлении датаграммы.</p>
          <pre class="SCREEN">WeatherStation::WeatherStation(QWidget *parent, const char *name) 
    : QDialog(parent, name), socketDevice(QSocketDevice::Datagram) 
{ 
  socketDevice.setBlocking(false); 
  socketDevice.bind(QHostAddress(), 5824); 
  socketNotifier = new QSocketNotifier(socketDevice.socket(), 
                                       QSocketNotifier::Read, 
                                       this); 
  connect(socketNotifier, SIGNAL(activated(int)), 
          this, SLOT(dataReceived())); 
  ... 
}
      
</pre>В списке инициализаторов конструктора создается устройство
<tt class="CLASSNAME">QSocketDevice</tt>, вызовом <tt class="METHODNAME">QSocketDevice::Datagram</tt>. В теле конструктора, вызовом
<tt class="METHODNAME">setBlocking(false)</tt>, оно переводится в
асинхронный режим работы. Вызовом функции <tt class="METHODNAME">
          bind()</tt>, сокету назначаются IP-адрес и номер порта.
          Вызовом функции <tt class="METHODNAME">QHostAddress()</tt> мы
          сообщаем, что будем принимать датаграммы, отправляемые на
          любой IP-адрес, который принадлежит компьютеру с запущенным
          приложением Weather Station.<br>
          <br>

          <p>Затем создается объект <tt class="CLASSNAME">QSocketNotifier</tt>, который будет
          "следить" за сокетом. Объект <tt class="CLASSNAME">QSocketNotifier</tt> будет выдавать сигнал
          <tt class="METHODNAME">activated(int)</tt> в момент
          поступления датаграммы. Этот сигнал соединяется со слотом
          <tt class="METHODNAME">dataReceived()</tt>.</p>
          <pre class="SCREEN">void WeatherStation::dataReceived() 
{ 
  QDateTime dateTime; 
  double temperature; 
  double humidity; 
  double altitude; 
  
  QByteArray datagram(socketDevice.bytesAvailable()); 
  socketDevice.readBlock(datagram.data(), datagram.size()); 
  
  QDataStream in(datagram, IO_ReadOnly); 
  in.setVersion(5); 
  in &gt;&gt; dateTime &gt;&gt; temperature &gt;&gt; humidity &gt;&gt; altitude; 
  
  dateLineEdit-&gt;setText(dateTime.date().toString()); 
  timeLineEdit-&gt;setText(dateTime.time().toString()); 
  temperatureLineEdit-&gt;setText(tr("%1 C").arg(temperature)); 
  humidityLineEdit-&gt;setText(tr("%1%").arg(humidity)); 
  altitudeLineEdit-&gt;setText(tr("%1 m").arg(altitude)); 
}
      
</pre>В функции <tt class="METHODNAME">dataReceived()</tt> производится
чтение датаграммы, вызовом <tt class="METHODNAME">readBlock()</tt>.
Функция <tt class="METHODNAME">QByteArray::data()</tt> возвращает
указатель на данные в <tt class="CLASSNAME">QByteArray</tt>, по
которому <tt class="METHODNAME">readBlock()</tt> запишет полученные
сведения. Затем производится извлечение отдельных значений, которые
заносятся в визуальные компоненты для отображения на экране. С точки
зрения приложения, датаграмма всегда передается и принимается как
единый блок данных. Это означает, что если доступен хотя бы один байт,
то следовательно датаграмма получена целиком.
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  WeatherStation station; 
  app.setMainWidget(&amp;station); 
  station.show(); 
  return app.exec(); 
}
      
</pre>В заключение, в функции <tt class="METHODNAME">main()</tt>
создается объект <tt class="CLASSNAME">WeatherStation</tt> и
назначается главным виджетом приложения.<br>
          <br>

          <p>На этом мы заканчиваем рассмотрение принципов работы с
          UDP. Мы постарались создать приемное и передающее приложения
          настолько простыми, насколько это возможно. В большинстве
          реальных применений, приложения должны как передавать, так и
          принимать датаграммы. В составе класса <tt class="CLASSNAME">QSocketDevice</tt> имеются функции <tt class="METHODNAME">peerAddress()</tt> и <tt class="METHODNAME">peerPort()</tt>, которые могут использоваться
          для определения IP-адреса и номера порта, на которые нужно
          послать ответ.</p>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER14"></a>Глава 14. XML</h1>

        <p>XML (от англ. Extensible Markup Language -- Расширяемый Язык
        Разметки) -- популярный формат файлов, используемый для обмена
        и хранения данных в текстовом виде.</p>

        <p>Для работы с XML документами, Qt поддерживает два различных
        API:</p>

        <ul>
          <li>
            <p>SAX (от англ. Simple API for XML -- Простейший
            Прикладной Интерфейс для работы с XML) -- используется для
            выполнения синтаксического анализа методом обработки
            событий разбора прямо в приложении, с помощью виртуальных
            функций.</p>
          </li>

          <li>
            <p>DOM (от англ. Document Object Model -- Объектная Модель
            представления Документов) -- преобразует XML-документ в
            древовидную структуру, в результате приложение получает
            возможность навигации по ней.</p>
          </li>
        </ul>В каждом конкретном случае, при выборе того или иного API,
        необходимо учитывать множество факторов. SAX -- более быстрый,
        он больше подходит для выполнения простых задач (например,
        чтобы найти все вхождения заданного тега в документе), и для
        работы с XML-файлами огромного размера, которые могут не
        уместиться в памяти целиком. DOM -- более удобен, в большинстве
        приложений, фактор удобства перевешивает быстроту и
        нетребовательность SAX.<br>
        <br>

        <p>В этой главе мы покажем, как работать с XML-файлами
        посредством обоих API.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="READINGXMLWITHSAX"></a>14.1.
          Чтение XML-документов с помощью SAX.</h1>

          <p>SAX -- это (де-факто) Java API стандарт для чтения
          XML-документов. Классы SAX, в библиотеке Qt, моделируют
          реализацию SAX2 Java, с небольшими отличиями в именованиях.
          Дополнительную информацию о SAX вы найдете по адресу:
          <a href="http://www.saxproject.org/" target="_top">http://www.saxproject.org/</a>.</p>

          <p>Qt предоставляет SAX-парсер <tt class="CLASSNAME">QXmlSimpleReader</tt>. Он распознает правильно
          оформленные XML-документы и поддерживает пространства имен
          XML. Во время анализа документа вызываются виртуальные
          функции классов-обработчиков событий разбора. (В данном
          случае, понятие "событие разбора" никак не
          пересекается с понятием событий в Qt.) Например, предположим,
          что парсер анализирует XML-документ со следующим
          содержимым:</p>
          <pre class="SCREEN">&lt;doc&gt; 
  &lt;quote&gt;Errare humanum est&lt;/quote&gt; 
&lt;/doc&gt;  
      
</pre>В этом случае парсер мог бы вызвать следующие обработчики событий
разбора:
          <pre class="SCREEN">startDocument() 
startElement("doc") 
startElement("quote") 
characters("Errare humanum est") 
endElement("quote") 
endElement("doc") 
endDocument()
      
</pre>Все вышеприведенные функции определены в классе
          <tt class="CLASSNAME">QXmlContentHandler</tt>. С целью
          упрощения примера мы не приводим некоторые аргументы в
          функциях <tt class="METHODNAME">startElement()</tt> и
          <tt class="METHODNAME">endElement()</tt>.<br>
          <br>

          <p>Класс <tt class="CLASSNAME">QXmlContentHandler</tt> --
          лишь один из многих, которые могут работать совместно с
          <tt class="CLASSNAME">QXmlSimpleReader</tt>. Среди других
          классов можно назвать: <tt class="CLASSNAME">QXmlEntityResolver, QXmlDTDHandler,
          QXmlErrorHandler, QXmlDeclHandler</tt> и <tt class="CLASSNAME">QXmlLexicalHandler</tt>. Они реализуют
          исключительно виртуальные функции и предоставляют сведения о
          различного типа событиях разбора. В большинстве приложений
          используются только два класса: <tt class="CLASSNAME">QXmlContentHandler</tt> и <tt class="CLASSNAME">QXmlErrorHandler</tt>.</p>

          <p>Для большего удобства, Qt так же предоставляет класс
          <tt class="CLASSNAME">QXmlDefaultHandler</tt>, который
          наследует (через множественное наследование) и реализует все
          виртуальные функции других классов-обработчиков. Такая
          архитектура, со множеством абстрактных классов и единственным
          классом-наследником, довольно необычна для Qt, однако, она
          была принята в соответствии с моделью реализации, принятой в
          Java.</p>

          <p>Рассмотрим на примере, как можно использовать классы
          <tt class="CLASSNAME">QXmlSimpleReader</tt> и <tt class="CLASSNAME">QXmlDefaultHandler</tt> для разбора XML-файла и
          отображения его содержимого в <tt class="CLASSNAME">QListView</tt>. Наш класс, производный от класса
          <tt class="CLASSNAME">QXmlDefaultHandler</tt>, будет
          называться <tt class="CLASSNAME">SaxHandler</tt>. В его
          задачи будет входить разбор XML-документа, представляющего
          собой список терминов, использовавшихся в книге.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig14.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 14.1. Дерево наследования класса <tt class="CLASSNAME">SaxHandler</tt>.</p>
            </div>
          </div><br>
          Ниже приведен XML-файл, содержимое которого отображается в
          <tt class="CLASSNAME">QListView</tt>, на рисунке 14.2.
          <a name="P308"></a>
          <pre class="SCREEN">&lt;?xml version="1.0"?&gt; 
&lt;bookindex&gt;
&lt;entry term="sidebearings"&gt; 
  &lt;page&gt;10&lt;/page&gt; 
  &lt;page&gt;34-35&lt;/page&gt; 
  &lt;page&gt;307-308&lt;/page&gt; 
&lt;/entry&gt; 
&lt;entry term="subtraction"&gt; 
  &lt;entry term="of pictures"&gt; 
    &lt;page&gt;115&lt;/page&gt; 
    &lt;page&gt;244&lt;/page&gt; 
  &lt;/entry&gt; 
  &lt;entry term="of vectors"&gt; 
    &lt;page&gt;9&lt;/page&gt; 
  &lt;/entry&gt; 
&lt;/entry&gt; 
&lt;/bookindex&gt;
      
</pre>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig14.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 14.2. Файл со списком терминов, использованных
              в книге, загруженный в <tt class="CLASSNAME">QListView</tt>.</p>
            </div>
          </div><br>
          Сначала создадим определение класса-обработчика:
          <pre class="SCREEN">class SaxHandler : public QXmlDefaultHandler 
{ 
public: 
  SaxHandler(QListView *view); 
  
  bool startElement(const QString &amp;namespaceURI, 
                    const QString &amp;localName, 
                    const QString &amp;qName, 
                    const QXmlAttributes &amp;attribs); 
  bool endElement(const QString &amp;namespaceURI, 
                  const QString &amp;localName, 
                  const QString &amp;qName); 
  bool characters(const QString &amp;str); 
  bool fatalError(const QXmlParseException &amp;exception); 
  
private: 
  QListView *listView; 
  QListViewItem *currentItem; 
  QString currentText; 
};
      
</pre>Класс <tt class="CLASSNAME">SaxHandler</tt> порожден от класса
<tt class="CLASSNAME">QXmlDefaultHandler</tt> и перекрывает четыре
метода родителя: <tt class="METHODNAME">startElement(), endElement(),
characters()</tt> и <tt class="METHODNAME">fatalError()</tt>. Первые
три функции объявлены в классе <tt class="CLASSNAME">QXmlContentHandler</tt>, последняя функция -- в
          <tt class="CLASSNAME">QXmlErrorHandler</tt>.
          <pre class="SCREEN">SaxHandler::SaxHandler(QListView *view) 
{ 
  listView = view; 
  currentItem = 0; 
}
      
</pre>Конструктор получает указатель на <tt class="CLASSNAME">
          QListView</tt>, который будет заполняться информацией из
          XML-файла.
          <pre class="SCREEN">bool SaxHandler::startElement(const QString &amp;, const QString &amp;, 
                              const QString &amp;qName, 
                              const QXmlAttributes &amp;attribs) 
{ 
  if (qName == "entry") { 
    if (currentItem) { 
      currentItem = new QListViewItem(currentItem); 
    } else { 
      currentItem = new QListViewItem(listView); 
    } 
    currentItem-&gt;setOpen(true); 
    currentItem-&gt;setText(0, attribs.value("term")); 
  } else if (qName == "page") { 
    currentText = ""; 
  } 
  return true; 
}
      
</pre>Функция <tt class="METHODNAME">startElement()</tt> вызывается,
когда парсер встречает новый открывающий тег. Третий аргумент -- это
имя тега. Четвертый -- список атрибутов. В данном примере мы будем
игнорировать первый и второй аргументы. Они предназначены для работы с
XML-файлами, которые используют механизм пространств имен.<br>

          <br>

          <p>Если это тег <tt class="PARAMETER"><em>&lt;entry&gt;</em></tt>, создается новый
          элемент списка <tt class="CLASSNAME">QListView</tt>. Если
          анализируемый тег вложен в другой тег &lt;entry&gt;,
          создается вложенный подэлемент списка -- <tt class="CLASSNAME">QListViewItem</tt>. В противном случае создается
          элемент списка верхнего уровня. Функция <tt class="METHODNAME">setOpen(true)</tt> вызывается для того, чтобы
          открыть вложенные подэлементы данного элемента. Функция
          <tt class="METHODNAME">setText()</tt> записывает текст
          (значение атрибута <tt class="PARAMETER"><em>term</em></tt>),
          который будет отображаться на экране в первой колонке
          списка.</p>

          <p>Если это тег <tt class="PARAMETER"><em>&lt;page&gt;</em></tt>, то в <tt class="VARNAME">currentText</tt> записывается пустая строка.
          Переменная <tt class="VARNAME">currentText</tt> служит своего
          рода аккумулятором для текста, размещаемого между тегами
          &lt;page&gt; и &lt;/page&gt;.</p>

          <p>В заключение, в вызывающую программу возвращается
          <tt class="PARAMETER"><em>true</em></tt>, чтобы сообщить
          парсеру SAX о том, что он может продолжить разбор файла. В
          случае неопознанного тега, можно вернуть <tt class="PARAMETER"><em>false</em></tt>, чтобы известить парсер об
          ошибке. В этом случае необходимо тогда перекрыть метод
          <tt class="METHODNAME">errorString()</tt>, унаследованный от
          <tt class="CLASSNAME">QXmlDefaultHandler</tt>, чтобы вернуть
          соответствующее сообщение об ошибке.</p>
          <pre class="SCREEN">bool SaxHandler::characters(const QString &amp;str) 
{ 
  currentText += str; 
  return true; 
}
      
</pre>Функция <tt class="METHODNAME">characters()</tt> вызывается для
передачи символьных данных из XML-файла. В нашем случае мы просто
добавляем их в конец переменной <tt class="VARNAME">currentText</tt>.
          <pre class="SCREEN">bool SaxHandler::endElement(const QString &amp;, const QString &amp;, 
                            const QString &amp;qName) 
{ 
  if (qName == "entry") { 
    currentItem = currentItem-&gt;parent(); 
  } else if (qName == "page") { 
    if (currentItem) { 
      QString allPages = currentItem-&gt;text(1); 
      if (!allPages.isEmpty()) 
        allPages += ", "; 
      allPages += currentText; 
      currentItem-&gt;setText(1, allPages); 
    } 
  } 
  return true; 
}
      
</pre>Функция <tt class="METHODNAME">endElement()</tt> вызывается,
когда парсер встречает закрывающий тег. Аналогично функции
          <tt class="METHODNAME">startElement()</tt>, третьим
          аргументом ей передается имя тега.<br>
          <br>

          <p>Если это тег <tt class="PARAMETER"><em>&lt;/entry&gt;</em></tt>, то текущим
          назначается элемент более высокого уровня. Таким образом
          восстанавливается значение переменной, которое предшествовало
          открывающему тегу <tt class="PARAMETER"><em>&lt;entry&gt;</em></tt>.</p>

          <p>Если это тег <tt class="PARAMETER"><em>&lt;/page&gt;</em></tt>, производится
          добавление номеров в список страниц, которые отображаются во
          второй колонке списка.</p>
          <pre class="SCREEN">bool SaxHandler::fatalError(const QXmlParseException &amp;exception) { 
  qWarning("Line %d, column %d: %s", exception.lineNumber(), 
            exception.columnNumber(), exception.message().ascii()); 
  return false; 
}
      
</pre>Функция <tt class="METHODNAME">fatalError()</tt> вызывается,
когда парсер не может продолжить разбор XML-файла. Тогда мы просто
выводим сообщение, с указанием номера строки и позиции в строке, где
была обнаружена ошибка.<br>
          <br>

          <p>На этом мы завершаем обзор реализации класса <tt class="CLASSNAME">SaxHandler</tt> и переходим к демонстрации
          практического его применения:</p>
          <pre class="SCREEN">bool parseFile(const QString &amp;fileName) 
{ 
  QListView *listView = new QListView(0); 
  listView-&gt;setCaption(QObject::tr("SAX Handler")); 
  listView-&gt;setRootIsDecorated(true); 
  listView-&gt;setResizeMode(QListView::AllColumns); 
  listView-&gt;addColumn(QObject::tr("Terms")); 
  listView-&gt;addColumn(QObject::tr("Pages"));
  listView-&gt;show(); 
  
  QFile file(fileName); 
  QXmlSimpleReader reader; 
  
  SaxHandler handler(listView); 
  reader.setContentHandler(&amp;handler); 
  reader.setErrorHandler(&amp;handler); 
  return reader.parse(&amp;file); 
}
      
</pre>Сначала создается виджет <tt class="CLASSNAME">QListView</tt> с
двумя колонками. Затем создаются объект <tt class="CLASSNAME">
          QFile</tt>, посредством которого будет выполняться работа с
          файлом XML-документа, и <tt class="CLASSNAME">QXmlSimpleReader</tt> -- сам парсер. У нас нет
          необходимости открывать файл -- за нас это сделает сама
          библиотека Qt.<br>
          <br>

          <p>В заключение создается объект <tt class="CLASSNAME">SaxHandler</tt>. Мы передаем его парсеру, как
          обработчик событий разбора и как обработчик ошибок. И наконец
          запускаем процесс разбора, вызовом <tt class="METHODNAME">parse()</tt>.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="READINGXMLWITHDOM"></a>14.2.
          Чтение XML-документов с помощью DOM.</h1>

          <p>DOM -- это стандарт API, для разбора XML-документов,
          разработанный в недрах World Wide Web Consortium (W3C). Qt
          предоставляет реализацию DOM Level 2 для чтения, изменения и
          записи XML-документов.</p>

          <p>DOM представляет XML-файл в памяти, в виде древовидной
          структуры. У приложения имеется возможность перемещаться по
          этой структуре, как ему заблагорассудится. Программа может
          изменить содержимое дерева и сохранить его обратно в
          файл.</p>

          <p>Рассмотрим следующий XML-документ:</p>
          <pre class="SCREEN">&lt;doc&gt; 
  &lt;quote&gt;Errare humanum est&lt;/quote&gt; 
  &lt;translation&gt;To err is human&lt;/translation&gt; 
&lt;/doc&gt;
      
</pre>Соответствующее ему дерево DOM:

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig14.2.1.png"></p>
          </div>Дерево состоит из узлов различного типа. Например, узел
          <tt class="PARAMETER"><em>Element</em></tt> соответствует
          открывающему и парному закрывающему тегам. Все, что находится
          между ними, отображается в виде дочерних узлов.<br>
          <br>

          <p>В Qt, имена классов узлов начинаются с префикса <tt class="CLASSNAME">QDom</tt>. Таким образом, класс <tt class="CLASSNAME">QDomElement</tt> представляет узел <tt class="PARAMETER"><em>Element</em></tt>, а <tt class="CLASSNAME">QDomText</tt> -- узел <tt class="PARAMETER"><em>Text</em></tt>.</p>

          <p>Различные типы узлов могут включать в себя различные типы
          дочерних узлов. Например, узел <tt class="PARAMETER"><em>Element</em></tt> может содержать другие узлы
          типа <tt class="PARAMETER"><em>Element</em></tt>, а так же
          <tt class="PARAMETER"><em>Entity Reference, Text, CDATA
          Section, Processing Instruction</em></tt> и <tt class="PARAMETER"><em>Comment</em></tt>. На рисунке 14.3 показано,
          какие типы узлов, в состав каких типов могут входить.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig14.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 14.3. Взаимоотношения между типами узлов в
              DOM.</p>
            </div>
          </div><br>
          Для демонстрации работы с XML-документами через API DOM, мы
          напишем парсер, который будет анализировать <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P308">XML-файл</a>, представленный выше.
          <pre class="SCREEN">class DomParser 
{ 
public: 
  DomParser(QIODevice *device, QListView *view); 
  
private: 
  void parseEntry(const QDomElement &amp;element, 
                  QListViewItem *parent); 
  
  QListView *listView; 
};
      
</pre>Наш класс <tt class="CLASSNAME">DomParser</tt> будет производить
анализ XML-файла и выводить его содержимое в <tt class="CLASSNAME">
          QListView</tt>. Этот класс не имеет предка.
          <pre class="SCREEN">DomParser::DomParser(QIODevice *device, QListView *view) 
{ 
  listView = view;
  
  QString errorStr; 
  int errorLine; 
  int errorColumn; 
  QDomDocument doc; 
  if (!doc.setContent(device, true, &amp;errorStr, &amp;errorLine, 
                      &amp;errorColumn)) { 
    qWarning("Line %d, column %d: %s", errorLine, errorColumn, 
             errorStr.ascii()); 
    return; 
  } 
  
  QDomElement root = doc.documentElement(); 
  if (root.tagName() != "bookindex") { 
    qWarning("The file is not a bookindex file"); 
    return; 
  } 
  
  QDomNode node = root.firstChild(); 
  while (!node.isNull()) { 
    if (node.toElement().tagName() == "entry") 
      parseEntry(node.toElement(), 0); 
    node = node.nextSibling(); 
  } 
}
      
</pre>В конструкторе создается объект <tt class="CLASSNAME">QDomDocument</tt> и вызывается его метод
          <tt class="METHODNAME">setContent()</tt>, чтобы прочитать
          XML-документ из <tt class="CLASSNAME">QIODevice</tt>. Она
          автоматически открывает устройство. Затем вызывается
          <tt class="METHODNAME">documentElement()</tt>, чтобы получить
          корневой узел (со всеми дочерними узлами), и проверяется --
          является ли этот элемент тегом &lt;bookindex&gt;. После этого
          выполняются итерации по всем дочерним узлам и если встречен
          тег &lt;entry&gt;, вызывается <tt class="METHODNAME">parseEntry()</tt> для его анализа.<br>
          <br>

          <p>Класс <tt class="CLASSNAME">QDomNode</tt> может хранить
          узлы любого типа. Если вы собираетесь обрабатывать узлы
          какого-то конкретного типа, нужно сначала выполнить
          соответствующее преобразование. В этом примере нас интересуют
          только узлы типа <tt class="PARAMETER"><em>Element</em></tt>,
          поэтому мы выполняем преобразование вызовом метода <tt class="METHODNAME">toElement()</tt>, чтобы получить узел типа
          <tt class="CLASSNAME">QDomElement</tt>, и затем вызываем
          <tt class="METHODNAME">tagName()</tt>, чтобы прочитать имя
          тега. Если узел относится к другому типу, то функция
          <tt class="METHODNAME">toElement()</tt> вернет пустой объект
          <tt class="CLASSNAME">QDomElement</tt>, с пустым именем
          тега.</p>
          <pre class="SCREEN">void DomParser::parseEntry(const QDomElement &amp;element, 
                           QListViewItem *parent) 
{ 
  QListViewItem *item; 
  if (parent) { 
    item = new QListViewItem(parent); 
  } else { 
    item = new QListViewItem(listView); 
  } 
  item-&gt;setOpen(true); 
  item-&gt;setText(0, element.attribute("term")); 
  
  QDomNode node = element.firstChild(); 
  while (!node.isNull()) { 
    if (node.toElement().tagName() == "entry") {
      parseEntry(node.toElement(), item); 
    } else if (node.toElement().tagName() == "page") { 
      QDomNode childNode = node.firstChild(); 
      while (!childNode.isNull()) { 
        if (childNode.nodeType() == QDomNode::TextNode) { 
          QString page = childNode.toText().data(); 
          QString allPages = item-&gt;text(1); 
          if (!allPages.isEmpty()) 
            allPages += ", "; 
          allPages += page; 
          item-&gt;setText(1, allPages); 
          break; 
        } 
        childNode = childNode.nextSibling(); 
      } 
    } 
    node = node.nextSibling(); 
  } 
}
      
</pre>В функции <tt class="METHODNAME">parseEntry()</tt> создается
элемент списка <tt class="CLASSNAME">QListView</tt>. Если тег вложен в
другой тег <tt class="PARAMETER"><em>&lt;entry&gt;</em></tt>, то
создается вложенный элемент списка. В противном случае создается
элемент списка верхнего уровня. Чтобы открыть элемент списка,
вызывается <tt class="METHODNAME">setOpen(true)</tt> и затем в него
записывается текст, отображаемый в первой колонке списка, вызовом
функции <tt class="METHODNAME">setText()</tt> (содержимое атрибута
<tt class="PARAMETER"><em>term</em></tt>).<br>
          <br>

          <p>После инициализации <tt class="CLASSNAME">QListViewItem</tt>, выполняются итерации по всем
          вложенным узлам, соответствующим данному тегу <tt class="PARAMETER"><em>&lt;entry&gt;</em></tt>.</p>

          <p>Если встречен тег <tt class="PARAMETER"><em>&lt;entry&gt;</em></tt>, вызывается функция
          <tt class="METHODNAME">parseEntry()</tt>, которой, в качестве
          второго аргумента передается, текущий элемент списка. В
          результате будет создан новый элемент списка, вложенный в
          текущий.</p>

          <p>Если встречен тег <tt class="PARAMETER"><em>&lt;page&gt;</em></tt>, выполняется поиск
          узла <tt class="CLASSNAME">Text</tt>. После того как он будет
          найден, выполняется преобразование узла, функцией <tt class="METHODNAME">toText()</tt>, в <tt class="CLASSNAME">QDomText</tt> и из него извлекается текст в виде
          <tt class="CLASSNAME">QString</tt>. Полученный таким образом
          текст добавляется в список номеров страниц, который
          отображается во второй колонке <tt class="CLASSNAME">QListViewItem</tt>.</p>

          <p>Теперь покажем, как можно использовать полученный класс
          <tt class="CLASSNAME">DomParser</tt>:</p>
          <pre class="SCREEN">void parseFile(const QString &amp;fileName) { 
  QListView *listView = new QListView(0); 
  listView-&gt;setCaption(QObject::tr("DOM Parser")); 
  listView-&gt;setRootIsDecorated(true); 
  listView-&gt;setResizeMode(QListView::AllColumns); 
  listView-&gt;addColumn(QObject::tr("Terms")); 
  listView-&gt;addColumn(QObject::tr("Pages")); 
  listView-&gt;show(); 
  
  QFile file(fileName); 
  DomParser(&amp;file, listView); 
}
      
</pre>Сначала создается и настраивается <tt class="CLASSNAME">
          QListView</tt>. Затем создаются <tt class="CLASSNAME">QFile</tt> и <tt class="CLASSNAME">DomParser</tt>. Во время создания, <tt class="CLASSNAME">DomParser</tt> выполняет разбор XML-документа и
          заполняет список.<br>
          <br>

          <p>Как показывает пример, навигация по DOM-дереву может
          оказаться весьма громоздкой. Простое извлечение текста,
          заключенного между тегами <tt class="PARAMETER"><em>&lt;page&gt;</em></tt> и <tt class="PARAMETER"><em>&lt;/page&gt;</em></tt> потребовало от нас
          выполнения итераций по всему списку дочерних узлов, с помощью
          функций <tt class="METHODNAME">firstChild()</tt> и <tt class="METHODNAME">nextSibling()</tt>. Программисты, которые часто
          сталкиваются с необходимостью выполнения синтаксического
          анализа XML-документов, нередко пишут свои высокоуровневые
          классы-обертки, упрощающие выполнение наиболее часто
          используемых операций, таких как извлечение текста,
          заключенного между тегами.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="WRITINGXML"></a>14.3. Запись в
          XML-документы.</h1>

          <p>Существует два основных подхода создания XML-файлов в
          приложениях Qt:</p>

          <ul>
            <li>
              <p>Можно построить дерево DOM и затем вызвать метод
              <tt class="METHODNAME">save()</tt>.</p>
            </li>

            <li>
              <p>Можно вручную создать XML-файл</p>
            </li>
          </ul>Выбор того или иного метода зачастую сильно зависит от
          используемого парсера -- SAX или DOM. Ниже приводится отрывок
          кода, который создает дерево DOM и записывает его в файл, с
          помощью <tt class="CLASSNAME">QTextStream</tt>:
          <pre class="SCREEN">  const int Indent = 4; 

  QDomDocument doc; 
  QDomElement root = doc.createElement("doc"); 
  QDomElement quote = doc.createElement("quote"); 
  QDomElement translation = doc.createElement("translation"); 
  QDomText quoteText = doc.createTextNode("Errare humanum est"); 
  QDomText translationText = doc.createTextNode("To err is human"); 

  doc.appendChild(root); 
  root.appendChild(quote); 
  root.appendChild(translation); 
  quote.appendChild(quoteText); 
  translation.appendChild(translationText); 

  QTextStream out(&amp;file); 
  doc.save(out, Indent);
      
</pre>Вторым аргументом функции <tt class="METHODNAME">save()</tt>
передается размер отступов. Ненулевое значение обеспечивает более
удобочитаемый вид файла:
          <pre class="SCREEN">&lt;doc&gt; 
    &lt;quote&gt;Errare humanum est&lt;/quote&gt; 
    &lt;translation&gt;To err is human&lt;/translation&gt; 
&lt;/doc&gt;
      
</pre>Другой вариант применим в приложениях, которые используют
структуру DOM-дерева для внутренней организации данных. Такие
приложения, как правило, читают XML-документы с помощью DOM-парсера в
память, затем изменяют содержимое дерева и сохраняют изменения с
помощью <tt class="METHODNAME">save()</tt> в XML-файл.<br>
          <br>

          <p>В примерах выше использовалась кодировка UTF-8, однако
          существует возможность сохранения данных в других кодировках.
          Для этого достаточно добавить в начало XML-файла
          соответствующую кодировку:</p>
          <pre class="SCREEN">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
      
</pre>Следующий отрывок кода показывает, как это можно сделать:
          <pre class="SCREEN">  QTextStream out(&amp;file); 
  QDomNode xmlNode = doc.createProcessingInstruction("xml", 
                            "version=\"1.0\" encoding=\"ISO-8859-1\""); 
  doc.insertBefore(xmlNode, doc.firstChild()); 
  doc.save(out, Indent);
      
</pre>Создание XML-файлов вручную выполняется ничуть не сложнее. Для
этого можно воспользоваться классом <tt class="CLASSNAME">QTextStream</tt> и записать в него строки, как в обычный
текстовый файл. Самое сложное в этом случае -- выполнить правильное
экранирование служебных символов и значений атрибутов. Сделать это
можно с помощью отдельной функции:
          <pre class="SCREEN">QString escapeXml(const QString &amp;str) 
{ 
  QString xml = str; 
  xml.replace("&amp;", "&amp;amp;"); 
  xml.replace("&lt;", "&amp;lt;"); 
  xml.replace("&gt;", "&amp;gt;"); 
  xml.replace(" ", "&amp;apos;"); 
  xml.replace("\"", "&amp;quot;"); 
  return xml; 
}
      
</pre>Ниже приводится пример использования этой функции:
          <pre class="SCREEN">  QTextStream out(&amp;file); 
  out.setEncoding(QTextStream::UnicodeUTF8); 
  out &lt;&lt; "&lt;doc&gt;\n" 
      &lt;&lt; "    &lt;quote&gt;" &lt;&lt; escapeXml(quoteText) &lt;&lt; "&lt;/quote&gt;\n" 
      &lt;&lt; "    &lt;translation&gt;" &lt;&lt; escapeXml(translationText) 
      &lt;&lt; "&lt;/translation&gt;\n" 
      &lt;&lt; "&lt;/doc&gt;\n";
      
</pre>В ежеквартальнике <span class="emphasis"><em class="EMPHASIS">
          Qt Quarterly</em></span> вы найдете статью "Generating
          XML" (по адресу: <a href="http://doc.trolltech.com/qq/qq05-generating-xml.html" target="_top">http://doc.trolltech.com/qq/qq05-generating-xml.html</a>,
               в которой приводится пример простого класса, создающего
               XML-файлы. Класс сам обслуживает экранирование служебных
               символов, вставляет отступы и задает кодировку символов,
               предоставляя нам возможность сконцентрироваться на
               содержимом XML-файла.
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER15"></a>Глава 15. Интернационализация</h1>

        <p>В этой главе мы коснемся проблем интернационализации
        приложений, написаных с помощью библиотеки Qt. Первый раздел
        полностью посвящен Unicode -- кодировке символов, принятой в
        Qt. Сведения, которые содержатся в этом разделе, будут полезны
        всем Qt-разработчикам, поскольку даже если приложение
        разрабатывалось исключительно с англоязычным интерфейсом, рано
        или поздно оно может оказаться запущенным на машине грека или
        японца.</p>

        <p>Во втором разделе будет показано, как разрабатывать
        приложения, которые потом можно будет перевести на другие
        языки. Этот процесс настолько прост, что не стоит отказываться
        от такой возможности, даже если вы не планируете выпускать
        локализованные версии приложения.</p>

        <p>В третьем разделе будет рассказываться об истинно
        интернациональных приложениях. Здесь же мы покажем, как
        изменить язык интерфейса прямо во время исполнения
        приложения.</p>

        <p>В последнем разделе мы опишем процесс перевода приложений на
        другие языки. А так же покажем, как программист и переводчик
        могут совместно работать над проектом, пользуясь утилитой
        <span class="emphasis"><em class="EMPHASIS">Qt
        Linguist</em></span> и другим инструментарием.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="WORKINGWITHUNICODE"></a>15.1.
          Unicode.</h1>

          <p>Unicode -- это стандарт кодировки символов, который
          поддерживает большинство систем записи символов.
          Первоначально, идея Unicode состояла в том. чтобы каждый из
          символов кодировался не 8-ю, а 16-ю битами, что дает
          возможность определить 65536 символов, вместо 256. Наборы
          символов ASCII и ISO 8859-1 (Latin-1) являются поднаборами
          Unicode, и сохранили числовые значения своих символов.
          Например, Символ 'A' имеет значение 0x41 в ASCII,
          Latin-1 и Unicode.</p>

          <p>Класс <tt class="CLASSNAME">QString</tt> хранит строки как
          Unicode. Каждый символ в <tt class="CLASSNAME">QString</tt>
          является 16-ти битным <tt class="CLASSNAME">QChar</tt>, а не
          8-ми битным <tt class="CLASSNAME">char</tt>. Ниже приводится
          два способа записи символа 'A' в строку:</p>
          <pre class="SCREEN">    str[0] = 'A'; 
    str[0] = QChar(0x41);
      
</pre>Мы можем записать любой из символов Unicode, по его числовому
значению. Например, так можно записать символ греческого алфавита
('<span class="INLINEMEDIAOBJECT"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig15.0.1.png">
          </span>') и знак евро ('<span class="INLINEMEDIAOBJECT"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig15.0.2.png"></span>
          ')
          <pre class="SCREEN">    str[0] = QChar(0x3A3); 
    str[0] = QChar(0x20AC);
      
</pre>Числовые значения всех символов Unicode вы найдете по адресу
<a href="http://www.unicode.org/unicode/standard/standard.html" target="_top">http://www.unicode.org/unicode/standard/standard.html</a>.
               Если у вас не возникает необходимости использовать не
               Latin-1 символы, вам достаточно будет ознакомиться с
               кодами символов в общих чертах. С другой стороны Qt
               предлагает более удобный способ ввода символов Unicode в
               программах, как -- будет описано немного ниже.<br>
          <br>

          <p>Текстовый движок Qt 3.2 поддерживает следующие наборы
          символов на всех платформах: Арабский, Китайский,
          Кириллический, Греческий, Иврит, Японский, Корейский, Лао,
          Латинский, Тайский и Вьетнамский. Кроме этого, на платформах
          X11 с Xft и Windows NT, дополнительно поддерживаются
          следующие наборы символов: Бенгальский, Девангари, Гуджарати,
          Каннада, Кхмерский, Сирийский, Тамильский, Телугу и Тана. На
          X11 поддерживаются еще Малайский и Тибетский наборы символов,
          а на Windows XP дополнительно поддерживается Дивехи. Если
          исходить из предположения, что в системе установлены
          соответствующие шрифты, Qt будет в состоянии отображать все
          символы из этих наборов.</p>

          <p>Принципы работы с <tt class="CLASSNAME">QChar</tt>, в
          программах, несколько отличается от принципов работы с
          <tt class="CLASSNAME">char</tt>. Чтобы получить числовое
          значение символа <tt class="CLASSNAME">QChar</tt>, нужно
          вызвать метод этого класса <tt class="METHODNAME">unicode()</tt>. Чтобы получить код символа ASCII
          или Latin-1, класса <tt class="CLASSNAME">QChar</tt> нужно
          вызвать метод этого класса <tt class="METHODNAME">latin1()</tt>. Если символ не относится к
          поднабору Latin-1, <tt class="METHODNAME">latin1()</tt>
          вернет 0.</p>

          <p>Если заранее известно, что программа будет работать
          исключительно с символами ASCII или Latin-1, можно
          использовать функции из <tt class="FILENAME">&lt;cctype&gt;</tt>, такие как: <tt class="METHODNAME">isalpha(), isdigit()</tt> и <tt class="METHODNAME">isspace()</tt>. Они будут работать безотказно,
          потому что символы <tt class="CLASSNAME">QChar</tt>
          автоматически преобразуются в <tt class="CLASSNAME">char</tt>, в данном контексте, так же как и
          <tt class="CLASSNAME">QString</tt> автоматически
          преобразуется в <tt class="CLASSNAME">const char *</tt>.
          Однако, в любом случае лучше пользоваться функциями-членами
          класса <tt class="CLASSNAME">QChar</tt>, для выполнения
          подобных операций, поскольку они будут корректно работать с
          любыми символами Unicode. Среди функций, которые
          предоставляются классом <tt class="CLASSNAME">QChar</tt>,
          можно назвать: <tt class="METHODNAME">isPrint(), isPunct(),
          isSpace(), isMark(), isLetter(), isNumber(),
          isLetterOrNumber(), isDigit(), isSymbol(), lower()</tt> и
          <tt class="METHODNAME">upper()</tt>. Например, так можно
          проверить -- является ли символ цифрой или символом верхнего
          регистра:</p>
          <pre class="SCREEN">    if (ch.isDigit() || ch != ch.lower())
      ...
      
</pre>Функция <tt class="METHODNAME">lower()</tt> возвращает версию
символа в нижнем регистре. Если результат функции отличается от
оригинального символа, значит это символ верхнего регистра (или
заглавный символ). Этот отрывок кода справедлив для языков, которые
различают регистр символов (прописные и строчные), включая латиницу,
кириллицу и набор греческих символов.<br>
          <br>

          <p>Как только мы начинаем работать с Unicode-строками, у нас
          появляется возможность использовать их повсюду, где Qt API
          ожидает получить <tt class="CLASSNAME">QString</tt>. В свою
          очередь, Qt берет на себя ответственность по корректному
          отображению символов строки и преобразованию в другие
          кодировки, если в этом возникает необходимость.</p>

          <p>Особую осторожность нужно проявлять при работе с
          текстовыми файлами. Они могут содержать текст в самых
          разнообразных кодировках, определить которую, зачастую
          практически невозможно. По-умолчанию <tt class="CLASSNAME">QTextStream</tt> использует системную 8-ми битную
          кодировку символов (<tt class="CLASSNAME">QTextCodec::codecForLocale()</tt>), как для
          записи, так и для чтения файлов.</p>

          <p>Если у вас есть желание писать в файлы любые Unicode
          символы, можно предложить сохранять данные как Unicode, для
          этого, непосредственно перед записью данных, с помощью
          <tt class="CLASSNAME">QTextStream</tt>, нужно вызвать функцию
          <tt class="METHODNAME">setEncoding(QTextStream::Unicode)</tt>. В
          результате текст будет записан в файл в кодировке UTF-16, где
          каждый символ представлен двумя байтами. Формат UTF-16 очень
          близок к представлению <tt class="CLASSNAME">QString</tt> в
          памяти, поэтому чтение/запись строк UTF-16 выполняется очень
          быстро. Однако, этот формат довольно расточителен в случае
          символов ASCII, для хранения которых достаточно одного
          байта.</p>

          <p>При чтении данных из файла, <tt class="CLASSNAME">QTextStream</tt> обычно автоматически определяет
          Unicode, но для полной уверенности, перед выполнением
          процедуры чтения, лучше все-таки вызвать <tt class="METHODNAME">setEncoding(QTextStream::Unicode)</tt>.</p>

          <p>Еще одна кодировка, которая поддерживает весь набор
          символов Unicode -- это UTF-8. Ее основное преимущество перед
          UTF-16 состоит в том, что для хранения символов ASCII
          (символы в диапазоне 0x00..0x7F) она использует всего один
          байт. Все остальные символы, включая символы Latin-1,
          числовые значения которых лежат выше 0x7F, представлены
          многобайтными последовательностями. Для хранения текста,
          состоящего преимущественно из ASCII-символов, в формате UTF-8
          потребуется практически в два раза меньше пространства, чем в
          UTF-16. Чтобы использовать для записи/чтения текстовых файлов
          формат UTF-8, предварительно нужно вызвать <tt class="METHODNAME">setEncoding(QTextStream::UnicodeUTF8)</tt>.</p>

          <p>Если предполагается использование исключительно кодировки
          Latin-1, вне зависимости от настроек локали пользователя,
          можно вызвать <tt class="METHODNAME">setEncoding(QTextStream::Latin1)</tt>.</p>

          <p>Другие виды кодировки могут быть установлены с помощью
          вызова функции <tt class="METHODNAME">setCodec()</tt>,
          передав ей соответствующий <tt class="CLASSNAME">QTextCodec</tt>. Класс <tt class="CLASSNAME">QTextCodec</tt> выполняет преобразование между
          Unicode и заданной кодировкой. Экземпляры этого класса очень
          широко используются в библиотеке Qt. Они используются для
          поддержки шрифтов, методов ввода, буфера обмена, механизма
          "drag-and-drop" и именования файлов.</p>

          <p>Рассмотрим такой пример: допустим, что нам необходимо
          прочитать файл, записанный в кодировке EUC-KR, тогда мы могли
          бы написать такой код:</p>
          <pre class="SCREEN">  QTextStream in(&amp;file); 
  QTextCodec *koreanCodec = QTextCodec::codecForName("EUC-KR"); 
  if (koreanCodec) 
    in.setCodec(koreanCodec);
      
</pre>Некоторые форматы файлов могут содержать указание о кодировке
символов в области заголовка. В данном случае, заголовок -- это некая
область в начале файла, которая содержит исключительно ASCII-символы,
чтобы иметь гарантированную возможность их чтения, независимо от
настроек локали. Наиболее типичный пример -- файлы формата XML,
которые, как правило, используют кодировку UTF-8 или UTF-16. Самый
правильный способ настройки <tt class="CLASSNAME">QTextStream</tt>,
перед работой с XML-файлами, это вызвать <tt class="METHODNAME">
          setEncoding(QTextStream::UnicodeUTF8)</tt>. Если файл ранее
          был сохранен в UTF-16, <tt class="CLASSNAME">QTextStream</tt>
          автоматически определит это обстоятельство и скорректирует
          свои настройки. Заголовок XML-файла, иногда может содержать
          описание кодировки в заголовке <tt class="CLASSNAME">&lt;?xml?&gt;</tt> (аргумент <tt class="CLASSNAME">encoding</tt>), например:
          <pre class="SCREEN">    &lt;?xml version="1.0" encoding="EUC-KR"?&gt;
      
</pre>Поскольку <tt class="CLASSNAME">QTextStream</tt> не допускает
изменения настройки кодировки после начала процедуры чтения, то
наиболее правильный подход заключается в том, чтобы начать чтение файла
заново, после того как будет задана правильная кодировка (может быть
получена с помощью <tt class="METHODNAME">QTextCodec::codecForName()</tt>).<br>
          <br>

          <p>Но не стоит забывать, что в случае XML, мы можем
          использовать специализированные классы Qt, предназначенные
          для работы с данными файлами (см. <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER14">Главу
          14</a>), что избавит нас от необходимости беспокоиться о
          кодировке файлов.</p>

          <p>Еще одна область применения <tt class="CLASSNAME">QTextCodec</tt> -- задание кодировки для строк,
          размещаемых в исходном тексте программ. Рассмотрим такой
          пример: группа японских программистов разрабатывают
          приложение, предназначенное, в первую очередь, для
          внутреннего рынка. Наиболее вероятно, что исходные тексты
          набираются в редакторе, в кодировке EUC-JP или Shift-JIS, что
          позволяет им вставлять японские иероглифы прямо в текст
          программы, примерно так:</p>
          <pre class="SCREEN">  QPushButton *button = new QPushButton(tr("<span class="INLINEMEDIAOBJECT"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig15.0.3.png"></span>"), 0);
      
</pre>По-умолчанию, Qt интерпретирует аргументы функции
          <tt class="METHODNAME">tr()</tt> как Latin-1. Чтобы
          установить иную кодировку, нужно вызвать статическую функцию
          <tt class="METHODNAME">QTextCodec::setCodecForTr()</tt>,
          например:
          <pre class="SCREEN">  QTextCodec *japaneseCodec = QTextCodec::codecForName("EUC-JP"); 
  QTextCodec::setCodecForTr(japaneseCodec);
      
</pre>Это должно быть сделано перед самым первым вызовом функции
<tt class="METHODNAME">tr()</tt>. Как правило это делается в функции
<tt class="METHODNAME">main()</tt>, после создания объекта
          <tt class="CLASSNAME">QApplication</tt>.<br>
          <br>

          <p>Но все остальные строки в программе, по прежнему будут
          интерпретироваться как Latin-1. Если программист хочет
          записать японские иероглифы в строковую переменную, он должен
          выполнить явное преобразование в Unicode:</p>
          <pre class="SCREEN">QString text = japaneseCodec-&gt;toUnicode("<span class="INLINEMEDIAOBJECT"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig15.0.4.png"></span>");
      
</pre>Как альтернатива -- установить соответствующий кодек для
выполнения преобразований между <tt class="CLASSNAME">const char *</tt>
и <tt class="CLASSNAME">QString</tt>, вызовом <tt class="CLASSNAME">
          QTextCodec::setCodecForCStrings()</tt>:
          <pre class="SCREEN">  QTextCodec::setCodecForCStrings(japaneseCodec);
      
</pre>Техника, описанная выше, может применяться к любой кодировке, не
являющейся Latin-1, включая Китайскую, Греческую, Корейскую и Русскую.
Ниже приводится список кодировок, поддерживаемых библиотекой Qt 3.2:

          <div class="INFORMALTABLE">
            <a name="AEN6929"></a>

            <table border="1" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Apple Roman</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>CP1258</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-4</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-15</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Big5-HKSCS</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>EUC-JP</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-5</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 10646 UCS-2</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>CP874</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>EUC-KR</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-6</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>JIS7</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>CP1250</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>GB2312</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-7</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>KOI8-R</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>CP1251</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>GB18030</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-8</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>KOI8-U</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>CP1252</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>GBK</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-8-I</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Shift-JIS</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>CP1253</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>IBM-850</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-9</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>TIS-620</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>CP1254</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>IBM-866</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-10</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>TSCII</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>CP1255</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-1</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-11</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>UTF-8</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>CP1256</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-2</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-13</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top"> </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>CP1257</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-3</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>ISO 8859-14</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top"> </td>
                </tr>
              </tbody>
            </table>
          </div>Для каждой из них, <tt class="METHODNAME">QTextCodec::codecForName()</tt> возвращает
          правильное значение. Поддержка других кодировок может быть
          реализована либо путем создания производного класса от
          <tt class="CLASSNAME">QTextCodec</tt>, либо созданием
          файла-карты (charmap) и последующим использованием <tt class="METHODNAME">QTextCodec::loadCharmapFile()</tt>.
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="MAKINGAPPLICATIONSTRANSLATIONAWARE"></a>15.2. Разработка
          приложений, подготовленных к переводу.</h1>

          <p>Если необходимо предусмотреть возможность перевода
          приложения на разные языки, следует соблюдать следующие
          положения:</p>

          <ul>
            <li>
              <p>Весь текст, который будет отображаться перед
              пользователем, должен пропускаться через функцию
              <tt class="METHODNAME">tr()</tt>.</p>
            </li>
          </ul>

          <ul>
            <li>
              <p>На запуске, приложение должно подгружать файл с
              переводом (<tt class="FILENAME">.qm</tt>).</p>
            </li>
          </ul>Эти условия не являются обязательными для приложений,
          которые никогда не будут переведены на другие языки. Однако,
          использование функции <tt class="METHODNAME">tr()</tt> не
          настолько обременительно, чтобы отказываться от нее. К тому
          же, тем самым вы оставляете открытой возможность локализации
          приложения в будущем.<br>
          <br>

          <p>Функция <tt class="METHODNAME">tr()</tt> -- статическая,
          она определена в классе <tt class="CLASSNAME">QObject</tt> и
          перекрывается в каждом классе-потомке, который включает в
          свое определение макрос <tt class="CLASSNAME">Q_OBJECT</tt>.
          Она возвращает перевод заданной строки, если он существует,
          или оригинальную версию строки -- в противном случае.</p>

          <p>Для подготовки файла перевода необходимо запустить утилиту
          Qt -- <tt class="FILENAME">lupdate</tt>. Она извлечет из
          исходного текста программы все строки, которые передаются
          функции <tt class="METHODNAME">tr()</tt> и создаст файл
          перевода. Этот файл может быть передан переводчику, который
          добавит в него перевод для каждой из строк. Более подробно
          процесс перевода описан в разделе <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#TRANSLATINGAPPLICATIONS">Перевод существующих
          приложений</a>.</p>

          <p>Функция <tt class="METHODNAME">tr()</tt> имеет следующий
          синтаксис вызова:</p>
          <pre class="SCREEN">  Context::tr(sourceText, comment)
      
</pre>Часть имени <tt class="METHODNAME">Context</tt> -- это имя
класса, производного от <tt class="CLASSNAME">QObject</tt>. Если
функция вызывается в контексте класса, то указание имени класса не
обязательно. <tt class="VARNAME">sourceText</tt> -- это строка
символов, которая должна быть переведена. <tt class="VARNAME">
          comment</tt> -- не обязательный аргумент, может
          использоваться для предоставления дополнительной информации
          переводчику.<br>
          <br>

          <p>Еще один пример:</p>
          <pre class="SCREEN">BlueWidget::BlueWidget(QWidget *parent, const char *name) 
    : QWidget(parent, name) 
{ 
  QString str1 = tr("Legal"); 
  QString str2 = BlueWidget::tr("Legal"); 
  QString str3 = YellowDialog::tr("Legal"); 
  QString str4 = YellowDialog::tr("Legal", "US paper size"); 
}
      
</pre>Первые два вызова производятся в контексте класса
          <tt class="CLASSNAME">BlueWidget</tt>, последние два --
          <tt class="CLASSNAME">YellowDialog</tt>. Все четыре вызова
          получают строку "Legal" в качестве исходной, кроме
          того, последний из них имеет дополнительный комментарий,
          который поможет переводчику понять смысл исходной строки.<br>
          <br>

          <p>Перевод строк в разных контекстах выполняется независимо
          друг от друга. Переводчики обычно учитывают контекст в своей
          работе, часто выполняя пробные запуски приложения и оценивая
          качество перевода.</p>

          <p>При вызове <tt class="METHODNAME">tr()</tt> из глобальных
          функций, необходимо явно указывать контекст, в качестве
          которого может использоваться любой класс, наследник от
          <tt class="CLASSNAME">QObject</tt>. Если в приложении нет
          ничего подходящего, всегда можно прибегнуть к услугам самого
          <tt class="CLASSNAME">QObject</tt>, например:</p>
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  ... 
  QPushButton button(QObject::tr("Hello Qt!"), 0); 
  app.setMainWidget(&amp;button); 
  button.show(); 
  return app.exec(); 
}
      
</pre>Очень часто полезной оказывается следующая методика, которая
может быть применена к переводу названия приложения: вместо того, чтобы
всякий раз набивать строки с именем приложения и вынуждать переводчика
переводить их для каждого из контекстов, в котором они используются,
более удобным будет определить его в виде макроса <tt class="VARNAME">
          APPNAME</tt>, поместить макрос в заголовочный файл и
          использовать его по мере необходимости:
          <pre class="SCREEN">#define APPNAME MainWindow::tr("OpenDrawer 2D")
      
</pre>До сих пор, в качестве контекста мы рассматривали имя класса. Это
довольно удобно, поскольку в большинстве случаев мы можем не указывать
контекст перевода явно, при вызове функции <tt class="METHODNAME">
          tr()</tt>. Но более универсальный способ подготовки строк к
          переводу состоит в использовании функции <tt class="METHODNAME">QApplication:: translate()</tt>, которая
          принимает три аргумента: контекст, исходный текст и
          необязательный комментарий. Например, еще один способ
          определения макроса <tt class="VARNAME">APPNAME</tt>:
          <pre class="SCREEN">#define APPNAME qApp-&gt;translate("Global Stuff", "OpenDrawer 2D")
      
</pre>На этот раз текст помещен в контекст "Global
Stuff".<br>
          <br>

          <p>Функции <tt class="METHODNAME">tr()</tt> и <tt class="METHODNAME">translate()</tt> имеют двойное назначение: они
          служат маркерами для утилиты <tt class="FILENAME">lupdate</tt> и в то же самое время -- это обычные
          функции C++, которые выполняют перевод текста. Такая
          двойственность накладывает некоторые ограничения на то, как
          записывается исходный код. Например, следующий отрывок не
          будет выполнять перевод строки на другой язык:</p>
          <pre class="SCREEN">  // НЕВЕРНО
  const char *appName = "OpenDrawer 2D"; 
  QString translated = tr(appName);
      
</pre>Проблема состоит в том, что <tt class="FILENAME">lupdate</tt> не
сможет отыскать строку "OpenDrawer 2D", поскольку она явно не
передается функции <tt class="METHODNAME">tr()</tt>. Эта проблема очень
часто проявляется при работе с динамическими строками:
          <pre class="SCREEN">  // НЕВЕРНО
  statusBar()-&gt;message(tr("Host " + hostName + " found"));
      
</pre>Здесь строка изменяется динамически, в зависимости от значения
переменной <tt class="VARNAME">hostName</tt>, таким образом мы не можем
требовать от <tt class="METHODNAME">tr()</tt> корректного перевода.<br>

          <br>

          <p>Как одно из решений проблемы -- используйте <tt class="METHODNAME">QString::arg()</tt>:</p>
          <pre class="SCREEN">  statusBar()-&gt;message(tr("Host %1 found").arg(hostName));
      
</pre>Остановимся в этом месте чуть подробнее: функции
          <tt class="METHODNAME">tr()</tt> передается строка символов
          "Host %1 found". Допустим, что приложение загрузило
          файл с русским переводом, тогда функция <tt class="METHODNAME">tr()</tt> должна вернуть примерно такую строку:
          "Обнаружен узел сети %1". После этого аргумент
          '%1' замещается содержимым переменной <tt class="VARNAME">hostName</tt>. В результате мы получаем вполне
          корректный перевод сообщения, которое демонстрируется
          русскоговорящему пользователю.<br>
          <br>

          <p>В случае, когда необходимо записать перевод строки в
          переменную, следует использовать макрос <tt class="METHODNAME">QT_TR_NOOP()</tt>. Чаще всего этот прием
          используется при создании статических массивов строк,
          например:</p>
          <pre class="SCREEN">void OrderForm::init() 
{ 
  static const char * const flowers[] = { 
      QT_TR_NOOP("Medium Stem Pink Roses"), 
      QT_TR_NOOP("One Dozen Boxed Roses"), 
      QT_TR_NOOP("Calypso Orchid"), 
      QT_TR_NOOP("Dried Red Rose Bouquet"), 
      QT_TR_NOOP("Mixed Peonies Bouquet"), 
      0 
  };
  int i = 0; 
  while (flowers[i]) { 
    comboBox-&gt;insertItem(tr(flowers[i])); 
    ++i; 
  } 
}
      
</pre>Макрос <tt class="METHODNAME">QT_TR_NOOP()</tt> фактически ничего
не делает, но он служит маркером для <tt class="FILENAME">lupdate</tt>.
Строки, передаваемые этому макросу попадут в файл перевода и затем
<tt class="METHODNAME">tr()</tt> переведет содержимое переменной
обычным образом. Как видите, даже не смотря на то, что функции
<tt class="METHODNAME">tr()</tt> передается не текст, а переменная,
перевод будет выполнен корректно.<br>
          <br>

          <p>Есть еще один макрос -- <tt class="METHODNAME">QT_TRANSLATE_NOOP()</tt>, который похож на
          <tt class="METHODNAME">QT_TR_NOOP()</tt>, только в отличие от
          последнего, ему можно задать контекст перевода. Этот макрос
          найдет применение, когда необходимо инициализировать
          переменные за пределами класса:</p>
          <pre class="SCREEN">static const char * const flowers[] = { 
    QT_TRANSLATE_NOOP("OrderForm", "Medium Stem Pink Roses"), 
    QT_TRANSLATE_NOOP("OrderForm", "One Dozen Boxed Roses"), 
    QT_TRANSLATE_NOOP("OrderForm", "Calypso Orchid"), 
    QT_TRANSLATE_NOOP("OrderForm", "Dried Red Rose Bouquet"), 
    QT_TRANSLATE_NOOP("OrderForm", "Mixed Peonies Bouquet"), 
    0 
};
      
</pre>причем контекст должен совпадать с контекстом вызова функции
<tt class="METHODNAME">tr()</tt>, которая будет выполнять перевод этих
строк.<br>
          <br>

          <p>При использовании <tt class="METHODNAME">tr()</tt> в
          приложении не так уж и сложно забыть заключить какие нибудь
          строки в вызов этой функции, особенно если вы еще новичок.
          Эти досадные промахи будут проявляться в локализованных
          приложениях в виде непереведенных сообщений или надписей,
          вызывая чувство недовольства у пользователя. Чтобы избежать
          этой проблемы, мы можем запретить неявное преобразование из
          <tt class="CLASSNAME">const char *</tt> в <tt class="CLASSNAME">QString</tt>, определив символ препроцессора
          <tt class="CLASSNAME">QT_NO_CAST_ASCII</tt>, перед директивой
          подключения заголовочного файла <tt class="FILENAME">&lt;qstring.h&gt;</tt>. Самый простой способ
          определить этот символ -- поместить в файл <tt class="FILENAME">.pro</tt> следующую строку:</p>
          <pre class="SCREEN">DEFINES += QT_NO_CAST_ASCII
      
</pre>В результате, каждая строка, которая не пропускается через вызов
<tt class="METHODNAME">tr()</tt> или <tt class="METHODNAME">QString::
fromAscii()</tt> (в зависимости от того, должна строка подвергаться
переводу или нет), будет вызывать ошибку времени компиляции.<br>

          <br>

          <p>После того, как все строки будут "завернуты" в
          вызовы <tt class="METHODNAME">tr()</tt>, остается соблюсти
          еще одно важное условие -- загрузить на запуске файл с
          переводом. Обычно это делается в функции <tt class="METHODNAME">main()</tt>. Например, следующий код загрузит
          файл с переводом, с учетом региональных настроек
          пользователя:</p>
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv);
  
  QTranslator appTranslator; 
  appTranslator.load(QString("app_") + QTextCodec::locale(), 
                     qApp-&gt;applicationDirPath()); 
  app.installTranslator(&amp;appTranslator); 
  ... 
  return app.exec(); 
}
      
</pre>Функция <tt class="METHODNAME">QTextCodec::locale()</tt>
возвращает строку -- имя локали пользователя, запустившего приложение.
Локаль может быть определена более или менее точно, например,
          <tt class="VARNAME">ru</tt> определяет русскую локаль,
          <tt class="VARNAME">ru_RU</tt> -- русскую локаль для России,
          <tt class="VARNAME">ru_RU.KOI8-R</tt> -- русскую локаль для
          России, с кодировкой символов KOI8-R.<br>
          <br>

          <p>Предположим, что приложение получило строку с именем
          локали -- <tt class="VARNAME">ru_RU.KOI8-R</tt>, тогда
          <tt class="METHODNAME">load()</tt> попытается сначала
          загрузить файл <tt class="FILENAME">app_ru_RU.KOI8-R.qm</tt>.
          Если этот файл отсутствует, то <tt class="METHODNAME">load()</tt> попытается загрузить файл <tt class="FILENAME">app_ru_RU.qm</tt>, затем <tt class="FILENAME">app_ru.qm</tt> и наконец <tt class="FILENAME">app.qm</tt>. Обычно, в таких случаях достаточно
          создать один файл, с именем <tt class="FILENAME">app_ru.qm</tt>. Однако, если перевод предполагает
          более точный учет региональных настроек, как например в
          случае fr_FR (французский язык для Франции) и fr_CA
          (французский язык для Канады), то может потребоваться создать
          отдельные файлы с переводом для каждого из регионов.</p>

          <p>Второй аргумент функции <tt class="METHODNAME">load()</tt>
          -- это каталог, где находится файл с переводом. Компания
          Trolltech предоставляет файлы с французским и немецким
          переводами Qt в каталоге <tt class="FILENAME">translations</tt>. (Переводы на некоторые другие
          языки так же могут поставляться вместе с библиотекой, но все
          они выполняются командами добровольцев и официально не
          поддерживаются.) Так же должен подгружаться библиотечный файл
          с переводом:</p>
          <pre class="SCREEN">  QTranslator qtTranslator; 
  qtTranslator.load(QString("qt_") + QTextCodec::locale(), 
                    qApp-&gt;applicationDirPath()); 
  app.installTranslator(&amp;qtTranslator);
      
</pre>Экземпляр класса <tt class="CLASSNAME">QTranslator</tt> может
хранить только один файл с переводом, поэтому следует использовать
различные <tt class="CLASSNAME">QTranslator</tt>. Но это не является
большой проблемой, так как мы можем создать столько экземпляров класса
<tt class="CLASSNAME">QTranslator</tt>, сколько потребуется. Все они
будут использоваться приложением при поиске перевода.<br>
          <br>

          <p>В некоторых языках, таких как арабский и иврит, строки
          пишутся справа-налево. В этих случаях приложению необходимо
          сообщить о порядке вывода строк вызовом <tt class="METHODNAME">QApplication::setReverseLayout(true)</tt>. Для
          таких языков, файл перевода должен содержать специальный
          маркер -- "LTR", который обеспечивает корректный
          вывод переведенных строк.</p>

          <p>Для пользователей программы может оказаться более удобным
          вариант, когда файлы перевода внедряются в тело исполняемого
          файла программы. Мало того, что этот прием уменьшает
          количество файлов, которые придется распространять вместе
          сприложением, но это так же сведет к минимуму риск случайной
          потери файлов с переводами. Для реализации этой возможности,
          в составе Qt распространяется утилита <tt class="FILENAME">qembed</tt>, которая преобразует файлы с
          переводами в массивы C++, которые могут передаваться функции
          <tt class="METHODNAME">QTranslator::load()</tt>.</p>

          <p>Мы описали все, что необходимо сделать, чтобы подготовить
          приложение к интернационализации. Но язык и направление
          письма это еще не все, что отличает страны и культуры.
          Интернационализированная программа должна принимать во
          внимание формат представления даты, времени, национальной
          валюты, чисел и порядок сортировки строк. Для этого в Qt 3.2
          не существует никаких специальных функций, но мы можем
          использовать стандартные функции <tt class="METHODNAME">setlocale()</tt> и <tt class="METHODNAME">localeconv()</tt>. <a name="AEN7233" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#FTN.AEN7233"><span class="footnote">[8]</span></a></p>

          <p>Некоторые функции и классы Qt адаптируют свое поведение
          под настройки локали:</p>

          <ul>
            <li>
              <p>Функция <tt class="METHODNAME">QString::localeAwareCompare()</tt> выполняет
              сравнение строк в зависимости от настроек локали. Она
              используется классами <tt class="CLASSNAME">QIconView</tt> и <tt class="CLASSNAME">QListView</tt> для выполнения сортировки
              своих элементов.</p>
            </li>

            <li>
              <p>Функция <tt class="METHODNAME">toString()</tt>
              используется классами <tt class="CLASSNAME">QDate,
              QTime</tt> и <tt class="CLASSNAME">QDateTime</tt>,
              возвращающими локализованное представление даты и
              времени, когда вызываются с аргументом <tt class="CLASSNAME">Qt::LocalDate</tt>.</p>
            </li>

            <li>
              <p>По-умолчанию <tt class="CLASSNAME">QDateEdit,
              QTimeEdit</tt> и <tt class="CLASSNAME">QDateTimeEdit</tt>
              представляют дату и время в локализованном виде.</p>
            </li>
          </ul>Наконец, вместе с переводом, приложение может
          использовать разные наборы иконок для разных языков.
          Например, для языков, в которых письмо осуществляется
          справа-налево, в web-браузере логичнее было бы поменять
          местами кнопки "Назад" и "Вперед".
          Сделать это можно следующим образом:
          <pre class="SCREEN">  if (QApplication::reverseLayout()) { 
    backAct-&gt;setIconSet(forwardIcon); 
    forwardAct-&gt;setIconSet(backIcon); 
  } else { 
    backAct-&gt;setIconSet(backIcon); 
    forwardAct-&gt;setIconSet(forwardIcon); 
  }
      
</pre>Иконки, изображение на которых соответствует алфавитным символам,
очень часто должны быть адаптированы, в соответствии с конкретными
языковыми настройками. Например, в текстовых процессорах, иконка с
изображением символа "I" (что означает "Italic" --
Курсив) должна быть заменена на "C" для Испании (Cursivo) или
на "K" -- для России (Курсив). Самый простой способ:
          <pre class="SCREEN">  if (tr("Italic")[0] == 'C') { 
    italicAct-&gt;setIconSet(iconC); 
  } else if (tr("Italic")[0] == 'K') { 
    italicAct-&gt;setIconSet(iconK); 
  } else { 
    italicAct-&gt;setIconSet(iconI); 
  }
      
</pre>
        </div><br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="DYNAMICLANGUAGESWITCHING"></a>15.3. Динамическое
          переключение языков.</h1>

          <p>В большинстве приложений, определение предпочитаемого
          пользователем языка производится в функции <tt class="METHODNAME">main()</tt> и затем выполняется загрузка
          соответствующего файла с переводом. Чаще всего этого бывает
          достаточно, но иногда возникают ситуации, когда нужно быстро
          переключить интерфейс приложения на другой язык, без
          перезапуска приложения. В качестве примера можно привести
          приложения для операторов международных телефонных центров,
          для переводчиков, выполняющих синхронный перевод или для
          операторов отделений банков, когда становится насущной
          необходимость в быстром переключении между языками.</p>

          <p>Чтобы приложение позволяло выполнять быстрый переход от
          языка к языку, нужно сделать немного больше, чем просто
          загрузить единственный файл с переводом, но это не так
          сложно, как может показаться на первый взгляд. Чтобы
          реализовать возможность выбора языка во время исполнения
          приложения, нужно:</p>

          <ul>
            <li>
              <p>Обеспечить пользователя средствами выбора языка.</p>
            </li>

            <li>
              <p>Для каждого виджета или диалога, все строки,
              подвергающиеся переводу, необходимо разместить в
              отдельной функции (которую часто называют как <tt class="METHODNAME">retranslateStrings()</tt>) и вызывать ее при
              смене языка.</p>
            </li>
          </ul>Рассмотрим отдельные части исходного кода приложения,
          которое поддерживает возможность быстрой смены языка
          интерфейса. Язык по-умолчанию -- Английский.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig15.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 15.1. Меню <strong class="COMMAND">Language</strong>.</p>
            </div>
          </div><br>
          Поскольку заранее не известно, какой из языков предпочтет
          пользователь, приложение запускается с языком по-умолчанию.
          Загрузка файла с переводом будет производиться динамически,
          по мере необходимости. Таким образом, весь код,
          поддерживающий перевод, должен размещаться в классах главного
          окна и диалогов. Рассмотрим класс главного окна
          приложения-примера (Call Center), производного от класса
          <tt class="CLASSNAME">QMainWindow</tt>:
          <pre class="SCREEN">MainWindow::MainWindow(QWidget *parent, const char *name) 
    : QMainWindow(parent, name) 
{ 
  journalView = new JournalView(this); 
  setCentralWidget(journalView); 
  
  qmPath = qApp-&gt;applicationDirPath() + "/translations";
  appTranslator = new QTranslator(this); 
  qtTranslator = new QTranslator(this); 
  qApp-&gt;installTranslator(appTranslator); 
  qApp-&gt;installTranslator(qtTranslator); 
  
  createActions(); 
  createMenus(); 
  retranslateStrings(); 
}
      
</pre>В конструкторе, виджет <tt class="CLASSNAME">JournalView</tt>
(наследник класса <tt class="CLASSNAME">QListView</tt>) назначается
центральным. Затем настраиваются переменные-члены, которые имеют
отношение к переводу:

          <ul>
            <li>
              <p>Переменная <tt class="VARNAME">qmPath</tt>, типа
              <tt class="CLASSNAME">QString</tt>, определяет путь к
              каталогу, где находятся файлы с переводами.</p>
            </li>

            <li>
              <p>Переменная <tt class="VARNAME">appTranslator</tt> --
              это указатель на объект <tt class="CLASSNAME">QTranslator</tt>, который используется для
              хранения текущего перевода.</p>
            </li>

            <li>
              <p>Переменная <tt class="VARNAME">qtTranslator</tt> --
              это указатель на объект <tt class="CLASSNAME">QTranslator</tt>, который используется для
              хранения текущего библиотечного перевода.</p>
            </li>
          </ul>В конце вызываются <tt class="METHODNAME">createActions()</tt> и <tt class="METHODNAME">createMenus()</tt>, которые создают систему
          меню. И наконец вызывается функция <tt class="METHODNAME">retranslateStrings()</tt>, которая настраивает
          первоначальный перевод по-умолчанию.
          <pre class="SCREEN">void MainWindow::createActions() 
{ 
  newAct = new QAction(this); 
  connect(newAct, SIGNAL(activated()), this, SLOT(newFile())); 
  ... 
  aboutQtAct = new QAction(this); 
  connect(aboutQtAct, SIGNAL(activated()), qApp, SLOT(aboutQt())); 
}
      
</pre>Функция <tt class="METHODNAME">createActions()</tt> создает
обычные объекты <tt class="CLASSNAME">QAction</tt>, правда без указания
надписей и горячих комбинаций клавиш. Эти действия будут выполнены в
функции <tt class="METHODNAME">retranslateStrings()</tt>.
          <pre class="SCREEN">void MainWindow::createMenus() 
{ 
  fileMenu = new QPopupMenu(this); 
  newAct-&gt;addTo(fileMenu); 
  openAct-&gt;addTo(fileMenu); 
  saveAct-&gt;addTo(fileMenu); 
  exitAct-&gt;addTo(fileMenu); 
  ... 
  createLanguageMenu(); 
}
      
</pre>Функция <tt class="METHODNAME">createMenus()</tt> создает меню,
но не вставляет их в полосу меню. Эти действия так же будут выполнены в
функции <tt class="METHODNAME">retranslateStrings()</tt>. В конце
функции вызывается <tt class="METHODNAME">createLanguageMenu()</tt>,
которая заполняет меню списком поддерживаемых языков. Мы вернемся к
этой функции чуть позже, а сейчас заглянем в исходный код функции
<tt class="METHODNAME">retranslateStrings()</tt>:
          <pre class="SCREEN">void MainWindow::retranslateStrings() 
{ 
  setCaption(tr("Call Center")); 
  
  newAct-&gt;setMenuText(tr("&amp;New")); 
  newAct-&gt;setAccel(tr("Ctrl+N")); 
  newAct-&gt;setStatusTip(tr("Create a new journal")); 
  ... 
  aboutQtAct-&gt;setMenuText(tr("About &amp;Qt")); 
  aboutQtAct-&gt;setStatusTip(tr("Show the Qt library's About box")); 
  
  menuBar()-&gt;clear(); 
  menuBar()-&gt;insertItem(tr("&amp;File"), fileMenu); 
  menuBar()-&gt;insertItem(tr("&amp;Edit"), editMenu); 
  menuBar()-&gt;insertItem(tr("&amp;Reports"), reportsMenu); 
  menuBar()-&gt;insertItem(tr("&amp;Language"), languageMenu); 
  menuBar()-&gt;insertItem(tr("&amp;Help"), helpMenu); 
}
      
</pre>В функции <tt class="METHODNAME">retranslateStrings()</tt>
сосредоточены все вызовы <tt class="METHODNAME">tr()</tt> для класса
<tt class="CLASSNAME">MainWindow</tt>. Она вызывается из конструктора
класса, а так же всякий раз, когда пользователь изменяет язык
интерфейса приложения, из меню <strong class="COMMAND">Language</strong>.<br>
          <br>

          <p>Здесь в пункты меню записывается текст и строки подсказки.
          Затем меню вставляются в полосу меню, с уже переведенными
          надписями.</p>

          <p>Функция <tt class="METHODNAME">createMenus()</tt>, которая
          упоминалась выше, вызывает функцию <tt class="METHODNAME">createLanguageMenu()</tt>, чтобы заполнить меню
          <strong class="COMMAND">Language</strong> списком
          поддерживаемых языков:</p>
          <pre class="SCREEN">void MainWindow::createLanguageMenu() 
{ 
  QDir dir(qmPath); 
  QStringList fileNames = dir.entryList("callcenter_*.qm"); 
  
  for (int i = 0; i &lt; (int)fileNames.size(); ++i) { 
    QTranslator translator; 
    translator.load(fileNames[i], qmPath); 
    
    QTranslatorMessage message = 
            translator.findMessage("MainWindow", "English"); 
    QString language = message.translation(); 
    
    int id = languageMenu-&gt;insertItem( 
                     tr("&amp;%1 %2").arg(i + 1).arg(language), 
                     this, SLOT(switchToLanguage(int))); 
    languageMenu-&gt;setItemParameter(id, i); 
    if (language == "English") 
      languageMenu-&gt;setItemChecked(id, true); 
    
    QString locale = fileNames[i]; 
    locale = locale.mid(locale.find('_') + 1); 
    locale.truncate(locale.find('.'));
    locales.push_back(locale); 
  } 
}
      
</pre>Вместо того, чтобы жестко зашивать список языков в приложение,
здесь создается один пункт меню для каждого файла с переводом
(<tt class="FILENAME">.qm</tt>). Для простоты примера, предполагается,
что англоязычный вариант так же находится в отдельном файле
          <tt class="FILENAME">.qm</tt>. Как альтернатива -- когда
          пользователь выбирает пункт меню <strong class="COMMAND">English</strong>, очищать <tt class="CLASSNAME">QTranslator</tt> методом <tt class="METHODNAME">clear()</tt>.<br>
          <br>

          <p>Единственная сложность тут состоит в том, чтобы
          представить названия языков в меню в достаточно удобочитаемом
          виде. Если просто показывать <strong class="COMMAND">en</strong>, вместо <strong class="COMMAND">English</strong>, или <strong class="COMMAND">de</strong>, вместо <strong class="COMMAND">Deutsch</strong>, то мы можем привести в
          замешательство отдельных пользователей. Поэтому, <tt class="METHODNAME">createLanguageMenu()</tt> проверяет перевод
          строки "English" в контексте
          "MainWindow". Эта строка должна быть переведена как
          "Deutsch" в немецком переводе, как
          "Francais" -- во французским и как
          "<span class="INLINEMEDIAOBJECT"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig15.0.5.png"></span>" -- в японском.</p>

          <p>Пункты меню создаются вызовом <tt class="METHODNAME">QPopupMenu::insertItem()</tt>. Они соединяются
          со слотом <tt class="METHODNAME">switchToLanguage(int)</tt>
          главного окна, который мы рассмотрим чуть ниже. Аргумент
          слота <tt class="METHODNAME">switchToLanguage(int)</tt> --
          это значение, установленное функцией <tt class="METHODNAME">setItemParameter()</tt>. Примерно то же самое мы
          делали в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">Главе 3</a>, когда в приложении
          Spreadsheet создавали <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#P54">пункты меню</a>,
          соответствующие названиям недавно открывавшихся
          документов.</p>

          <p>В конце, название локали добавляется в список <tt class="VARNAME">locales</tt>, который будет использоваться функцией
          <tt class="METHODNAME">switchToLanguage()</tt>.</p>
          <pre class="SCREEN">void MainWindow::switchToLanguage(int param) 
{ 
  appTranslator-&gt;load("callcenter_" + locales[param], qmPath); 
  qtTranslator-&gt;load("qt_" + locales[param], qmPath); 
  
  for (int i = 0; i &lt; (int)languageMenu-&gt;count(); ++i) 
    languageMenu-&gt;setItemChecked(languageMenu-&gt;idAt(i), 
                                 i == param); 
  retranslateStrings(); 
}
      
</pre>Слот <tt class="METHODNAME">switchToLanguage()</tt> отрабатывает,
когда пользователь выбирает какой либо пункт в меню
          <strong class="COMMAND">Language</strong>. Сначала слот
          загружат файлы с переводами для приложения и для библиотеки
          Qt. Затем обновляет состояние маркеров пунктов меню. И
          наконец вызывает <tt class="METHODNAME">retranslateStrings()</tt>, которая выполняет
          перевод всех надписей в главном окне.<br>
          <br>

          <p>В Microsoft Windows, дополнительно к обслуживанию меню
          <strong class="COMMAND">Language</strong>, можно
          предусмотреть реакцию приложения на событие <tt class="METHODNAME">LocaleChange</tt>, которое возникает, когда
          изменяются региональные настройки среды. Этот тип событий
          существует во всех версиях Qt, но актуален только для
          Microsoft Windows. Для обработки этого события необходимо
          перекрыть обработчик <tt class="METHODNAME">QObject::event()</tt> следующим образом:</p>
          <pre class="SCREEN">bool MainWindow::event(QEvent *event) 
{ 
  if (event-&gt;type() == QEvent::LocaleChange) { 
    appTranslator-&gt;load(QString("callcenter_") 
                        + QTextCodec::locale(), 
                        qmPath); 
    qtTranslator-&gt;load(QString("qt_") + QTextCodec::locale(), 
                       qmPath); 
    retranslateStrings(); 
  } 
  return QMainWindow::event(event); 
}
      
</pre>Если пользователь изменит региональные настройки во время работы
приложения, то будет произведена попытка загрузить соответствующий файл
с переводом и последующим вызовом <tt class="METHODNAME">retranslateStrings()</tt> будет обновлен интерфейс
приложения.<br>
          <br>

          <p>В любом случае, событие передается обработчику событий
          предка, поскольку базовый класс так же может быть
          заинтересован в получении события <tt class="METHODNAME">LocaleChange</tt>.</p>

          <p>На этом мы завершаем обзор класса <tt class="CLASSNAME">MainWindow</tt> и переходим к одному из виджетов
          главного окна -- <tt class="CLASSNAME">JournalView</tt>,
          чтобы показать, какие изменения необходимо внести, чтобы он
          так же поддерживал возможность изменения языка во время
          работы приложения.</p>
          <pre class="SCREEN">JournalView::JournalView(QWidget *parent, const char *name) 
    : QListView(parent, name) 
{ 
  ... 
  retranslateStrings(); 
}
      
</pre>Класс <tt class="CLASSNAME">JournalView</tt> порожден от класса
<tt class="CLASSNAME">QListView</tt>. В конце конструктора класса
вызывается его метод <tt class="METHODNAME">retranslateStrings()</tt>.
Это очень похоже на то, что мы делали в классе главного окна.
          <pre class="SCREEN">bool JournalView::event(QEvent *event) 
{ 
  if (event-&gt;type() == QEvent::LanguageChange) 
    retranslateStrings(); 
  return QListView::event(event); 
}
      
</pre>Обработчик событий виджета вызывает <tt class="METHODNAME">
          retranslateStrings()</tt>, при поступлении события <tt class="METHODNAME">LanguageChange</tt>.<br>
          <br>

          <p>Qt генерирует событие <tt class="METHODNAME">LanguageChange</tt>, при изменении содержимого
          <tt class="CLASSNAME">QTranslator</tt>. В нашем приложении
          эта ситуация возникает, когда вызывается функция <tt class="METHODNAME">load()</tt>, для загрузки файлов перевода в
          <tt class="VARNAME">appTranslator</tt> и <tt class="VARNAME">qtTranslator</tt>.</p>

          <p>Не следует путать события <tt class="METHODNAME">LanguageChange</tt> и <tt class="METHODNAME">LocaleChange</tt>. Событие <tt class="METHODNAME">LocaleChange</tt> как бы говорит приложению:
          "Необходимо загрузить другой файл с переводом", а
          событие <tt class="METHODNAME">LanguageChange</tt>:
          "Необходимо выполнить перевод всех строк".</p>

          <p>В классе <tt class="CLASSNAME">MainWindow</tt> у нас не
          возникало необходимости реагировать на событие <tt class="METHODNAME">LanguageChange</tt>, поскольку функция
          <tt class="METHODNAME">retranslateStrings()</tt> итак
          вызывалась сразу же вслед за загрузкой нового файла
          перевода.</p>
          <pre class="SCREEN">void JournalView::retranslateStrings() 
{ 
  for (int i = columns() - 1; i &gt;= 0; --i) 
    removeColumn(i); 
  addColumn(tr("Time")); 
  addColumn(tr("Priority")); 
  addColumn(tr("Phone Number")); 
  addColumn(tr("Subject")); 
}
      
</pre>Функция <tt class="METHODNAME">retranslateStrings()</tt>
пересоздает заголовки столбцов в <tt class="CLASSNAME">QListView</tt>,
с новыми надписями в них. Для этого, сначала все заголовки удаляются, а
потом создаются новые. Эта операция воздействует только на заголовки
столбцов и никак не влияет на содержимое <tt class="CLASSNAME">
          QListView</tt>.<br>
          <br>

          <p>Для диалогов и виджетов, создаваемых в визуальном
          построителе <span class="emphasis"><em class="EMPHASIS">Qt
          Designer</em></span>, утилита <tt class="FILENAME">uic</tt>
          сама создает функции, похожие на <tt class="METHODNAME">retranslateStrings()</tt>, которая автоматически
          вызывается в ответ на событие <tt class="METHODNAME">LanguageChange</tt>. Все что нам остается
          сделать -- это загрузить соответствующий файл с переводом,
          когда пользователь изменяет язык приложения.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="TRANSLATINGAPPLICATIONS"></a>15.4. Перевод существующих
          приложений.</h1>

          <p>Перевод Qt-приложений, которые содержат в себе вызовы
          <tt class="METHODNAME">tr()</tt>, выполняется в три
          приема;</p>

          <ol type="1">
            <li>
              <p>Утилитой <tt class="FILENAME">lupdate</tt> извлекаются
              все строки из исходного текста приложения.</p>
            </li>

            <li>
              <p>Выполняется перевод строк, с помощью утилиты
              <span class="emphasis"><em class="EMPHASIS">Qt
              Linguist</em></span>.</p>
            </li>

            <li>
              <p>С помощью утилиты <tt class="FILENAME">lrelease</tt>
              создается двоичный файл <tt class="FILENAME">.qm</tt> с
              переводом, который потом может быть загружен
              приложением.</p>
            </li>
          </ol>Пункты 1 и 3 выполняются разработчиком приложения. Пункт
          2 -- переводчиком. Этот процесс может повторяться
          неоднократно, в ходе разработки и эксплуатации
          приложения.<br>
          <br>

          <p>В качестве примера, рассмотрим процесс перевода приложения
          Spreadsheet, которое было написано нами в <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">Главе 3</a>. Оно уже содержит все необходимые
          вызовы <tt class="METHODNAME">tr()</tt>.</p>

          <p>Прежде всего, необходимо внести изменения в файл проекта
          <tt class="FILENAME">.pro</tt>, чтобы указать -- какие языки
          будут поддерживаться приложением. Допустим, что мы собираемся
          включить поддержку немецкого, французского и русского языков,
          дополнительно к английскому, тогда необходимо в файл
          <tt class="FILENAME">spreadsheet.pro</tt> добавить раздел
          <tt class="FILENAME">TRANSLATIONS</tt>:</p>
          <pre class="SCREEN">TRANSLATIONS = spreadsheet_de.ts \ 
               spreadsheet_fr.ts \
               spreadsheet_ru.ts
      
</pre>Здесь мы указали три файла переводов: для немецкого, французского
и русского языков. Эти файлы будут созданы при первом запуске утилиты
<tt class="FILENAME">lupdate</tt>, а на последующих запусках будут
просто дополняться.<br>
          <br>

          <p>Обычно исходные файлы с переводом имеют расширение
          <tt class="FILENAME">.ts</tt>. Они записываются в формате XML
          и потому занимают больше места на диске, чем скомпилированные
          файлы с переводом <tt class="FILENAME">.qm</tt>. Для тех,
          кому это интересно -- <tt class="FILENAME">.ts</tt> означает
          "translation source" (исходный текст перевода), а
          <tt class="FILENAME">.qm</tt> -- "Qt message".</p>

          <p>Допустим, что мы уже находимся в каталоге с исходными
          текстами приложения Spreadsheet. Теперь запускаем <tt class="FILENAME">lupdate</tt> из командной строки:</p>
          <pre class="SCREEN">  lupdate -verbose spreadsheet.pro
      
</pre>Ключ <tt class="FILENAME">-verbose</tt> -- необязательный. Он
просто заставляет <tt class="FILENAME">lupdate</tt> выводить более
подробную информацию в ходе своей работы. Ниже приведен примерный
вывод, полученный во время работы утилиты:
          <pre class="SCREEN">Updating  spreadsheet_de.ts ... 
  0 known, 101 new and 0 obsoleted messages 
Updating  spreadsheet_fr.ts ... 
  0 known, 101 new and 0 obsoleted messages
Updating  spreadsheet_ru.ts ... 
  0 known, 101 new and 0 obsoleted messages
      
</pre>Каждая строка, которая "завернута" в вызов
          <tt class="METHODNAME">tr()</tt>, заносится в <tt class="FILENAME">.ts</tt>, с пустым местом для перевода. Строки,
          которые находятся в файле <tt class="FILENAME">.ui</tt>, так
          же включаются в исходный файл перевода.<br>
          <br>

          <p>По-умолчанию, <tt class="FILENAME">lupdate</tt>
          предполагает, что все строки, завернутые в вызовы <tt class="METHODNAME">tr()</tt>, набраны в кодировке Latin-1. Если это
          не так, необходимо указать элемент <tt class="METHODNAME">CODEC</tt> в файле <tt class="FILENAME">.pro</tt>, например так:</p>
          <pre class="SCREEN">CODEC       = EUC-JP
      
</pre>Это необходимо делать в дополнение к вызову <tt class="METHODNAME">QTextCodec::setCodecForTr()</tt> в приложении.<br>

          <br>

          <p>Перевод, в файлы <tt class="FILENAME">spreadsheet_de.ts,
          spreadsheet_fr.ts</tt> и <tt class="FILENAME">spreadsheet_ru.ts</tt>, добавляется переводчиком,
          с помощью утилиты <span class="emphasis"><em class="EMPHASIS">Qt Linguist</em></span>.</p>

          <p>Чтобы запустить <span class="emphasis"><em class="EMPHASIS">Qt Linguist</em></span>, в среде Windows, выберите
          пункт <strong class="COMMAND">Qt 3.2.x | Qt Linguist</strong>
          в меню <strong class="COMMAND">Пуск</strong>, в среде Unix --
          наберите команду <tt class="FILENAME">linguist</tt>. Затем, с
          помощью меню <strong class="COMMAND">File|Open</strong>,
          откройте файл с исходным текстом перевода.</p>

          <p>С левой стороны главного окна <span class="emphasis"><em class="EMPHASIS">Qt Linguist</em></span>
          находится список контекстов переводов. Для Spreadsheet
          существуют следующие контексты: "FindDialog",
          "GoToCellDialog", "MainWindow",
          "SortDialog" и "Spreadsheet". В верхней
          части с правой стороны находится список строк для текущего
          контекста. Каждая строка отображается вместе с переводом и
          флагом <strong class="COMMAND">Done</strong>
          ("Готово"). В средней области, с правой стороны,
          вводится текст перевода для текущей строки. И внизу находится
          список переводов, автоматически предлагаемых утилитой
          <span class="emphasis"><em class="EMPHASIS">Qt
          Linguist</em></span>.</p>

          <p>По окончании работы над переводом, файл <tt class="FILENAME">.ts</tt> необходимо преобразовать в файл
          <tt class="FILENAME">.qm</tt>. Для этого, в приложении
          <span class="emphasis"><em class="EMPHASIS">Qt
          Linguist</em></span> выберите пункт меню <strong class="COMMAND">File|Release</strong>. Обычно, после перевода
          нескольких строк, выполняются пробные запуски приложения, с
          созданным файлом <tt class="FILENAME">.qm</tt>, чтобы
          визуально оценить качество перевода.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig15.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 15.2. <span class="emphasis"><em class="EMPHASIS">Qt Linguist</em></span> в действии.</p>
            </div>
          </div><br>
          Чтобы перегенерировать все файлы <tt class="FILENAME">.qm</tt> сразу, необходимо запустить утилиту
          командной строки <tt class="FILENAME">lrelease</tt>:
          <pre class="SCREEN">lrelease -verbose spreadsheet.pro
      
</pre>Предположим, что мы сделали перевод на русский язык 19-ти строк,
причем установили признак <strong class="COMMAND">Done</strong> для
17-ти из них. В этом случае мы получим от <tt class="FILENAME">
          lrelease</tt> примерно такой вывод:
          <pre class="SCREEN">Updating  spreadsheet_de.qm ... 
  0 finished, 0 unfinished and 101 untranslated messages 
Updating  spreadsheet_fr.qm ... 
  0 finished, 0 unfinished and 101 untranslated messages 
Updating  spreadsheet_ru.qm ... 
  17 finished, 2 unfinished and 82 untranslated messages
      
</pre>Непереведенные строки, при пробном запуске приложения, будут
отображаться на языке оригинала. Флаг <strong class="COMMAND">
          Done</strong> никак не используется утилитой <tt class="FILENAME">lrelease</tt>, он предназначен исключительно для
          переводчика, чтобы напоминать о том, какие строки имеют
          окончательный перевод, а какие требуют уточнения.<br>
          <br>

          <p>В случае внесения изменений в исходный код приложения,
          содержимое файлов <tt class="FILENAME">.ts</tt> может
          "устареть". Чтобы этого не происходило нужно всякий
          раз запускать утилиту <tt class="FILENAME">lupdate</tt>,
          добавлять перевод для вновь появляющихся строк и пересобирать
          файлы <tt class="FILENAME">.qm</tt>. Некоторые команды
          разработчиков синхронизируют перевод так часто, насколько это
          только возможно, другие предпочитают дождаться окончательного
          релиза приложения и только тогда приступают к переводу.</p>

          <p>Утилиты <tt class="FILENAME">lupdate</tt> и <span class="emphasis"><em class="EMPHASIS">Qt Linguist</em></span>
          достаточно "умны". Переведенные строки,
          необходимость в которых уже отпала, все равно сохраняются в
          исходных файлах с переводами, на тот случай, если они могут
          понадобиться в будущем. При обновлении файлов <tt class="FILENAME">.ts</tt>, утилита <tt class="FILENAME">lupdate</tt> использует интеллектуальный алгоритм
          объединения, который помогает избежать лишней работы по
          переводу одинаковых строк в различных контекстах.</p>

          <p>За дополнительной информацией о программах <span class="emphasis"><em class="EMPHASIS">Qt Linguist</em></span>,
          <tt class="FILENAME">lupdate</tt> и <tt class="FILENAME">lrelease</tt>, обращайтесь к справочному
          руководству <span class="emphasis"><em class="EMPHASIS">Qt
          Linguist</em></span>, которое доступно по адресу: <a href="http://doc.trolltech.com/3.2/linguist-manual.html" target="_top">http://doc.trolltech.com/3.2/linguist-manual.html</a>.
             Это руководство содержит полное описание пользовательского
             интерфейса программы и пошаговый самоучитель для
             программистов.</p>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER16"></a>Глава 16. Разработка справочной
        системы приложения.</h1>

        <p>Большинство приложений включают в себя справочную систему. В
        некоторых случаях она ограничивается предоставлением
        всплывающих подсказок, подсказок, выводимых в строке состояния
        справки типа: "What's This?" ("Что
        это?"). Qt полностью поддерживает отображение справочной
        информации такого рода. В других приложениях объем справочной
        информации может быть очень велик и содержать огромное
        количество текста. Для отображения такого рода справочной
        информации можно использовать компонент <tt class="CLASSNAME">QTextBrowser</tt>, а можно воспользоваться услугами
        <span class="emphasis"><em class="EMPHASIS">Qt
        Assistant</em></span> или любого другого обозревателя
        HTML-страниц.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="TOOLTIPSSTATUSTIPSANDWHATSTHISHELP"></a>16.1. Всплывающие
          подсказки и справка "What's This?".</h1>

          <p>Всплывающие подсказки -- это небольшие текстовые
          сообщения, которые появляются на экране, когда указатель мыши
          останавливается над виджетом на некоторое время. Текст таких
          подсказок выводится черным шрифтом на желтом фоне. Изначально
          всплывающие подсказки предназначались для того, чтобы дать
          краткое описание кнопок на панели инструментов. Однако мы
          можем добавить всплывающие подсказки к любому из виджетов.
          Например:</p>
          <pre class="SCREEN">  QToolTip::add(findButton, tr("Find next"));
      
</pre>Чтобы добавить подсказку к кнопке в панели инструментов, которой
соответствует объект <tt class="CLASSNAME">QAction</tt>, можно просто
вызвать метод <tt class="METHODNAME">setToolTip()</tt> требуемого
объекта <tt class="CLASSNAME">QAction</tt>:
          <pre class="SCREEN">  newAct = new QAction(tr("&amp;New"), tr("Ctrl+N"), this); 
  newAct-&gt;setToolTip(tr("New file"));
      
</pre>Если текст подсказки не установить явно, он будет сгенерирован
автоматически, из текста, заданного при создании объекта, и горячей
комбинации клавиш, например "New (Ctrl+N)".<br>
          <br>

          <p>Подсказка в строке состояния -- это небольшой по объему
          текст, обычно немного больше, чем текст всплывающей
          подсказки, который отображается в строке состояния
          приложения. Для добавления такого текста нужно вызвать
          функцию <tt class="METHODNAME">setStatusTip()</tt>:</p>
          <pre class="SCREEN">  newAct-&gt;setStatusTip(tr("Create a new file"));
      
</pre>При отсутствии текста подсказки для строки состояния,
          <tt class="CLASSNAME">QAction</tt> будет использовать текст
          всплывающей подсказки.<br>
          <br>

          <p>Для других виджетов необходимо передать в функцию
          <tt class="METHODNAME">QToolTip::add()</tt>, третьим и
          четвертым аргументами, объект класса <tt class="CLASSNAME">QToolTipGroup</tt> и текст подсказки:</p>
          <pre class="SCREEN">  QToolTip::add(findButton, tr("Find next"), toolTipGroup, 
                tr("Find the next occurrence of the search text"));
      
</pre>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig16.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 16.1. Приложение, отображающее всплывающую
              подсказку и подсказку в строке состояния.</p>
            </div>
          </div><br>
          В визуальном построителе <span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span> текст подсказок можно
          задать через свойства виджета <tt class="VARNAME">toolTip</tt> и <tt class="VARNAME">statusTip</tt>.<br>
          <br>

          <p>В некоторых случаях возникает необходимость в
          предоставлении большего количества справочной информации о
          виджете, чем это может уместиться в подсказки. Например, у
          нас может появиться желание добавить более подробный текст
          описания для каждого из полей в сложном диалоге, не заставляя
          при этом пользователя вызывать отдельное окно с текстом
          справки. Идеальное решение в этом случае -- использование
          режима "What's This?" ("Что это?").
          Когда окно приложения переводится в этот режим, указатель
          мыши приобретает вид -- <span class="INLINEMEDIAOBJECT"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig16.0.1.png"></span>,
          и пользователь может щелкнуть мышью по любому элементу
          интерфейса, чтобы получить дополнительную справку. Чтобы
          перевести окно в режим "What's This?",
          пользователь должен либо щелкнуть по кнопке "?",
          расположенной в заголовке окна, либо нажать комбинацию клавиш
          <strong class="COMMAND">Shift+F1</strong>.</p>

          <p>Текст справки может быть зада вызовом <tt class="METHODNAME">QWhatsThis::add()</tt>. Например:</p>
          <pre class="SCREEN">  QWhatsThis::add(sourceLineEdit, 
      tr("&lt;img src=\"icon.png\"&gt;" 
      "&amp;nbsp;The meaning of the Source field depends on the " 
      "Type field:" 
      "&lt;ul&gt;" 
      "&lt;li&gt;&lt;b&gt;Books&lt;/b&gt; have a Publisher&lt;/li&gt;" 
      "&lt;li&gt;&lt;b&gt;Articles&lt;/b&gt; have a Journal name with volume and " 
      "issue number&lt;/li&gt;" 
      "&lt;li&gt;&lt;b&gt;Thesis&lt;/b&gt; have an Institution name and a " 
      "department name&lt;/li&gt;" 
      "&lt;/ul&gt;"));
      
</pre>Здесь, как и во многих других виджетах Qt, мы можем форматировать
текст подсказки с помощью HTML-тегов. В этом примере мы добавили
рисунок в текст подсказки (который описан в разделе
          <tt class="VARNAME">IMAGE</tt>, в файле <tt class="FILENAME">.pro</tt>), список сделали маркированным, а
          некоторые слова выделили жирным шрифтом. Теги HTML, которые
          поддерживает Qt, перечислены в описании класса <tt class="CLASSNAME">QStyleSheet</tt>.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig16.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 16.2. Диалог, отображающий текст подсказки
              "What's This?".</p>
            </div>
          </div><br>
          Текст подсказки "What's This?" может быть задан
          и для объектов <tt class="CLASSNAME">QAction</tt>:
          <pre class="SCREEN">openAct-&gt;setWhatsThis(tr("&lt;img src=open.png&gt;&amp;nbsp;" 
                         "Click this option to open an " 
                         "existing file."));
      
</pre>Текст подсказки будет отображаться после щелчка мышью по пунктам
меню или кнопкам на панели инструментов, когда окно будет находиться в
режиме "What's This?". В визуальном построителе
<span class="emphasis"><em class="EMPHASIS">Qt Designer</em></span>
текст справки можно задать через свойство <tt class="VARNAME">
          whatsThis</tt>.<br>
          <br>

          <p>Если приложение предусматривает переход в режим
          "What's This?", то общепринятым считается
          добавление в меню <strong class="COMMAND">Help</strong>
          пункта <strong class="COMMAND">What's This?</strong> и
          кнопки <strong class="COMMAND">What's This?</strong> на
          панель инструментов. Это может быть сделано за счет создания
          объекта <tt class="CLASSNAME">QAction</tt>, у которого сигнал
          <tt class="METHODNAME">activated()</tt> будет связан со
          слотом <tt class="METHODNAME">whatsThis()</tt> главного окна
          приложения.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="USINGQTEXTBROWSERASASIMPLEHELPENGINE"></a>16.2.
          Использование QTextBrowser для отображения текста
          справки.</h1>

          <p>Большие серьезные приложения могут содержать объем
          справочной информации, намного превышающий возможности
          всплывающих подсказок и даже подсказок типа "What's
          This?". Самое простое решение в этом случае -- создать
          обозреватель справочной системы. Приложение может открывать
          окно обозревателя справки при выборе пункта <strong class="COMMAND">Help</strong>, в меню <strong class="COMMAND">Help</strong>, или при нажатии на кнопку
          <strong class="COMMAND">Help</strong> в панели
          инструментов.</p>

          <p>В этом разделе мы рассмотрим простейший обозреватель
          справочной системы, внешний вид которого представлен на
          рисунке 16.3, и опишем, как его использовать в приложении.
          Для отображения текста справки используется <tt class="CLASSNAME">QTextBrowser</tt>, который может обрабатывать
          некоторые теги HTML и идеально подходит под заданные
          условия.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig16.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 16.3. Виджет <tt class="CLASSNAME">HelpBrowser</tt>.</p>
            </div>
          </div><br>
          Как обычно, начнем с заголовочного файла:
          <pre class="SCREEN">#include &lt;qwidget.h&gt; 

class QPushButton; 
class QTextBrowser; 

class HelpBrowser : public QWidget 
{ 
  Q_OBJECT 
public: 
  HelpBrowser(const QString &amp;path, const QString &amp;page, 
              QWidget *parent = 0, const char *name = 0); 
  
  static void showPage(const QString &amp;page); 
  
private slots: 
  void updateCaption(); 
  
private:
  QTextBrowser *textBrowser; 
  QPushButton *homeButton; 
  QPushButton *backButton; 
  QPushButton *closeButton; 
};
      
</pre><tt class="CLASSNAME">HelpBrowser</tt> имеет статическую функцию,
которая может вызываться из любого места в приложении. Она создает окно
обозревателя и показывает запрошенную страницу.<br>
          <br>

          <p>Теперь исходный код файла реализации:</p>
          <pre class="SCREEN">#include &lt;qapplication.h&gt; 
#include &lt;qlayout.h&gt; 
#include &lt;qpushbutton.h&gt; 
#include &lt;qtextbrowser.h&gt; 

#include "helpbrowser.h" 

HelpBrowser::HelpBrowser(const QString &amp;path, const QString &amp;page, 
                         QWidget *parent, const char *name) 
    : QWidget(parent, name, WGroupLeader | WDestructiveClose) 
{ 
  textBrowser = new QTextBrowser(this); 
  homeButton = new QPushButton(tr("&amp;Home"), this); 
  backButton = new QPushButton(tr("&amp;Back"), this); 
  closeButton = new QPushButton(tr("Close"), this); 
  closeButton-&gt;setAccel(tr("Esc")); 
  
  QVBoxLayout *mainLayout = new QVBoxLayout(this); 
  QHBoxLayout *buttonLayout = new QHBoxLayout(mainLayout); 
  buttonLayout-&gt;addWidget(homeButton); 
  buttonLayout-&gt;addWidget(backButton); 
  buttonLayout-&gt;addStretch(1); 
  buttonLayout-&gt;addWidget(closeButton); 
  mainLayout-&gt;addWidget(textBrowser);
  
  connect(homeButton, SIGNAL(clicked()), 
          textBrowser, SLOT(home())); 
  connect(backButton, SIGNAL(clicked()), 
          textBrowser, SLOT(backward())); 
  connect(closeButton, SIGNAL(clicked()), 
          this, SLOT(close())); 
  connect(textBrowser, SIGNAL(sourceChanged(const QString &amp;)), 
          this, SLOT(updateCaption())); 
  
  textBrowser-&gt;mimeSourceFactory()-&gt;addFilePath(path); 
  textBrowser-&gt;setSource(page); 
}
      
</pre>Размещение компонентов в окне более чем простое: ряд кнопок
находится над <tt class="CLASSNAME">QTextBrowser</tt>. Аргумент
<tt class="VARNAME">path</tt> -- это путь к каталогу, где находятся
файлы с текстом справки. Аргумент <tt class="VARNAME">page</tt> -- имя
файла справки, с необязательным названием темы (в терминах HTML --
anchor, или имя ссылки).<br>
          <br>

          <p>Мы передаем конструктору флаг <tt class="VARNAME">WGroupLeader</tt>, потому что окно <tt class="CLASSNAME">HelpBrowser</tt> может открываться из модальных
          диалогов. Обычно модальные диалоги не позволяют пользователю
          взаимодействовать с другими окнами приложения. Однако, в
          данном случае, после того как пользователь запросил помощь,
          он должен иметь возможность работать как с окном модального
          диалога, так и с окном обозревателя справочной системы. Флаг
          <tt class="CLASSNAME">WGroupLeader</tt> обеспечивает такую
          возможность.</p>
          <pre class="SCREEN">void HelpBrowser::updateCaption() 
{ 
  setCaption(tr("Help: %1").arg(textBrowser-&gt;documentTitle())); 
}
      
</pre>Всякий раз, при переходе на другую страницу, вызывается слот
<tt class="METHODNAME">updateCaption()</tt>. Функция
          <tt class="METHODNAME">documentTitle()</tt> возвращает текст,
          заданный в теге <tt class="METHODNAME">&lt;title&gt;</tt>.
          <pre class="SCREEN">void HelpBrowser::showPage(const QString &amp;page) 
{ 
  QString path = qApp-&gt;applicationDirPath() + "/doc"; 
  HelpBrowser *browser = new HelpBrowser(path, page); 
  browser-&gt;resize(500, 400); 
  browser-&gt;show(); 
}
      
</pre>В функции <tt class="METHODNAME">showPage()</tt> создается окно
обозревателя и затем выводится на экран. Окно будет уничтожено
автоматически, когда пользователь закроет его, поскольку в конструкторе
был установлен флаг <tt class="VARNAME">WDestructiveClose</tt>.<br>

          <br>

          <p>В данном примере мы исходим из предположения, что файлы
          справки находятся в подкаталоге <tt class="FILENAME">doc</tt>.</p>

          <p>Теперь можно вызвать обозреватель из приложения. Для
          этого, в главном окне приложения, мы создадим объект
          <tt class="CLASSNAME">QAction</tt> -- <strong class="COMMAND">Help</strong> и соединим его со слотом <tt class="METHODNAME">help()</tt>:</p>
          <pre class="SCREEN">void MainWindow::help() 
{ 
  HelpBrowser::showPage("index.html"); 
}
      
</pre>Мы полагаем, что основной файл справки называется
          <tt class="FILENAME">index.html</tt>. Чтобы вызвать
          обозреватель из диалога, нужно связать соответствующую кнопку
          <strong class="COMMAND">Help</strong> со слотом <tt class="METHODNAME">help()</tt>:
          <pre class="SCREEN">void EntryDialog::help() 
{ 
  HelpBrowser::showPage("dialogs.html#entrydialog"); 
}
      
</pre>Здесь мы обращаемся уже к другому файлу справки --
          <tt class="FILENAME">dialogs.html</tt> и выполняем переход к
          ссылке <tt class="FILENAME">entrydialog</tt>.<br>
          <br>

          <p>Еще одно место, откуда можно вызвать обозреватель
          справочной системы -- текст справки типа "What's
          This?". Для этого достаточно вставить в текст справки
          "What's This?" тег HTML <tt class="FILENAME">&lt;a href="..."&gt;</tt>.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig16.4.png"></p>

            <div class="CAPTION">
              <p>Рисунок 16.4. Текст справки "What's
              This?" со ссылкой на файл справки.</p>
            </div>
          </div><br>
          Чтобы такая гипертекстовая ссылка работала, мы должны
          использовать класс, производный от <tt class="CLASSNAME">QWhatsThis</tt>, который будет "знать",
          как вызвать обозреватель справочной системы. Для этого надо в
          классе-потомке перекрыть метод <tt class="METHODNAME">clicked()</tt>, в котором вызвать <tt class="METHODNAME">HelpBrowser:: showPage()</tt>. Ниже приводится
          определение класса:
          <pre class="SCREEN">class MyWhatsThis : public QWhatsThis 
{ 
public: 
  MyWhatsThis(QWidget *widget, const QString &amp;text);
   
  QString text(const QPoint &amp;point); 
  bool clicked(const QString &amp;page); 
  
private: 
  QString myText; 
};
      
</pre>Где <tt class="METHODNAME">text()</tt> и <tt class="METHODNAME">
          clicked()</tt> -- это методы предка, перекрываемые потомком.
          <pre class="SCREEN">MyWhatsThis::MyWhatsThis(QWidget *widget, const QString &amp;text) 
    : QWhatsThis(widget) 
{ 
  myText = text; 
}
      
</pre>Конструктор получает указатель на виджет и текст справки для
этого виджета. Мы передаем указатель на виджет базовому конструктору и
сохраняем текст справки в приватной переменной.
          <pre class="SCREEN">QString MyWhatsThis::text(const QPoint &amp;) 
{ 
  return myText; 
}
      
</pre>Функция <tt class="METHODNAME">text()</tt> возвращает текст
справки виджета, для заданных координат указателя мыши. Некоторые
виджеты могут возвращать разный текст справки, в зависимости от того,
где был произведен щелчок мышью, но в данном примере мы всегда будем
возвращать один и тот же текст.
          <pre class="SCREEN">bool MyWhatsThis::clicked(const QString &amp;page) 
{ 
  if (page.isEmpty()) { 
    return true; 
  } else { 
    HelpBrowser::showPage(page);
    return false; 
  } 
}
      
</pre>Функция <tt class="METHODNAME">clicked()</tt> вызывается в момент
щелчка мышью по виджету, когда окно находится в режиме "What's
This?". Если пользователь щелкает по гиперссылке, то функция
получит название страницы в аргументе <tt class="VARNAME">page</tt>. В
противном случае в <tt class="VARNAME">page</tt> будет пустая
строка.<br>
          <br>

          <p>Возвращаемое значение используется базовым классом
          <tt class="CLASSNAME">QWhatsThis</tt> для того, чтобы
          определить, что делать дальше -- скрыть (<tt class="VARNAME">true</tt>) подсказку "What's This?"
          или оставить ее видимой (<tt class="VARNAME">false</tt>). В
          данной ситуации мы хотим, чтобы текст "What's
          This?" оставался видимым на экране, поэтому возвращаем
          <tt class="VARNAME">false</tt>. Когда пользователь щелкает по
          любому другому месту в тексте "What's This?",
          мы возвращаем <tt class="VARNAME">true</tt>.</p>

          <p>Ниже показан пример использования класса <tt class="CLASSNAME">MyWhatsThis</tt>:</p>
          <pre class="SCREEN">  new MyWhatsThis(sourceLineEdit, 
      tr("&lt;img src=\"icon.png\"&gt;" 
      "&amp;nbsp;The meaning of the " 
      "&lt;a href=\"fields.html#source\"&gt;Source&lt;/a&gt; field depends on " 
      "the &lt;a href=\"fields.html#type\"&gt;Type&lt;/a&gt; field:" 
      "&lt;ul&gt;" 
      "&lt;li&gt;&lt;b&gt;Books&lt;/b&gt; have a Publisher&lt;/li&gt;" 
      "&lt;li&gt;&lt;b&gt;Articles&lt;/b&gt; have a Journal name with volume and " 
      "issue number&lt;/li&gt;" 
      "&lt;li&gt;&lt;b&gt;Thesis&lt;/b&gt; have an Institution name and a department " 
      "name&lt;/li&gt;" 
      "&lt;/ul&gt;"));
      
</pre>На этот раз, вместо вызова <tt class="METHODNAME">QWhatsThis::add()</tt>, мы создаем экземпляр класса
<tt class="CLASSNAME">MyWhatsThis</tt> для виджета, с текстом
подсказки. Теперь пользователь может щелкнуть по гипертекстовой ссылке
и вызвать обозреватель справочной системы.<br>
          <br>

          <p>Выглядит немного странно, так как мы создаем объект, но не
          связываем его с какой бы то ни было переменной. Но это только
          на первый взгляд, потому что Qt сама следит за создаваемыми
          объектами класса <tt class="CLASSNAME">QWhatsThis</tt> и
          удаляет их, когда необходимость в них отпадает.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="USINGQTASSISTANTFORPOWERFULONLINEHELP"></a>16.3.
          Использование Qt Assistant для отображения текста
          справки.</h1>

          <p><span class="emphasis"><em class="EMPHASIS">Qt
          Assistant</em></span> -- это приложение, которое вы можете
          свободно распространять совместно со своей программой,
          предоставляемое компанией Trolltech. Основные его достоинства
          -- поддержка индексации, поиск по все справочной системе и
          возможность поддержки нескольких наборов документации для
          различных приложений.</p>

          <p>Для использования <span class="emphasis"><em class="EMPHASIS">Qt Assistant</em></span> в своих приложениях,
          необходимо добавить некоторый код, который добавит свою
          справочную систему в базу <span class="emphasis"><em class="EMPHASIS">Qt Assistant</em></span>.</p>

          <p>Взаимодействие между приложением и <span class="emphasis"><em class="EMPHASIS">Qt Assistant</em></span>
          обеспечивает класс <tt class="CLASSNAME">QAssistantClient</tt>, размещенный в отдельной
          библиотеке. Чтобы связать приложение с этой библиотекой, надо
          добавить следующую строку в файл проекта <tt class="FILENAME">.pro</tt>:</p>
          <pre class="SCREEN">LIBS += -lqassistantclient
      
</pre>Создадим новый класс <tt class="CLASSNAME">HelpBrowser</tt>,
который будет использовать <span class="emphasis"><em class="EMPHASIS">
          Qt Assistant</em></span> для отображения текста справки.
          Определение класса:
          <pre class="SCREEN">#ifndef HELPBROWSER_H 
#define HELPBROWSER_H 

class QAssistantClient; 

class HelpBrowser 
{ 
public: 
  static void showPage(const QString &amp;page); 
  
private: 
  static QAssistantClient *assistant; 
}; 

#endif
      
</pre>И содержимое файла <tt class="FILENAME">helpbrowser.cpp</tt>:
          <pre class="SCREEN">#include &lt;qassistantclient.h&gt; 

#include "helpbrowser.h" 

QAssistantClient *HelpBrowser::assistant = 0; 

void HelpBrowser::showPage(const QString &amp;page) 
{ 
  if (!assistant) 
    assistant = new QAssistantClient(""); 
  assistant-&gt;showPage(page); 
}
      
</pre>Конструктор <tt class="CLASSNAME">QAssistantClient</tt> получает
в первом аргументе имя каталога, который используется для поиска
исполняемого файла утилиты <span class="emphasis"><em class="EMPHASIS">
          Qt Assistant</em></span>. Когда передается пустая строка, то
          поиск производится в каталогах, указанных в переменной
          окружения <tt class="VARNAME">PATH</tt>. Класс <tt class="CLASSNAME">QAssistantClient</tt> имеет свою собственную
          функцию <tt class="METHODNAME">showPage()</tt>, которая
          принимает имя HTML-файла, с необязательным именем ссылки --
          точь-в-точь как было сделано нами при создании класса
          <tt class="CLASSNAME">HelpBrowser</tt>, производного от
          класса <tt class="CLASSNAME">QTextBrowser</tt>.<br>
          <br>

          <p>Следующий шаг, который необходимо сделать -- сообщить
          <span class="emphasis"><em class="EMPHASIS">Qt
          Assistant</em></span>, где размещается документация к
          программе. Делается это путем создания профайла и файла
          <tt class="FILENAME">.dcf</tt>, который содержит все
          необходимые сведения о документации. Как это делается описано
          в сопроводительной документации к утилите <span class="emphasis"><em class="EMPHASIS">Qt Assistant</em></span>,
          поэтому здесь мы не будем дублировать эти сведения.</p>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER17"></a>Глава 17. Многопоточность.</h1>

        <p>Обычно, приложения с графическим интерфейсом исполняются в
        рамках одного потока. Если такое приложение начинает выполнять
        продолжительную по времени операцию, то возникает эффект
        "замораживания" интерфейса, который длится до тех
        пор, пока длительная операция не будет завершена. В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER7">Главе 7</a> был приведен один из вариантов решения
        этой проблемы. Другой вариант -- многопоточность.</p>

        <p>В многопоточных приложениях, обслуживание интерфейса
        производится в отдельном потоке, а обработка данных -- в другом
        (одном или нескольких) потоке. В результате приложение
        сохраняет возможность откликаться на действия пользователя даже
        во время интенсивной обработки данных. Еще одно преимущество
        многопоточности -- на многопроцессорных системах различные
        потоки могут выполняться на различных процессорах одновременно,
        что несомненно увеличивает скорость исполнения.</p>

        <p>В этой главе мы поговорим о классе <tt class="CLASSNAME">QThread</tt> и покажем, как синхронизировать потоки
        с помощью классов <tt class="CLASSNAME">QMutex, QSemaphore</tt>
        и <tt class="CLASSNAME">QWaitCondition</tt>. Затем коснемся
        темы взаимодействия между потоками и завершим главу
        перечислением классов Qt, которые могут использоваться за
        пределами главного потока приложения, где исполняется цикл
        обработки событий Qt.</p>

        <p>Многопоточность -- очень объемная тема. Ей посвящено
        огромное количество книг. Здесь мы будем исходить из
        предположения, что вы уже знакомы с основными принципами
        разработки многопоточных приложений, и все наше внимание
        сконцентрируем не на использовании многопоточности как таковой,
        а на основных положениях создания многопоточных
        Qt-приложений.</p>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="WORKINGWITHTHREADS"></a>17.1.
          Потоки.</h1>

          <p>Добавить несколько потоков в приложение, написанное с
          использованием библиотеки Qt, очень просто. Для этого нужно
          лишь создать дочерний класс от <tt class="CLASSNAME">QThread</tt> и перекрыть метод <tt class="METHODNAME">run()</tt>. В качестве примера мы напишем
          простой класс, потомок класса <tt class="CLASSNAME">QThread</tt>, который выводит текст на
          консоль.</p>
          <pre class="SCREEN">class Thread : public QThread 
{ 
public: 
  Thread(); 
  
  void setMessage(const QString &amp;message); 
  void run(); 
  void stop(); 
  
private: 
  QString messageStr; 
  volatile bool stopped; 
};
      
</pre>Этот класс перекрывает метод родителя <tt class="METHODNAME">
          run()</tt> и добавляет еще две функции: <tt class="METHODNAME">setMessage()</tt> и <tt class="METHODNAME">stop()</tt>.<br>
          <br>

          <p>Ключевое слово <tt class="VARNAME">volatile</tt>, которое
          присутствует в объявлении переменной <tt class="VARNAME">stopped</tt>, означает, что доступ к ней может
          производиться из других потоков и поэтому необходимо
          выполнять чтение значения переменной всякий раз, когда это
          необходимо. Если опустить этот спецификатор, компилятор может
          выполнить оптимизацию кода обращения к переменной, что в
          некоторых ситуациях приведет к неправильным результатам.</p>
          <pre class="SCREEN">Thread::Thread() 
{ 
  stopped = false; 
}
      
</pre>В конструкторе, переменной <tt class="VARNAME">stopped</tt>
присваивается значение <tt class="VARNAME">false</tt>.
          <pre class="SCREEN">void Thread::run() 
{ 
  while (!stopped) 
    cerr &lt;&lt; messageStr.ascii(); 
  stopped = false; 
  cerr &lt;&lt; endl; 
}
      
</pre>Функция <tt class="METHODNAME">run()</tt> предназначена для
запуска потока. Поток будет исполняться до тех пор, пока в переменную
<tt class="VARNAME">stopped</tt> не будет записано значение
          <tt class="VARNAME">true</tt>. В процессе исполнения потока,
          на консоль будет выводиться заданный текст сообщения. Поток
          завершит свою работу, как только функция <tt class="METHODNAME">run()</tt> вернет управление.
          <pre class="SCREEN">void Thread::stop() 
{ 
  stopped = true; 
}
      
</pre>Функция <tt class="METHODNAME">stop()</tt> записывает в
переменную <tt class="VARNAME">stopped</tt> значение
          <tt class="VARNAME">true</tt> и тем самым останавливает
          исполнение потока. Эта функция может быть вызвана из другого
          потока в любой момент времени. В данном примере мы исходим из
          предположения, что присваивание значения булевой переменной
          является атомарной (в смысле -- непрерываемой) операцией.
          Чуть ниже, в этом же разделе, мы покажем, как обеспечить
          атомарность операции присваивания, с помощью экземпляра
          класса <tt class="CLASSNAME">QMutex</tt>.<br>
          <br>

          <p>Класс <tt class="CLASSNAME">QThread</tt> имеет метод
          <tt class="METHODNAME">terminate()</tt>, который завершает
          работу потока. Однако мы не рекомендуем использовать его,
          поскольку этот метод может остановить поток в любой точке его
          исполнения, не давая ему возможность самому корректно
          завершить свою работу. Более безопасный способ остановки
          потока -- с помощью функции <tt class="METHODNAME">stop()</tt>, как это делается в нашем
          примере.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig17.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 17.1. Внешний вид приложения Threads.</p>
            </div>
          </div><br>
          Теперь напишем небольшое приложение, которое будет запускать
          два дополнительных потока -- A и B.
          <pre class="SCREEN">class ThreadForm : public QDialog 
{ 
  Q_OBJECT 
public: 
  ThreadForm(QWidget *parent = 0, const char *name = 0); 
  
protected: 
  void closeEvent(QCloseEvent *event); 
  
private slots: 
  void startOrStopThreadA(); 
  void startOrStopThreadB(); 
  
private: 
  Thread threadA; 
  Thread threadB; 
  QPushButton *threadAButton; 
  QPushButton *threadBButton; 
  QPushButton *quitButton; 
};
      
</pre>В классе <tt class="CLASSNAME">ThreadForm</tt> объявлены две
приватных переменных типа <tt class="CLASSNAME">Thread</tt> и несколько
кнопок, которыми выполняется управление приложением.
          <pre class="SCREEN">ThreadForm::ThreadForm(QWidget *parent, const char *name) 
    : QDialog(parent, name) 
{ 
  setCaption(tr("Threads")); 
  
  threadA.setMessage("A"); 
  threadB.setMessage("B"); 
  
  threadAButton = new QPushButton(tr("Start A"), this); 
  threadBButton = new QPushButton(tr("Start B"), this); 
  quitButton = new QPushButton(tr("Quit"), this); 
  quitButton-&gt;setDefault(true); 
  
  connect(threadAButton, SIGNAL(clicked()), 
          this, SLOT(startOrStopThreadA())); 
  connect(threadBButton, SIGNAL(clicked()), 
          this, SLOT(startOrStopThreadB()));
  connect(quitButton, SIGNAL(clicked()), 
          this, SLOT(close())); 
  ... 
}
      
</pre>В конструкторе формы, с помощью вызовов функций
          <tt class="METHODNAME">setMessage()</tt>, потокам назначается
          текст для вывода на консоль. Таким образом, поток A будет
          печатать букву "A", а поток B -- букву
          "B".
          <pre class="SCREEN">void ThreadForm::startOrStopThreadA() 
{ 
  if (threadA.running()) { 
    threadA.stop(); 
    threadAButton-&gt;setText(tr("Start A")); 
  } else { 
    threadA.start(); 
    threadAButton-&gt;setText(tr("Stop A")); 
  } 
}
      
</pre>Когда пользователь нажимает кнопку, которая управляет потоком A,
вызывается функция-слот <tt class="METHODNAME">startOrStopThreadA()</tt>. Она останавливает работу
потока, если он запущен, и запускает -- в противном случае. Кроме того,
функция так же изменяет надпись на кнопке.
          <pre class="SCREEN">void ThreadForm::startOrStopThreadB() 
{ 
  if (threadB.running()) { 
    threadB.stop(); 
    threadBButton-&gt;setText(tr("Start B")); 
  } else { 
    threadB.start(); 
    threadBButton-&gt;setText(tr("Stop B")); 
  } 
}
      
</pre>Код функции <tt class="METHODNAME">startOrStopThreadB()</tt>
практически один-в-один повторяет код функции <tt class="METHODNAME">
          startOrStopThreadA()</tt>.
          <pre class="SCREEN">void ThreadForm::closeEvent(QCloseEvent *event) 
{ 
  threadA.stop(); 
  threadB.stop(); 
  threadA.wait(); 
  threadB.wait(); 
  event-&gt;accept(); 
}
      
</pre>Если пользователь закрывает окно приложения, то потокам
посылается команда на останов, после чего программа ждет (с помощью
функции <tt class="METHODNAME">QThread::wait()</tt>), пока они не
завершат свою работу. Затем вызывается <tt class="METHODNAME">
          QCloseEvent:: accept()</tt>.<br>
          <br>

          <p>Для сборки приложения, необходимо добавить следующую
          строку в файл <tt class="FILENAME">.pro</tt>:</p>
          <pre class="SCREEN">CONFIG += thread
      
</pre>Она сообщает <tt class="FILENAME">qmake</tt> о том, что для
сборки приложения должна использоваться версия Qt, совместимая с
потоками. Чтобы собрать потоко-совместимую версию библиотеки Qt,
необходимо передать ключ <tt class="PARAMETER"><em>-thread</em></tt>
скрипту <tt class="FILENAME">configure</tt>, во время установки Qt в
Unix или Mac OS X. В Windows, библиотека Qt является потоко-совместимой
по-умолчанию. Для данного примера необходимо добавить еще и опцию
<tt class="PARAMETER"><em>console</em></tt>, поскольку необходимо
обеспечить вывод текста на консоль в операционной системе Windows:
          <pre class="SCREEN">win32:CONFIG += console
      
</pre>Теперь, если запустить приложение и нажать на кнопку
<strong class="COMMAND">Start A</strong>, на консоли будет печататься
последовательность символов "A". После нажатия на кнопку
<strong class="COMMAND">Start B</strong> последовательность символов
"A" будет перемежаться символами "B". После нажатия
на кнопку <strong class="COMMAND">Stop A</strong>, будут выводиться
одни символы "B".<br>
          <br>

          <p>Обычно в многопоточных приложениях возникает проблема
          синхронизации потоков. Для этих целей в Qt имеются классы
          <tt class="CLASSNAME">QMutex, QMutexLocker, QSemaphore</tt> и
          <tt class="CLASSNAME">QWaitCondition</tt>.</p>

          <p>Класс <tt class="CLASSNAME">QMutex</tt> являет собой
          средство защиты. С его помощью можно исключить возможность
          доступа к переменным или участкам кода из нескольких потоков
          одновременно. Класс имеет функцию <tt class="METHODNAME">lock()</tt>, которая "запирает"
          мьютекс. Если мьютекс не заперт, то текущий поток захватывает
          его и тут же "запирает", в противном случае, поток,
          который попытался захватить запертый мьютекс, блокируется до
          тех пор пока мьютекс не освободится. Когда функция <tt class="METHODNAME">lock()</tt> возвратит управление в поток, он
          станет держателем мьютекса до того момента, пока не будет
          вызвана функция <tt class="METHODNAME">unlock()</tt>. Кроме
          функции <tt class="METHODNAME">lock()</tt>, класс <tt class="CLASSNAME">QMutex</tt> имеет функцию <tt class="METHODNAME">tryLock()</tt>, которая возвращает управление
          потоку немедленно, даже если мьютекс уже "заперт"
          другим потоком.</p>

          <p>Для примере предположим, что необходимо защитить мьютексом
          переменную <tt class="VARNAME">stopped</tt>. Для этого нужно
          добавить новый член класса <tt class="CLASSNAME">Thread</tt>:</p>
          <pre class="SCREEN">  QMutex mutex;
      
</pre>Функция <tt class="METHODNAME">run()</tt> теперь будет выглядеть
так:
          <pre class="SCREEN">void Thread::run() 
{ 
  for (;;) { 
    mutex.lock(); 
    if (stopped) { 
      stopped = false; 
      mutex.unlock(); 
      break; 
    } 
    mutex.unlock(); 
    
    cerr &lt;&lt; messageStr.ascii(); 
  } 
  cerr &lt;&lt; endl; 
}
      
</pre>А функция <tt class="METHODNAME">stop()</tt> так:
          <pre class="SCREEN">void Thread::stop() 
{ 
  mutex.lock(); 
  stopped = true; 
  mutex.unlock(); 
}
      
</pre>В сложных функциях, особенно при использовании исключений C++,
легко можно ошибиться при выполнении последовательностей операций по
запиранию/отпиранию мьютексов. Поэтому, в состав Qt включен класс
<tt class="CLASSNAME">QMutexLocker</tt>, который значительно упрощает
работу с мьютексами. Конструктор класса <tt class="CLASSNAME">
          QMutexLocker</tt> принимает объект <tt class="CLASSNAME">QMutex</tt> в виде аргумента и запирает его.
          Деструктор класса <tt class="CLASSNAME">QMutexLocker</tt> --
          отпирает мьютекс. Например, с использованием класса
          <tt class="CLASSNAME">QMutexLocker</tt>, функция <tt class="METHODNAME">stop()</tt> могла бы быть переписана следующим
          образом:
          <pre class="SCREEN">void Thread::stop() 
{ 
  QMutexLocker locker(&amp;mutex); 
  stopped = true; 
}
      
</pre>Семафоры в Qt реализованы в виде класса <tt class="CLASSNAME">
          QSemaphore</tt>. Семафоры являются дальнейшим обобщением
          мьютексов и могут использоваться для защиты от одновременного
          доступа к нескольким идентичным ресурсам.<br>
          <br>

          <p>В следующей таблице приведено соответствие между
          <tt class="CLASSNAME">QSemaphore</tt> и <tt class="CLASSNAME">QMutex</tt>:</p>
          <pre class="SCREEN">      QSemaphore semaphore(1);     |      QMutex mutex; 
      semaphore++;                 |      mutex.lock(); 
      semaphore--;                 |      mutex.unlock(); 
      
</pre>Постфиксные операторы "++" и "--" захватывают
и отпускают один ресурс, доступ к которому защищен семафором. Аргумент
1, который передается конструктору, указывает, что семафор обслуживает
один единственный ресурс. Основное преимущество семафора состоит в том,
что с его помощью можно захватить сразу несколько ресурсов,
последовательно вызывая "++" несколько раз.<br>
          <br>

          <p>Типичное применение семафоров -- операции обмена данными
          (<tt class="VARNAME">DataSize</tt>) между потоками, с помощью
          общего циклического буфера некоторого объема (<tt class="VARNAME">BufferSize</tt>):</p>
          <pre class="SCREEN">  const int DataSize = 100000; 
  const int BufferSize = 4096; 
  char buffer[BufferSize];
      
</pre>Поток-источник пишет данные в буфер до тех пор, пока не заполнит
его и затем продолжает запись данных с начала буфера, затирая данные,
записанные ранее. Поток-приемник читает данные по мере их поступления.
Рисунок 17.2 иллистрирует процесс записи/чтения в/из буфер(а) размером
в 16 байт.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig17.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 17.2. Модель источник/приемник.</p>
            </div>
          </div><br>
          Потребность в синхронизации очевидна: если поток-источник
          будет писать данные слишком быстро, то он затрет данные,
          которые еще не прочитаны потоком-приемником, и наоборот, если
          поток-приемник будет читать слишком быстро, то он
          "обгонит" поток-источник и начнет считывать
          неверные данные.<br>
          <br>

          <p>Самое простое решение этих проблем -- поток-источник
          заполняет весь буфер целиком, затем ожидает, пока
          поток-приемник не прочитает его, и так далее. Однако, на
          многопроцессорных системах такой прием приведет к снижению
          производительности. Более гибкое решение -- позволить потокам
          работать с разными частями буфера одновременно.</p>

          <p>Как один из вариантов реализации подобного подхода --
          использовать два семафора:</p>
          <pre class="SCREEN">QSemaphore freeSpace(BufferSize); 
QSemaphore usedSpace(BufferSize);
      
</pre>Семафор <tt class="VARNAME">freeSpace</tt> управляет частью
буфера, которая заполняется потоком-источником, а семафор
          <tt class="VARNAME">usedSpace</tt> -- областью, которая
          доступна на чтение потоку-приемнику. Эти области не
          пересекаются между собой. Обе имеют размер <tt class="VARNAME">BufferSize</tt> (4096).<br>
          <br>

          <p>В данном случае каждый байт области считается отдельным
          ресурсом. В реальных приложениях часто используются более
          крупные единицы измерения (например 64-х или 256-ти байтные
          блоки), чтобы уменьшить количество обращений к семафорам.</p>
          <pre class="SCREEN">void acquire(QSemaphore &amp;semaphore) 
{ 
  semaphore++; 
}
      
</pre>Функция <tt class="METHODNAME">acquire()</tt> предпринимает
попытку захватить один ресурс (один байт в буфере). Для этих целей
класс <tt class="CLASSNAME">QSemaphore</tt> использует постфиксный
оператор "++", но в нашем конкретном случае более удобным
будет использовать функцию с именем <tt class="METHODNAME">acquire()</tt>.
          <pre class="SCREEN">void release(QSemaphore &amp;semaphore) 
{ 
  semaphore--; 
}
      
</pre>Аналогичным образом реализована функция <tt class="METHODNAME">
          release()</tt>, являющаяся синонимом постфиксного оператора
          "--".
          <pre class="SCREEN">void Producer::run() 
{ 
  for (int i = 0; i &lt; DataSize; ++i) { 
    acquire(freeSpace); 
    buffer[i % BufferSize] = "ACGT"[(uint)rand() % 4]; 
    release(usedSpace); 
  } 
}
      
</pre>Источник захватывает один "свободный" байт. Если буфер
заполнен данными, которые еще не прочитаны потоком-приемником, то вызов
<tt class="METHODNAME">acquire()</tt> заблокирует работу источника до
тех пор, пока приемник не начнет чтение данных. Как только байт будет
захвачен, в него записывается случайный символ ('A',
'C', 'G' или 'T'), после чего байт отпускается
как "используемый", благодаря этому он становится доступен
приемнику.
          <pre class="SCREEN">void Consumer::run() 
{ 
  for (int i = 0; i &lt; DataSize; ++i) { 
    acquire(usedSpace); 
    cerr &lt;&lt; buffer[i % BufferSize]; 
    release(freeSpace); 
  } 
  cerr &lt;&lt; endl; 
}
      
</pre>Приемник захватывает один "используемый" байт. Если в
буфере нет данных, доступных для чтения, то функция
          <tt class="METHODNAME">acquire()</tt> заблокирует работу
          приемника до тех пор, пока источник не запишет какие нибудь
          данные в буфер. Как только байт будет захвачен, символ
          выводится на консоль, после чего байт освобождается как
          "свободный", благодаря этому он становится доступен
          источнику.
          <pre class="SCREEN">int main() 
{ 
  usedSpace += BufferSize; 
  
  Producer producer; 
  Consumer consumer; 
  producer.start(); 
  consumer.start(); 
  producer.wait(); 
  consumer.wait(); 
  return 0; 
}
      
</pre>Функция <tt class="METHODNAME">main()</tt> захватывает все байты
как "используемые" (с помощью оператора "+=" класса
<tt class="CLASSNAME">QSemaphore</tt>), чтобы предотвратить
преждевременное чтение данных приемником. Затем запускается
поток-источник и вслед за ним -- поток приемник. В результате,
поток-источник будет записывать данные, а вслед за ним, поток-приемник
-- читать их.<br>
          <br>

          <p>После запуска программа будет выводить на консоль символы
          'A', 'C', 'G' и 'T' в
          случайном порядке. После того, как программа выведет 100 000
          символов, она завершит свою работу. Чтобы окончательно
          прояснить порядок работы потоков, попробуйте запретить вывод
          символов, принимаемых потоком-источником и выводите символ
          'P', когда источник записывает один байт в буфер, и
          символ 'c' -- когда поток-приемник читает один байт
          из буфера. Чтобы еще больше упростить понимание, можно
          уменьшить <tt class="VARNAME">DataSize</tt> и <tt class="VARNAME">BufferSize</tt>.</p>

          <p>Для случая, когда <tt class="VARNAME">DataSize == 10</tt>,
          а <tt class="VARNAME">BufferSize == 4</tt>, вполне возможен
          результат: <tt class="COMPUTEROUTPUT">PcPcPcPcPcPcPcPcPcPc</tt>. Он говорит о том,
          что поток-приемник читает данные из буфера по мере их
          поступления -- оба потока работают с одинаковой скоростью.
          Возможен вариант, когда поток-источник успевает заполнить
          буфер целиком, до того как поток-приемник начнет чтение:
          <tt class="COMPUTEROUTPUT">PPPPccccPPPPccccPPcc</tt>.
          Существует масса других вариантов. Семафоры предоставляют
          большую свободу выбора системному планировщику, который может
          "изучать" поведение потоков и выбирать для них
          наиболее оптимальную политику планирования.</p>

          <p>Еще один вариант синхронизации потоков может быть
          реализован на классах <tt class="CLASSNAME">QWaitCondition</tt> и <tt class="CLASSNAME">QMutex</tt>. Класс <tt class="CLASSNAME">QWaitCondition</tt> дает потоку возможность
          возобновлять работу других потоков, при наступлении
          некоторого состояния. Что позволяет более точно управлять
          потоками, чем это возможно только на одних мьютексах. Чтобы
          продемонстрировать это на примере, мы опять вернемся к связке
          источник-приемник и реализуем тот же самый обмен данными с
          помощью классов <tt class="CLASSNAME">QWaitCondition</tt> и
          <tt class="CLASSNAME">QMutex</tt>.</p>
          <pre class="SCREEN">const int DataSize = 100000; 
const int BufferSize = 4096; 
char buffer[BufferSize]; 

QWaitCondition bufferIsNotFull; 
QWaitCondition bufferIsNotEmpty; 
QMutex mutex; 
int usedSpace = 0;
      
</pre>В дополнение к буферу обмена, мы объявили два экземпляра класса
<tt class="CLASSNAME">QWaitCondition</tt>, один экземпляр
          <tt class="CLASSNAME">QMutex</tt> и одну переменную, которая
          хранит количество "используемых" байт.
          <pre class="SCREEN">void Producer::run() 
{ 
  for (int i = 0; i &lt; DataSize; ++i) { 
    mutex.lock(); 
    while (usedSpace == BufferSize) 
      bufferIsNotFull.wait(&amp;mutex); 
    buffer[i % BufferSize] = "ACGT"[(uint)rand() % 4]; 
    ++usedSpace; 
    bufferIsNotEmpty.wakeAll(); 
    mutex.unlock(); 
  } 
}
      
</pre>Работа потока-источника начинается с проверки -- не заполнен ли
буфер. Если буфер заполнен, то он ждет, пока не наступит состояние
"буфер не полон". Затем в буфер записывается один байт,
содержимое переменной <tt class="VARNAME">usedSpace</tt> увеличивается
на 1 и возобновляются ("пробуждаются") все потоки, которые
ожидают наступления состояния "буфер не пуст".<br>
          <br>

          <p>В данном примере мьютекс используется для предотвращения
          одновременного доступа к переменной <tt class="VARNAME">usedSpace</tt>. Функция <tt class="METHODNAME">QWaitCondition::wait()</tt> может принимать
          первым аргументом запертый мьютекс, который отпирается, перед
          блокировкой вызвавшего ее потока, и опять запирается, перед
          тем как функция вернет управление.</p>

          <p>В этом примере, цикл <tt class="METHODNAME">while</tt></p>
          <pre class="SCREEN">  while (usedSpace == BufferSize) 
    bufferIsNotFull.wait(&amp;mutex);
      
</pre>может быть заменен условным оператором:
          <pre class="SCREEN">  if (usedSpace == BufferSize) { 
    mutex.unlock(); 
    bufferIsNotFull.wait(); 
    mutex.lock(); 
  }
      
</pre>Однако такой вариант неприемлем для случая, когда одновременно
будут работать несколько потоков-источников, так как любой из
потоков-источников может захватить мьютекс после выхода из
          <tt class="METHODNAME">wait()</tt>, и сделать ложным условие
          "буфер не полон".
          <pre class="SCREEN">void Consumer::run() 
{ 
  for (int i = 0; i &lt; DataSize; ++i) { 
    mutex.lock(); 
    while (usedSpace == 0) 
      bufferIsNotEmpty.wait(&amp;mutex); 
    cerr &lt;&lt; buffer[i % BufferSize]; 
    --usedSpace; 
    bufferIsNotFull.wakeAll(); 
    mutex.unlock(); 
  } cerr &lt;&lt; endl; 
}
      
</pre>Поток-приемник являет собой полную противоположность
потоку-источнику. Он ожидает наступления состояния "буфер не
пуст" и пробуждает все потоки, которые ожидают наступления
состояния "буфер не полон".<br>
          <br>

          <p>Во всех наших примерах, потоки обращались к одним и тем же
          глобальным переменным. Но в некоторых случаях возникает
          необходимость хранить в глобальной переменной различные
          значения для различных потоков. Это часто называют как
          "механизм хранения локальных данных потока"
          (thread-local storage -- TLS). Добиться этого можно с помощью
          словаря, где в качестве ключа будет выступать числовой
          идентификатор потока (возвращаемый функцией <tt class="METHODNAME">QThread::currentThread()</tt>), но лучшее
          решение -- использовать специализированный класс <tt class="CLASSNAME">QThreadStorage&lt;T&gt;</tt>.</p>

          <p>Обычно экземпляр класса <tt class="CLASSNAME">QThreadStorage&lt;T&gt;</tt> используют в
          качестве буфера. При наличии отдельных буферов для каждого из
          потоков, отпадает необходимость в постоянном запирании,
          отпирании и, возможно, ожидании мьютекса. Например:</p>
          <pre class="SCREEN">QThreadStorage&lt;QMap&lt;int, double&gt; *&gt; cache; 

void insertIntoCache(int id, double value) 
{ 
  if (!cache.hasLocalData()) 
    cache.setLocalData(new QMap&lt;int, double&gt;); 
  cache.localData()-&gt;insert(id, value); 
} 

void removeFromCache(int id) 
{ 
  if (cache.hasLocalData()) 
    cache.localData()-&gt;remove(id); 
}
      
</pre>Переменная <tt class="VARNAME">cache</tt> хранит по одному
указателю на <tt class="CLASSNAME">QMap&lt;int, double&gt;</tt>, для
каждого из потоков. (Из-за ограничений, накладываемых некоторыми
компиляторам, шаблонный тип в <tt class="CLASSNAME">QThreadStorage&lt;T&gt;</tt> должен быть указателем.) При
первом обращении к буферу из некоторого потока, когда функция
          <tt class="METHODNAME">hasLocalData()</tt> возвращает
          <tt class="PARAMETER"><em>false</em></tt>, мы создаем
          экземпляр класса <tt class="CLASSNAME">QMap&lt;int,
          double&gt;</tt>.<br>
          <br>

          <p>В дополнение к буферам, класс <tt class="CLASSNAME">QThreadStorage&lt;T&gt;</tt> может использоваться
          для создания глобальных переменных, которые хранят код
          последней ошибки (подобных переменной <tt class="VARNAME">errno</tt>) и предотвращают взаимовлияние потоков
          друг на друга.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="COMMUNICATINGWITHTHEGUITHREAD"></a>17.2. Взаимодействие с
          главным потоком приложения.</h1>

          <p>На запуске программы, написанной с использованием
          библиотеки Qt, стартует главный поток приложения. Это
          единственный поток, в котором допускается создание экземпляра
          класса <tt class="CLASSNAME">QApplication</tt> и вызов его
          метода <tt class="METHODNAME">exec()</tt>. Всвязи с этим,
          главный поток приложения часто называют GUI-потоком. После
          вызова функции <tt class="METHODNAME">exec()</tt> этот поток
          либо ждет поступления события, либо обрабатывает какое нибудь
          событие.</p>

          <p>Главный поток может запускать другие потоки, с помощью
          экземпляров классов, производных от <tt class="CLASSNAME">QThread</tt>. Новые потоки могут обмениваться
          информацией между собой через глобальные переменные, с
          использованием мьютексов, семафоров или ожидая наступления
          определенного состояния. Но это совершенно не подходит для
          организации взаимодействий между главным и второстепенными
          потоками в приложении, поскольку вышеперечисленные методики
          могут блокировать главный поток, "замораживая" тем
          самым интерфейс с пользователем.</p>

          <p>Для этих целей обычно используется механизм событий Qt,
          который допускает создание нестандартных типов событий и их
          передачу через вызов метода <tt class="METHODNAME">QApplication::postEvent()</tt>. Кроме того,
          функция <tt class="METHODNAME">postEvent()</tt> является
          потоко-безопасной, поэтому она может использоваться для
          передачи событий в главный поток из любого другого
          потока.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig17.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 17.3. Внешний вид приложения Image Pro.</p>
            </div>
          </div><br>
          Принципы организации обмена событиями между потоками, мы
          будем рассматривать на примере приложения Image Pro. Оно
          предназначено для работы с изображениями и позволяет вращать
          их, изменять размеры и глубину цветопередачи. Длительные
          операции будут выполняться в дополнительном потоке, чтобы
          избежать блокировки главного цикла обработки событий
          приложения. Это особенно актуально при работе с большими
          изображениями. Второстепенный поток имеет список заданий, или
          "транзакций", которые необходимо выполнить и
          посылает события главному потоку, чтобы проинформировать его
          о ходе выполнения операции.
          <pre class="SCREEN">ImageWindow::ImageWindow(QWidget *parent, const char *name) 
    : QMainWindow(parent, name) 
{ 
  thread.setTargetWidget(this); 
  ... 
}
      
</pre>В конструкторе назначается виджет-получатель событий. События
второстепенного потока будут отправляться этому виджету. Переменная
<tt class="VARNAME">thread</tt> относится к классу <tt class="CLASSNAME">TransactionThread</tt>, который мы опишем чуть ниже.
          <pre class="SCREEN">void ImageWindow::flipHorizontally() 
{ 
  addTransaction(new FlipTransaction(Horizontal)); 
}
      
</pre>Слот <tt class="METHODNAME">flipHorizontally()</tt> создает
транзакцию "flip" ("отобразить") и регистрирует ее
вызовом функции <tt class="METHODNAME">addTransaction()</tt>.
Аналогичным образом реализованы функции <tt class="METHODNAME">
          flipVertical(), resizeImage(), convertTo32Bit(),
          convertTo8Bit()</tt> и <tt class="METHODNAME">convertTo1Bit()</tt>.
          <pre class="SCREEN">void ImageWindow::addTransaction(Transaction *transact) 
{ 
  thread.addTransaction(transact); 
  openAct-&gt;setEnabled(false); 
  saveAct-&gt;setEnabled(false); 
  saveAsAct-&gt;setEnabled(false); 
}
      
</pre>Функция <tt class="METHODNAME">addTransaction()</tt> добавляет
транзакцию в очередь заданий второстепенного потока и запрещает
операции <strong class="COMMAND">Open, Save</strong> и
          <strong class="COMMAND">Save As</strong> на время ее
          выполнения.
          <pre class="SCREEN">void ImageWindow::customEvent(QCustomEvent *event) 
{ 
  if ((int)event-&gt;type() == TransactionStart) { 
    TransactionStartEvent *startEvent = 
            (TransactionStartEvent *)event; 
    infoLabel-&gt;setText(startEvent-&gt;message); 
  } else if ((int)event-&gt;type() == AllTransactionsDone) { 
    openAct-&gt;setEnabled(true); 
    saveAct-&gt;setEnabled(true); 
    saveAsAct-&gt;setEnabled(true); 
    imageLabel-&gt;setPixmap(QPixmap(thread.image())); 
    infoLabel-&gt;setText(tr("Ready")); 
    modLabel-&gt;setText(tr("MOD")); 
    modified = true; 
    statusBar()-&gt;message(tr("Done"), 2000); 
  } else { 
    QMainWindow::customEvent(event); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">customEvent()</tt> объявлена в
классе <tt class="CLASSNAME">QObject</tt> и предназначена для обработки
нестандартных событий. Константы <tt class="VARNAME">TransactionStart</tt> и <tt class="VARNAME">AllTransactionsDone</tt> определены в <tt class="FILENAME">
          transactionthread.h</tt>, как:
          <pre class="SCREEN">  enum { TransactionStart = 1001, AllTransactionsDone = 1002 };
      
</pre>Стандартные события Qt имеют значения ниже 1000, поэтому более
высокие значения могут свободно использоваться для создания своих,
нестандартных событий.<br>
          <br>

          <p>Нестандартные события создаются как экземпляры класса
          <tt class="CLASSNAME">QCustomEvent</tt>, производного от
          <tt class="CLASSNAME">QEvent</tt>, которые, кроме типа
          события, могут хранить дополнительный указатель типа
          <tt class="CLASSNAME">void</tt>. Класс события <tt class="CLASSNAME">TransactionStart</tt> порожден от <tt class="CLASSNAME">QCustomEvent</tt> и имеет одну дополнительную
          переменную-член:</p>
          <pre class="SCREEN">class TransactionStartEvent : public QCustomEvent 
{ 
public: 
  TransactionStartEvent(); 
  
  QString message; 
}; 

TransactionStartEvent::TransactionStartEvent() 
    : QCustomEvent(TransactionStart) 
{ 
}
      
</pre>В конструкторе класса мы передаем константу <tt class="VARNAME">
          TransactionStart</tt> унаследованному конструктору,
          инициализируя таким образом тип события.<br>
          <br>

          <p>Теперь перейдем к классу <tt class="CLASSNAME">TransactionThread</tt>:</p>
          <pre class="SCREEN">class TransactionThread : public QThread 
{ 
public: 
  void run(); 
  void setTargetWidget(QWidget *widget); 
  void addTransaction(Transaction *transact); 
  void setImage(const QImage &amp;image); 
  QImage image(); 
  
private: 
  QWidget *targetWidget; 
  QMutex mutex; 
  QImage currentImage; 
  std::list&lt;Transaction *&gt; transactions; 
};
      
</pre>Класс <tt class="CLASSNAME">TransactionThread</tt> имеет список
заданий (транзакций), которые исполняются в порядке очередности
поступления.
          <pre class="SCREEN">void TransactionThread::addTransaction(Transaction *transact) 
{ 
  QMutexLocker locker(&amp;mutex); 
  transactions.push_back(transact); 
  if (!running()) 
    start(); 
}
      
</pre>Функция <tt class="METHODNAME">addTransaction()</tt> добавляет
новое задание в очередь транзакций и запускает поток на исполнение,
если он еще не запущен.
          <pre class="SCREEN">void TransactionThread::run() 
{ 
  Transaction *transact; 
  
  for (;;) { 
    mutex.lock(); 
    if (transactions.empty()) { 
      mutex.unlock(); 
      break; 
    } 
    QImage oldImage = currentImage; 
    transact = *transactions.begin(); 
    transactions.pop_front(); 
    mutex.unlock(); 
    
    TransactionStartEvent *event = new TransactionStartEvent; 
    event-&gt;message = transact-&gt;messageStr(); 
    QApplication::postEvent(targetWidget, event); 
    
    QImage newImage = transact-&gt;apply(oldImage); 
    delete transact; 
    
    mutex.lock(); 
    currentImage = newImage; 
    mutex.unlock(); 
  } 
  QApplication::postEvent(targetWidget, 
                          new QCustomEvent(AllTransactionsDone)); 
}
      
</pre>Функция <tt class="METHODNAME">run()</tt> обходит список заданий
и выполняет их (вызовом <tt class="METHODNAME">apply()</tt>). Доступ к
объектам <tt class="VARNAME">transactions</tt> и <tt class="VARNAME">
          currentImage</tt> осуществляется под защитой мьютекса.<br>
          <br>

          <p>Когда транзакция запускается, в приложение, выбранному
          виджету (<tt class="VARNAME">ImageWindow</tt>), посылается
          событие <tt class="VARNAME">TransactionStart</tt>. После
          выполнения всех транзакций -- событие <tt class="VARNAME">AllTransactionsDone</tt>.</p>
          <pre class="SCREEN">class Transaction 
{ 
public: 
  virtual QImage apply(const QImage &amp;image) = 0; 
  virtual QString messageStr() = 0; 
};
      
</pre>Класс <tt class="CLASSNAME">Transaction</tt> -- это абстрактный
класс, который служит основой для создания классов, выполняющих
определенные действия над изображением. В нашем примере, это
классы-потомки: <tt class="CLASSNAME">FlipTransaction,
ResizeTransaction</tt> и <tt class="CLASSNAME">ConvertDepthTransaction</tt>. Мы рассмотрим только
<tt class="CLASSNAME">FlipTransaction</tt>, остальные два класса
реализованы аналогичным образом.
          <pre class="SCREEN">class FlipTransaction : public Transaction 
{ 
public:
  FlipTransaction(Qt::Orientation orient); 
  
  QImage apply(const QImage &amp;image); 
  QString messageStr(); 
  
private: 
  Qt::Orientation orientation; 
};
      
</pre>Конструктору класса передается один аргумент, который определяет
направление (ориентацию) отражения (<tt class="VARNAME">Horizontal</tt>
или <tt class="VARNAME">Vertical</tt>).
          <pre class="SCREEN">QImage FlipTransaction::apply(const QImage &amp;image) 
{ 
  return image.mirror(orientation == Qt::Horizontal, 
                      orientation == Qt::Vertical); 
}
      
</pre>Для того, чтобы отразить изображение, функция
          <tt class="METHODNAME">apply()</tt> обращается к методу
          <tt class="METHODNAME">QImage::mirror()</tt> и возвращает
          полученный результат.
          <pre class="SCREEN">QString FlipTransaction::messageStr() 
{ 
  if (orientation == Qt::Horizontal) 
    return QObject::tr("Flipping image horizontally..."); 
  else 
    return QObject::tr("Flipping image vertically..."); 
}
      
</pre>Функция <tt class="METHODNAME">messageStr()</tt> возвращает текст
сообщения, которое будет отображаться в строке состояния приложения во
время выполнения транзакции. Эта функция вызывается из
          <tt class="METHODNAME">ImageWindow::customEvent()</tt>, в
          контексте главного потока приложения.<br>
          <br>

          <p>Для длительных операций можно предусмотреть передачу
          сведений о ходе выполнения. Для этого нужно создать
          дополнительное событие и с его помощью посылать приложению
          процент выполнения задания.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="USINGQTSCLASSESINNONGUITHREADS"></a>17.3. Работа с классами
          Qt вне главного потока.</h1>

          <p>Функция называется <span class="emphasis"><em class="EMPHASIS">потоко-безопасной</em></span> (<span class="emphasis"><em class="EMPHASIS">thread-safe</em></span>),
          когда она может свободно вызываться из нескольких потоков
          одновременно. Если две потоко-безопасные функции, вызываемые
          из разных потоков одновременно, работают с одними и теми же
          данными, то результат выполнения таких функций всегда
          предсказуем. Распространив это определение на классы можно
          сказать, что класс является потоко-безопасным, когда все его
          методы могут одновременно вызываться из нескольких потоков,
          без появления непредсказуемых побочных эффектов, даже если
          они взаимодействуют с оним и тем же объектом.</p>

          <p>Среди потоко-безопасных классов в Qt можно назвать:
          <tt class="CLASSNAME">QThread, QMutex, QMutexLocker,
          QSemaphore, QThreadStorage&lt;T&gt;</tt> и <tt class="CLASSNAME">QWaitCondition</tt>. Кроме того, следующие
          функции-члены являются потоко-безопасными: <tt class="METHODNAME">QApplication::postEvent(),
          QApplication::removePostedEvent(),
          QApplication::removePostedEvents()</tt> и <tt class="METHODNAME">QEventLoop::wakeUp()</tt>.</p>

          <p>Большинство невизуальных классов Qt соответствуют менее
          строгому требованию -- <span class="emphasis"><em class="EMPHASIS">реентерабельности</em></span>. Класс называется
          реентерабельным, если он допускает одновременное
          существование нескольких экземпляров в различных потоках.
          Однако, одновременный доступ к реентерабельным объектам из
          нескольких потоков может оказаться далеко не безопасен и
          потому должен выполняться под защитой мьютексов. Как правило,
          любой класс C++, который не использует глобальные или иные
          разделяемые данные, является реентерабельным.</p>

          <p>Класс <tt class="CLASSNAME">QObject</tt> --
          реентерабельный, но ни один из его потомков в Qt не является
          таковым. Как следствие -- мы не можем напрямую обращаться к
          виджетам вне контекста главного потока приложения. Если,
          скажем, нужно изменить текст в <tt class="CLASSNAME">QLabel</tt> из второстепенного потока, то
          необходимо послать нестандартное событие в главный поток,
          посредством которого изменить текст надписи.</p>

          <p>Операция удаления объекта <tt class="CLASSNAME">QObject</tt>, с помощью <tt class="METHODNAME">delete</tt>, не является реентерабельной.
          Поэтому, при необходимости удаления объекта <tt class="CLASSNAME">QObject</tt> из другого потока, нам придется
          вызвать метод <tt class="METHODNAME">QObject::deleteLater()</tt>, который посылает
          событие "deferred delete".</p>

          <p>В контексте любого потока допускается использование
          механизма сигналов и слотов. При выдаче сигнала, связанный с
          ним слот исполняется в контексте того же потока, а не в
          потоке, где был создан объект-приемник. Таким образом сигналы
          и слоты не могут использоваться для организации
          взаимодействий между потоками.</p>

          <p>Класс <tt class="CLASSNAME">QTimer</tt>, и классы для
          работы с сетью <tt class="CLASSNAME">QFtp, QHttp,
          QSocket</tt> и <tt class="CLASSNAME">QSocketNotifier</tt>,
          целиком зависят от цикла обработки событий, поэтому они не
          могут использоваться за пределами главного потока.
          Единственный сетевой класс, который не зависит от цикла
          обработки событий -- это <tt class="CLASSNAME">QSocketDevice</tt>, являющийся
          "оберткой" вокруг платформо-зависимого сетевого
          API. Некоторые программисты считают, что использование
          <tt class="CLASSNAME">QSocketDevice</tt> в синхронном режиме,
          вне контекста главного потока, дает более простой код, нежели
          использование <tt class="CLASSNAME">QSocket</tt> (который
          работает асинхронно), а благодаря работе вне главного потока
          -- он не блокирует цикл обработки событий.</p>

          <p>Модули SQL и OpenGL так же могут использоваться в
          многопоточных приложениях, но имеют свои собственные
          ограничения, которые отличаются от системы к системе. За
          более подробной информацией обращайтесь по адресу: <a href="http://doc.trolltech.com/3.2/sql-driver.html" target="_top">http://doc.trolltech.com/3.2/sql-driver.html</a>, а
             так же к статье "Glimpsing the Third Dimension",
             в ежеквартальнике <span class="emphasis"><em class="EMPHASIS">Qt Quarterly</em></span>: <a href="http://doc.trolltech.com/qq/qq06-glimpsing.html" target="_top">http://doc.trolltech.com/qq/qq06-glimpsing.html</a>.</p>

          <p>Многие из невизуальных классов Qt, включая <tt class="CLASSNAME">QImage, QString</tt> и другие, используют явные и
          неявные методы оптимизации, связанные с разделением данных
          между объектами. Эти классы являются реентерабельными, за
          исключением конструкторов копирования и операторов
          присваивания. Когда создается копия объекта, то копируются
          только указатели на данные. Это может привести к
          непредсказуемым последствиям, если копии объекта попытаются
          одновременно, из нескольких потоков, изменить данные. В
          подобных ситуациях можно прибегнуть к услугам класса
          <tt class="CLASSNAME">QDeepCopy&lt;T&gt;</tt>, например:</p>
          <pre class="SCREEN">QString password; 
QMutex mutex; 
  
void setPassword(const QString &amp;str) 
{ 
  mutex.lock(); 
  password = QDeepCopy&lt;QString&gt;(str); 
  mutex.unlock(); 
}
      
</pre>Возможно, Qt 4 будет иметь более широкую поддержку потоков. Так,
среди всего прочего ожидается, что механизм сигналов и слотов будет
расширен до поддержки установления связей через границы потоков, и
позволит отказаться от необходимости создания нестандартных событий для
взаимодействия с главным потоком. Ожидается так же, что невизуальные
классы, подобные <tt class="CLASSNAME">QSocket</tt> и
          <tt class="CLASSNAME">QTimer</tt>, смогут использоваться вне
          контекста главного потока, и что необходимость в
          использовании класса <tt class="CLASSNAME">QDeepCopy&lt;T&gt;</tt> отпадет.
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="CHAPTER18"></a>Глава 18. Платформо-зависимые
        особенности.</h1>

        <p>В этой главе будут рассмотрены некоторые из
        платформо-зависимых особенностей библиотеки Qt. Начнем с
        описания доступа к системному API: Win32 -- для Windows, Core
        Graphics -- для Mac OS X и Xlib -- для X11. Затем перейдем к
        рассмотрению расширения ActiveQt и покажем, как добавить
        поддержку ActiveX в свои приложения, для платформы Windows. В
        последнем разделе главы опишем, как можно добиться
        взаимодействия приложения с менеджером сессии на платформе
        X11.</p>

        <p>Помимо расширений, представленных здесь, в состав версии Qt
        Enterprise Edition включено расширение Qt/Motif, которое
        облегчает миграцию приложений от Motif и Xt -- к Qt.
        Аналогичное расширение, для Tcl/Tk приложений предоставляет
        froglogic, и конвертер ресурсов Microsoft Windows --
        Klaralvdalens Datakonsult. Для разработчиков устройств,
        Trolltech предоставляет среду исполнения приложений -- Qtopia.
        За дополнительной информацией обращайтесь по адресам:</p>

        <ul>
          <li>
            <p><a href="http://doc.trolltech.com/3.2/motif-extension.html" target="_top">http://doc.trolltech.com/3.2/motif-extension.html</a></p>
          </li>

          <li>
            <p><a href="http://www.froglogic.com/" target="_top">http://www.froglogic.com/</a></p>
          </li>

          <li>
            <p><a href="http://www.klaralvdalens-datakonsult.se/?page=products%E2%8A%82=knut" target="_top">http://www.klaralvdalens-datakonsult.se/?page=products=knut</a></p>
          </li>

          <li>
            <p><a href="http://www.trolltech.com/products/qtopia/" target="_top">http://www.trolltech.com/products/qtopia/</a></p>
          </li>
        </ul><br>
        <br>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="INTERFACINGWITHNATIVEAPIS"></a>18.1. Взаимодействие с API
          операционной системы.</h1>

          <p>Qt предоставляет достаточно мощный API, которого вполне
          достаточно для большинства приложений на любых платформах. Но
          в некоторых случаях невозможно обойтись без обращения к
          средствам, предоставляемым самой операционной системой. В
          этом разделе мы покажем, как можно организовать
          взаимодействие приложений с API операционной системы для
          выполнения специфических задач.</p>

          <p>На всех, поддерживаемых библиотекой Qt, платформах, класс
          <tt class="CLASSNAME">QWidget</tt> реализует функцию
          <tt class="METHODNAME">winId()</tt>, которая возвращает
          числовой идентификатор окна (<tt class="VARNAME">HWND</tt> --
          в терминах Windows). Коме того, <tt class="CLASSNAME">QWidget</tt> предоставляет статическую функцию
          <tt class="METHODNAME">find()</tt>, которая возвращает
          <tt class="CLASSNAME">QWidget</tt> по заданному
          идентификатору окна. Этот идентификатор может быть передан
          функциям API операционной системы для достижения эффектов,
          которые зависят от платформы. Например, следующий код
          использует <tt class="METHODNAME">winId()</tt>, чтобы
          добиться эффекта полупрозрачности, при отображении
          визуального компонента <tt class="CLASSNAME">QLabel</tt> в
          Mac OS X, используя для этого функции графического ядра
          "Core Graphics". <a name="AEN7951" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#FTN.AEN7951"><span class="footnote">[9]</span></a></p>
          <pre class="SCREEN">#include &lt;qapplication.h&gt; 
#include &lt;qlabel.h&gt; 
#include &lt;qt_mac.h&gt; 

int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  QLabel *label = new QLabel("Hello Qt!", 0); 
  app.setMainWidget(label); 
  
  CGSWindowRef winRef = 
      GetNativeWindowFromWindowRef((WindowRef)label-&gt;winId()); 
  CGSSetWindowAlpha(_CGSDefaultConnection(), winRef, 0.5); 
  
  label-&gt;show(); 
  return app.exec(); 
}
      
</pre>Следующий код добивается того же самого эффекта на платформе
Windows, используя для этого Win32 API:
          <pre class="SCREEN">#define _WIN32_WINNT 0x0501 

#include &lt;qapplication.h&gt; 
#include &lt;qt_windows.h&gt; 

int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  QLabel *label = new QLabel("Hello Qt!", 0); 
  app.setMainWidget(label); 
  
  int exstyle = GetWindowLong(label-&gt;winId(), GWL_EXSTYLE); 
  exstyle |= WS_EX_LAYERED; 
  SetWindowLong(label-&gt;winId(), GWL_EXSTYLE, exstyle); 
  SetLayeredWindowAttributes(label-&gt;winId(), 0, 128, 
                             LWA_ALPHA); 
  
  label-&gt;show(); 
  return app.exec(); 
}
      
</pre>Этот код будет корректно работать в среде Windows 2000/XP. Если
вы желаете собрать и запустить приложение в более ранних версиях
Windows, которые не поддерживают полупрозрачность, вам придется
использовать библиотеку <tt class="CLASSNAME">QLibrary</tt>, которая
определяет функцию <tt class="METHODNAME">SetLayeredWindowAttributes</tt> во время исполнения, а не
во время сборки:
          <pre class="SCREEN">typedef BOOL (__stdcall *PSetLayeredWindowAttributes) 
        (HWND, COLORREF, BYTE, DWORD); 
PSetLayeredWindowAttributes pSetLayeredWindowAttributes = 
        (PSetLayeredWindowAttributes) QLibrary::resolve("user32", 
                "SetLayeredWindowAttributes");

  if (pSetLayeredWindowAttributes) { 
    int exstyle = GetWindowLong(label-&gt;winId(), GWL_EXSTYLE); 
    exstyle |= WS_EX_LAYERED; 
    SetWindowLong(label-&gt;winId(), GWL_EXSTYLE, exstyle); 
    pSetLayeredWindowAttributes(label-&gt;winId(), 0, 128, 
                                LWA_ALPHA); 
}
      
</pre>Qt/Windows использует такой подход, чтобы гарантировать
возможность использования расширенных особенностей, таких как поддержка
Unicode и преобразования шрифтов, везде, где это возможно, допуская при
этом возможность работы приложений на старых версиях Windows.<br>

          <br>

          <p>В X11 нет стандартного способа добиться эффекта
          полупрозрачности. Однако, в этой среде у нас есть возможность
          изменить свойства окна:</p>
          <pre class="SCREEN">  Atom atom = XInternAtom(win-&gt;x11Display(), "MY_PROPERTY", False); 
  long data = 1; 
  XChangeProperty(win-&gt;x11Display(), win-&gt;winId(), atom, atom, 
                  32, PropModeReplace, (unsigned char *)&amp;data, 1);
      
</pre>Qt/Embedded отличается от всех остальных версий Qt, где все это
реализуется прямо поверх буфера изображений (frame buffer) Linux, без
помощи промежуточного API. Она так же предоставляет свою собственную
оконную систему -- QWS. За дополнительной информацией по Qt/Embedded
обращайтесь по адресам: <a href="http://www.trolltech.com/products/embedded/" target="_top">http://www.trolltech.com/products/embedded/</a> и
               <a href="http://doc.trolltech.com/3.2/winsystem.html" target="_top">http://doc.trolltech.com/3.2/winsystem.html</a>.<br>
          <br>

          <p>При необходимости, можно использовать платформо-зависимые
          особенности не в ущерб переносимости, заключая специфический
          код в условные операторы препроцессора <tt class="METHODNAME">#if</tt> и <tt class="METHODNAME">#endif</tt>.
          Например:</p>
          <pre class="SCREEN">#if defined(Q_WS_MAC) 
  CGSWindowRef winRef = 
      GetNativeWindowFromWindowRef((WindowRef)label-&gt;winId()); 
  CGSSetWindowAlpha(_CGSDefaultConnection(), winRef, 0.5); 
#endif
      
</pre>Для каждой из платформ, Qt определяет один из следующих символов:
<tt class="VARNAME">Q_WS_WIN, Q_WS_X11, Q_WS_MAC</tt> или
          <tt class="VARNAME">Q_WS_QWS</tt>. Перед обращением к любому
          из них, исходный код приложения должен подключить хотя бы
          один заголовочный файл библиотеки. Кроме того, Qt
          предоставляет следующие символы препроцессора, для
          определения типа операционной системы:

          <div class="INFORMALTABLE">
            <a name="AEN7968"></a>

            <table border="1" class="CALSTABLE" cellspacing="0">
              <tbody style="background:#F5F5F5; color:black">
                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_WIN32</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_DGUX</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_LINUX</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_QNX6</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_WIN64</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_DYNIX</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_LYNX</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_RELIANT</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_CYGWIN</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_FREEBSD</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_NETBSD</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_SCO</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_MAC</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_HPUX</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_HPUX</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_SOLARIS</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_AIX</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_HURD</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_OSF</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_ULTRIX</p>
                      </li>
                    </ul>
                  </td>
                </tr>

                <tr>
                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_BSDI</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_IRIX</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_QNX</p>
                      </li>
                    </ul>
                  </td>

                  <td width="200" align="left" valign="top">
                    <ul>
                      <li>
                        <p>Q_OS_UNIXWARE</p>
                      </li>
                    </ul>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>Для большего удобства, Qt определяет символ Q_OS_WIN
          для Win32 и Win64, и Q_OS_UNIX для всех Unix-подобных систем,
          включая Mac OS X. Для уточнения номера версии операционной
          системы, во время исполнения, можно воспользоваться функциями
          <tt class="METHODNAME">QApplication::winVersion()</tt> (95,
          98 и т.д.) и <tt class="METHODNAME">QApplication::macVersion()</tt> (10.0, 10.1 и
          т.д.).<br>
          <br>

          <p>Некоторые классы визуальных компонентов предоставляют
          платформозависимую функцию <tt class="METHODNAME">handle()</tt>. На рисунке 18.1 перечислены типы
          значений, возвращаемых функцией <tt class="METHODNAME">handle()</tt>, в зависимости от типа
          платформы.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig18.1.png"></p>

            <div class="CAPTION">
              <p>Рисунок 18.1. Типы результата, возвращаемого функцией
              <tt class="METHODNAME">handle()</tt>.</p>
            </div>
          </div><br>
          <br>
          <br>

          <p>Некоторые классы, такие как <tt class="CLASSNAME">QWidget,
          QPixmap, QPrinter</tt> и <tt class="CLASSNAME">QPicture</tt>,
          ведут свою родословную от класса <tt class="CLASSNAME">QPaintDevice</tt>. В X11 и Mac OS X, <tt class="METHODNAME">handle()</tt> означает то же самое самое, что и
          <tt class="METHODNAME">winId()</tt> класса <tt class="CLASSNAME">QWidget</tt>. В Windows функция <tt class="METHODNAME">handle()</tt> возвращает контекст устройства, в
          то время как <tt class="METHODNAME">winId()</tt> --
          дескриптор окна. Похожим образом, функция <tt class="METHODNAME">hbm()</tt>, класса <tt class="CLASSNAME">QPixmap</tt>, в среде Windows, возвращает
          дескриптор растра (<tt class="VARNAME">HBITMAP</tt>).</p>

          <p>В X11, класс <tt class="CLASSNAME">QPaintDevice</tt>
          предоставляет множество функций, которые возвращают различные
          указатели и дескрипторы, включая <tt class="VARNAME">x11Display()</tt> и <tt class="VARNAME">x11Screen()</tt>. Они могут использоваться для
          настройки графического контекста X11 в объектах <tt class="CLASSNAME">QWidget</tt> или <tt class="CLASSNAME">QPixmap</tt>.</p>

          <p>Нередки ситуации, когда приложения, написанные с
          использованием библиотеки Qt, должны получить доступ к
          низкоуровневым событиям (XEvents -- в X11, MSG -- в Windows и
          Mac OS X, QWSEvents -- в Qt/Embedded) прежде, чем они будут
          преобразованы в <tt class="CLASSNAME">QEvent</tt>. Добиться
          этого можно, породив свой класс от <tt class="CLASSNAME">QApplication</tt> и перекрыв соответствующие
          фильтры событий: <tt class="METHODNAME">winEventFilter(),
          x11EventFilter(), macEventFilter()</tt> и <tt class="METHODNAME">qwsEventFilter()</tt>.</p>

          <p>Можно получить доступ к специфическим для платформы
          событиям, посылаемым заданному виджету, перекрыв одну из
          функций: <tt class="METHODNAME">winEvent(), x11Event(),
          macEvent()</tt> или <tt class="METHODNAME">qwsEvent()</tt>.
          Этот прием может оказаться единственно возможным, для
          обработки событий, которые обычно игнорируются библиотекой,
          например: событий от джойстика.</p>

          <p>За дополнительной информацией, касающейся
          платформо-зависимых проблем, включая вопросы программирования
          с использованием Qt/Embedded и распространения готовых
          приложений для различных платформ, обращайтесь по адресу:
          <a href="http://doc.trolltech.com/3.2/winsystem.html" target="_top">http://doc.trolltech.com/3.2/winsystem.html</a>.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="USINGACTIVEX"></a>18.2.
          ActiveX.</h1>

          <p>Технология Microsoft ActiveX позволяет приложениям
          включать интерфейсные компоненты, предоставляемые другими
          приложениями и библиотеками. Она базируется на технологии
          Microsoft COM и определяет один набор интерфейсов для
          приложений, которые которые используют внешние компоненты, и
          другой набор -- для приложений и библиотек, которые могут
          предоставить эти компоненты.</p>

          <p>Версия библиотеки Qt/Windows Enterprise Edition, включает
          в себя ActiveQt framework, которая позволяет объединить
          ActiveX и Qt. ActiveQt состоит из двух модулей:</p>

          <ul>
            <li>
              <p><span class="emphasis"><em class="EMPHASIS">QAxContainer</em></span> -- который позволяет
              использовать COM-объекты и встраивать в приложение
              элементы управления ActiveX.</p>
            </li>

            <li>
              <p><span class="emphasis"><em class="EMPHASIS">QAxServer</em></span> -- позволяет
              экспортировать наши собственные COM-объекты и элементы
              управления ActiveX, написанные с помощью Qt.</p>
            </li>
          </ul>В нашем первом примере мы встроим Windows Media Player в
          приложение Qt, используя для этого <span class="emphasis"><em class="EMPHASIS">QAxContainer</em></span>.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig18.2.png"></p>

            <div class="CAPTION">
              <p>Рисунок 18.2. Внешний вид приложения Media Player.</p>
            </div>
          </div><br>
          Главное окно приложения относится к классу <tt class="CLASSNAME">PlayerWindow</tt>:
          <pre class="SCREEN">class PlayerWindow : public QWidget 
{ 
  Q_OBJECT 
  Q_ENUMS(ReadyStateConstants) 
public: 
  enum PlayStateConstants { Stopped = 0, Paused = 1, Playing = 2 }; 
  enum ReadyStateConstants { Uninitialized = 0, Loading = 1, 
                             Interactive = 3, Complete = 4 }; 
                             
  PlayerWindow(QWidget *parent = 0, const char *name = 0); 
  
protected: 
  void timerEvent(QTimerEvent *event);
  
private slots: 
  void onPlayStateChange(int oldState, int newState); 
  void onReadyStateChange(ReadyStateConstants readyState); 
  void onPositionChange(double oldPos, double newPos); 
  void sliderValueChanged(int newValue); 
  void openFile();
      
</pre>Класс <tt class="CLASSNAME">PlayerWindow</tt> порожден от класса
<tt class="CLASSNAME">QWidget</tt>. Макрос <tt class="VARNAME">
          Q_ENUMS()</tt> используется для того, чтобы сообщить утилите
          <tt class="USERINPUT"><strong>moc</strong></tt> о том, что
          тип <tt class="CLASSNAME">ReadyStateConstants</tt>,
          используемый слотом <tt class="METHODNAME">onReadyStateChange()</tt>, относится к
          перечислениям.
          <pre class="SCREEN">private: 
  QAxWidget *wmp; 
  QToolButton *openButton; 
  QToolButton *playPauseButton; 
  QToolButton *stopButton; 
  QSlider *seekSlider; 
  QString fileFilters; 
  int updateTimer; 
};
      
</pre>В приватной секции объявлена переменная-член типа
          <tt class="CLASSNAME">QAxWidget *</tt>.
          <pre class="SCREEN">PlayerWindow::PlayerWindow(QWidget *parent, const char *name) 
    : QWidget(parent, name) 
{ 
  ...
  wmp = new QAxWidget(this); 
  wmp-&gt;setControl("{22D6F312-B0F6-11D0-94AB-0080C74C7E95}");
      
</pre>В конструкторе создается объект <tt class="CLASSNAME">QAxWidget</tt>, в который будет внедрен элемент управления
ActiveX -- Windows Media Player. Модуль <span class="emphasis">
          <em class="EMPHASIS">QAxContainer</em></span> содержит три
          класса: <tt class="CLASSNAME">QAxObject</tt> --
          инкапсулирующий COM-объект, <tt class="CLASSNAME">QAxWidget</tt> -- инкапсулирующий элемент ActiveX
          и <tt class="CLASSNAME">QAxBase</tt>, реализующий базовую
          функциональность классов <tt class="CLASSNAME">QAxObject</tt>
          и <tt class="CLASSNAME">QAxWidget</tt>.

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig18.3.png"></p>

            <div class="CAPTION">
              <p>Рисунок 18.3. Дерево наследования в модуле
              <span class="emphasis"><em class="EMPHASIS">QAxContainer</em></span>.</p>
            </div>
          </div><br>
          Методу <tt class="METHODNAME">setControl()</tt>, объекта
          <tt class="CLASSNAME">QAxWidget</tt>, передается
          идентификатор (GUID) элемента управления Windows Media Player
          6.4. С его помощью будет создан экземпляр требуемого
          компонента, после чего все свойства, события и методы
          элемента ActiveX станут доступны как обычные свойства,
          сигналы и слоты Qt объекта <tt class="CLASSNAME">QAxWidget</tt>.<br>
          <br>

          <p>Типы COM автоматически конвертируются в соответствующие
          типы Qt, в соответствии с таблицей, приведенной на рисунке
          18.4. Так например, входной параметр типа <tt class="CLASSNAME">VARIANT_BOOL</tt> преобразуется в тип <tt class="CLASSNAME">bool</tt>, а выходной <tt class="CLASSNAME">VARIANT_BOOL</tt> -- в <tt class="CLASSNAME">bool
          &amp;</tt>. Если результатом преобразования является класс Qt
          (<tt class="CLASSNAME">QString, QDateTime</tt> и т.п.), то
          входной параметр получает тип константной ссылки на этот
          класс (например <tt class="CLASSNAME">const QString
          &amp;</tt>).</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig18.4.png"></p>

            <div class="CAPTION">
              <p>Рисунок 18.4. Отношения между типами COM и Qt.</p>
            </div>
          </div><br>
          Чтобы получить список всех свойств, сигналов и слотов,
          доступных в <tt class="CLASSNAME">QAxObject</tt> или
          <tt class="CLASSNAME">QAxWidget</tt>, вызовите <tt class="METHODNAME">generateDocumentation()</tt> или воспользуйтесь
          утилитой командной строки <tt class="FILENAME">dumpdoc</tt>,
          размещенной в подкаталоге <tt class="FILENAME">extensions\activeqt\example</tt>.
          <pre class="SCREEN">  wmp-&gt;setProperty("ShowControls", QVariant(false, 0)); 
  wmp-&gt;setSizePolicy(QSizePolicy::Expanding, 
                     QSizePolicy::Expanding); 
  connect(wmp, SIGNAL(PlayStateChange(int, int)), 
          this, SLOT(onPlayStateChange(int, int))); 
  connect(wmp, SIGNAL(ReadyStateChange(ReadyStateConstants)), 
          this, SLOT(onReadyStateChange(ReadyStateConstants))); 
  connect(wmp, SIGNAL(PositionChange(double, double)), 
          this, SLOT(onPositionChange(double, double)));
      
</pre>Вслед за функцией <tt class="METHODNAME">setControl()</tt>, в
конструкторе <tt class="METHODNAME">PlayerWindow</tt>, вызывается
<tt class="METHODNAME">setProperty()</tt>, чтобы записать значение
<tt class="METHODNAME">false</tt> в свойство <tt class="METHODNAME">
          ShowControls</tt> плеера, поскольку приложение предоставляет
          свои элементы управления. Функция <tt class="METHODNAME">setProperty()</tt> реализована в классе
          <tt class="CLASSNAME">QObject</tt> и может использоваться для
          установки значений свойств как в COM-объектах, так и в
          обычных классах Qt. Ее второй аргумент имеет тип <tt class="CLASSNAME">QVariant</tt>. Поскольку некоторые компиляторы
          C++ до сих пор не поддерживают должным образом тип <tt class="CLASSNAME">bool</tt>, приходится передавать конструктору
          <tt class="CLASSNAME">QVariant</tt> заготовку типа <tt class="CLASSNAME">int</tt>. Для типов отличных от <tt class="CLASSNAME">bool</tt>, преобразование проходит
          автоматически.<br>
          <br>

          <p>Вслед за нею вызывается <tt class="METHODNAME">setSizePolicy()</tt>, отдавая компоненту все
          доступное на форме пространство. После чего выполняется
          подключение трех событий ActiveX плеера к слотам
          приложения.</p>

          <p>Оставшаяся часть конструктора выполняет обычные, для
          любого Qt класса, действия, за исключением, разве что,
          подключения трех Qt-сигналов к слотам COM-объекта (<tt class="METHODNAME">Play()</tt>, <tt class="METHODNAME">Pause()</tt>
          и <tt class="METHODNAME">Stop()</tt>).</p>

          <p>Оставим конструктор в покое и рассмотрим функцию
          <tt class="METHODNAME">timerEvent()</tt>:</p>
          <pre class="SCREEN">void PlayerWindow::timerEvent(QTimerEvent *event) 
{ 
  if (event-&gt;timerId() == updateTimer) { 
    double curPos = wmp-&gt;property("CurrentPosition").toDouble(); 
    onPositionChange(-1, curPos); 
  } else { 
    QWidget::timerEvent(event); 
  } 
}
      
</pre>Эта функция регулярно вызывается через определенные интервалы
времени, во время проигрывания. С ее помощью устанавливается положение
движка. Значение положения движка определяется путем чтения свойства
<tt class="VARNAME">CurrentPosition</tt> элемента ActiveX, с помощью
функции <tt class="METHODNAME">property()</tt>.<br>
          <br>

          <p>Мы не привели остальную часть кода конструктора по той
          причине, что он напрямую не связан с ActiveX и не
          демонстрирует ничего такого, о чем бы мы не говорили
          ранее.</p>

          <p>Чтобы связать приложение с модулем <span class="emphasis"><em class="EMPHASIS">QAxContainer</em></span>,
          необходимо в файл проекта добавить строку:</p>
          <pre class="SCREEN">LIBS += -lqaxcontainer
      
</pre>Иногда возникает необходимость прямого вызова методов COM-объекта
(без соединения с сигналом Qt). Самый простой способ -- вызвать функцию
<tt class="METHODNAME">dynamicCall()</tt>, которой в качестве первого
аргумента передать имя и сигнатуру вызываемого метода, а аргументы
метода -- в виде последующих входных параметров, например:
          <pre class="SCREEN">  wmp-&gt;dynamicCall("TitlePlay(uint)", 6);
      
</pre>Функция <tt class="METHODNAME">dynamicCall()</tt> может принимать
до восьми аргументов типа <tt class="CLASSNAME">QVariant</tt> и
возвращает значение типа <tt class="CLASSNAME">QVariant</tt>. Если
методу нужно передать аргумент типа <tt class="CLASSNAME">IDispatch
*</tt> или <tt class="CLASSNAME">IUnknown *</tt>, то можно сначала
инкапсулировать его в объект <tt class="CLASSNAME">QAxObject</tt>, а
затем вызвать метод <tt class="METHODNAME">asVariant()</tt>, чтобы
преобразовать его в тип <tt class="CLASSNAME">QVariant</tt>. Если метод
COM-объекта возвращает значение типа <tt class="CLASSNAME">IDispatch
*</tt> или <tt class="CLASSNAME">IUnknown</tt>, или если нужно получить
доступ к свойству COM-объекта одного из этих типов, то нам придется
воспользоваться функцией <tt class="METHODNAME">querySubObject()</tt>:
          <pre class="SCREEN">  QAxObject *session = outlook.querySubObject("Session"); 
  QAxObject *defaultContacts = 
          session-&gt;querySubObject("GetDefaultFolder(OlDefaultFolders)", 
                                  "olFolderContacts");
      
</pre>Если вызываемая функция имеет аргументы неподдерживаемых типов,
вы должны сначала получить COM-интерфейс, вызовом функции
          <tt class="METHODNAME">QAxBase::queryInterface()</tt>, а
          затем вызвать нужный метод напрямую. Не забывайте вызвать
          <tt class="METHODNAME">Release()</tt>, когда надобность в
          интерфейсе отпадет.<br>
          <br>

          <p>Если необходимость в вызове подобных функций возникает
          достаточно часто, вы можете создать класс-потомок от
          <tt class="CLASSNAME">QAxObject</tt> или от <tt class="CLASSNAME">QAxWidget</tt>, и добавить функции-члены для
          работы с COM-интерфейсом. При этом вы должны помнить, что
          потомки классов <tt class="CLASSNAME">QAxObject</tt> и
          <tt class="CLASSNAME">QAxWidget</tt> не могут определять
          новые свойства, сигналы и слоты.</p>

          <p>Теперь перейдем к обзору модуля <span class="emphasis"><em class="EMPHASIS">QAxServer</em></span>. Этот
          модуль позволяет превратить обычную Qt-программу в
          ActiveX-сервер. Сервер может быть выполнен либо в виде
          динамической библиотеки, либо в виде автономного приложения.
          Серверы, собранные в виде динамической библиотеки часто
          называют "внутренними" (in-process) серверами, а
          автономные приложения -- "внешними"
          (out-of-process) серверами.</p>

          <p>Наш первый пример будет собран в виде
          "внутреннего" сервера, который реализует виджет,
          отображающий прыгающий шарик. Мы так же покажем, как встроить
          виджет в Internet Explorer.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig18.5.png"></p>

            <div class="CAPTION">
              <p>Рисунок 18.5. Виджет <tt class="CLASSNAME">AxBouncer</tt> в Internet Explorer.</p>
            </div>
          </div><br>
          Начнем с определения класса виджета <tt class="CLASSNAME">AxBouncer</tt>:
          <pre class="SCREEN">class AxBouncer : public QWidget, public QAxBindable 
{ 
  Q_OBJECT 
  Q_ENUMS(Speed) 
  Q_PROPERTY(QColor color READ color WRITE setColor) 
  Q_PROPERTY(Speed speed READ speed WRITE setSpeed) 
  Q_PROPERTY(int radius READ radius WRITE setRadius) 
  Q_PROPERTY(bool running READ isRunning)
      
</pre>Класс <tt class="CLASSNAME">AxBouncer</tt> является потомком
сразу двух классов: <tt class="CLASSNAME">QWidget</tt> и
          <tt class="CLASSNAME">QAxBindable</tt>. Класс <tt class="CLASSNAME">QAxBindable</tt> реализует интерфейс между
          виджетом и ActiveX-клиентом. Любой виджет может быть
          экспортирован как элемент ActiveX, но порождая его от
          <tt class="CLASSNAME">QAxBindable</tt>, мы получаем
          возможность извещать клиента при изменении значений свойств
          виджета, а так же реализовать COM-интерфейсы, в дополнение к
          тем, что уже реализованы в <span class="emphasis"><em class="EMPHASIS">QAxServer</em></span>.<br>
          <br>

          <p>При использовании множественного наследования, с участием
          класса <tt class="CLASSNAME">QObject</tt>, вы всегда должны
          указывать этот класс первым в списке предков, чтобы
          обеспечить корректную работу утилиты <tt class="USERINPUT"><strong>moc</strong></tt>.</p>

          <p>В нашем определении мы объявили три свойства, доступные
          для чтения/записи и одно свойство, доступное только для
          чтения. Макрос <tt class="CLASSNAME">Q_ENUMS()</tt> сообщает
          утилите <tt class="USERINPUT"><strong>moc</strong></tt>, что
          <tt class="VARNAME">Speed</tt> -- это перечисление, которое
          объявлено в публичной секции</p>
          <pre class="SCREEN">public: 
  enum Speed { Slow, Normal, Fast }; 
  
  AxBouncer(QWidget *parent = 0, const char *name = 0); 
  
  void setSpeed(Speed newSpeed); 
  Speed speed() const { return ballSpeed; } 
  void setRadius(int newRadius); 
  int radius() const { return ballRadius; } 
  void setColor(const QColor &amp;newColor); 
  QColor color() const { return ballColor; } 
  bool isRunning() const { return myTimerId != 0; } 
  QSize sizeHint() const; 
  QAxAggregated *createAggregate(); 
  
public slots: 
  void start(); 
  void stop(); 

signals: 
  void bouncing();
      
</pre>В конструкторе <tt class="METHODNAME">AxBouncer</tt> нет ничего
необычного, это стандартный конструктор виджета, с аргументами
<tt class="VARNAME">parent</tt> и <tt class="VARNAME">name</tt>. Макрос
<tt class="VARNAME">QAXFACTORY_DEFAULT()</tt>, который используется для
экспорта компонента, принимает в виде параметра конструктор именно с
такой сигнатурой.<br>
          <br>

          <p>Функция <tt class="METHODNAME">createAggregate()</tt>
          перекрывает метод родительского класса <tt class="CLASSNAME">QAxBindable</tt>. К ее описанию мы вскоре
          вернемся.</p>
          <pre class="SCREEN">protected: 
  void paintEvent(QPaintEvent *event); 
  void timerEvent(QTimerEvent *event); 
  
private: 
  int intervalInMilliseconds() const; 
  
  QColor ballColor; 
  Speed ballSpeed; 
  int ballRadius; 
  int myTimerId; 
  int x; 
  int delta; 
};
      
</pre>Защищенная и приватная секции класса не содержат ничего
необычного, что отличало бы их от привычных виджетов Qt.
          <pre class="SCREEN">AxBouncer::AxBouncer(QWidget *parent, const char *name) 
    : QWidget(parent, name, WNoAutoErase) 
{ 
  ballColor = blue; 
  ballSpeed = Normal; 
  ballRadius = 15; 
  myTimerId = 0; 
  x = 20; 
  delta = 2; 
}
      
</pre>Конструктор выполняет инициализацию приватных переменных.
          <pre class="SCREEN">void AxBouncer::setColor(const QColor &amp;newColor) 
{ 
  if (newColor != ballColor amp;amp; requestPropertyChange("color")) { 
    ballColor = newColor; 
    update(); 
    propertyChanged("color"); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">setColor()</tt> записывает новое
значение цвета в переменную-член <tt class="VARNAME">color</tt> и
перерисовывает виджет, вызовом функции <tt class="METHODNAME">
          update()</tt>.<br>
          <br>

          <p>Необычными моментами здесь являются обращения к функциям
          <tt class="METHODNAME">requestPropertyChange()</tt> и
          <tt class="METHODNAME">propertyChanged()</tt>. Эти функции
          унаследованы от класса <tt class="CLASSNAME">QAxBindable</tt>. В идеале эти функции должны
          вызываться в паре всякий раз, когда необходимо изменить
          значение свойства. Функция <tt class="METHODNAME">requestPropertyChange()</tt> запрашивает права
          клиента на изменение свойства и возвращает <tt class="VARNAME">true</tt>, если клиенту позволено это делать.
          Функция <tt class="METHODNAME">propertyChanged()</tt>
          извещает клиента о том, что изменение произведено.</p>

          <p>Функции <tt class="METHODNAME">setSpeed()</tt> и
          <tt class="METHODNAME">setRadius()</tt>, которые так же
          устанавливают новые значения свойств, следуют тому же
          шаблону. Аналогичные действия выполняют слоты <tt class="METHODNAME">start()</tt> и <tt class="METHODNAME">stop()</tt>, потому что они изменяют свойство
          <tt class="VARNAME">running</tt>.</p>

          <p>Осталась еще одна функция класса <tt class="CLASSNAME">AxBouncer</tt>, которая представляет для нас
          интерес:</p>
          <pre class="SCREEN">QAxAggregated *AxBouncer::createAggregate() 
{ 
  return new ObjectSafetyImpl; 
}
      
</pre>Функция <tt class="METHODNAME">createAggregate()</tt> перекрывает
метод предка -- <tt class="CLASSNAME">QAxBindable</tt>. Она позволяет
реализовать COM-интерфейс(ы), которые не реализованы в модуле
<span class="emphasis"><em class="EMPHASIS">QAxServer</em></span>, или
обойти COM-интерфейсы по-умолчанию. В данном случае возвращается
интерфейс <tt class="CLASSNAME">IObjectSafety</tt>, который
используется в Internet Explorer, для безопасного доступа к элементам
компонента. Это обычный трюк, помогающий избежать сообщения об ошибке:
"Object not safe for scripting".<br>
          <br>

          <p>Ниже приводится определение класса, который реализует
          интерфейс <tt class="CLASSNAME">IObjectSafety</tt>:</p>
          <pre class="SCREEN">class ObjectSafetyImpl : public QAxAggregated, public IObjectSafety 
{ 
public: 
  long queryInterface(const QUuid &amp;iid, void **iface); 
  
  QAXAGG_IUNKNOWN 
  
  HRESULT WINAPI GetInterfaceSafetyOptions(REFIID riid, 
          DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions); 
  HRESULT WINAPI SetInterfaceSafetyOptions(REFIID riid, 
          DWORD pdwSupportedOptions, DWORD pdwEnabledOptions); 
};
      
</pre>Кдасс <tt class="CLASSNAME">ObjectSafetyImpl</tt> порожден от
<tt class="CLASSNAME">QAxAggregated</tt> и <tt class="CLASSNAME">
          IObjectSafety</tt>. Класс <tt class="CLASSNAME">QAxAggregated</tt> -- это абстрактный класс,
          использующийся в качестве базового, для реализации
          дополнительных COM-интерфейсов. Доступ к COM-объекту, который
          является расширением <tt class="CLASSNAME">QAxAggregated</tt>, может быть получен вызовом
          функции <tt class="METHODNAME">controllingUnknown()</tt>.
          Этот COM-объект негласно создается самим модулем <span class="emphasis"><em class="EMPHASIS">QAxServer</em></span>.<br>
          <br>

          <p>Макрос <tt class="CLASSNAME">QAXAGG_IUNKNOWN</tt>
          подставляет стандартную реализацию функций <tt class="METHODNAME">QueryInterface()</tt>, <tt class="METHODNAME">AddRef()</tt> и <tt class="METHODNAME">Release()</tt>.</p>
          <pre class="SCREEN">long ObjectSafetyImpl::queryInterface(const QUuid &amp;iid, void **iface) 
{ 
  *iface = 0; 
  if (iid == IID_IObjectSafety) 
    *iface = (IObjectSafety *)this; 
  else 
    return E_NOINTERFACE; 
  
  AddRef(); 
  return S_OK; 
}
      
</pre>Функция <tt class="METHODNAME">queryInterface()</tt> вызывается
программой-клиентом, управляющей COM-объектом, для того, чтобы получить
доступ к интерфейсу, реализуемому классом-наследником от
          <tt class="CLASSNAME">QAxAggregated</tt>. Для интерфейсов,
          реализация которых отсутствует, следует возвращать значение
          <tt class="CLASSNAME">E_NOINTERFACE</tt>.
          <pre class="SCREEN">HRESULT WINAPI ObjectSafetyImpl::GetInterfaceSafetyOptions( 
            REFIID riid, DWORD *pdwSupportedOptions, 
            DWORD *pdwEnabledOptions) 
{ 
  *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA 
                         | INTERFACESAFE_FOR_UNTRUSTED_CALLER; 
  *pdwEnabledOptions = *pdwSupportedOptions; 
  return S_OK; 
} 

HRESULT WINAPI ObjectSafetyImpl::SetInterfaceSafetyOptions(REFIID, 
            DWORD, DWORD) 
{ 
  return S_OK; 
}
      
</pre>Функции <tt class="METHODNAME">GetInterfaceSafetyOptions()</tt> и
<tt class="METHODNAME">SetInterfaceSafetyOptions()</tt> объявлены в
<tt class="CLASSNAME">IObjectSafety</tt>. Мы выполняем их реализацию
для того, чтобы сообщить вызывающей программе о том, что объект
безопасен.<br>
          <br>

          <p>Теперь перейдем к содержимому файла <tt class="FILENAME">main.cpp</tt>:</p>
          <pre class="SCREEN">#include &lt;qaxfactory.h&gt; 

#include "axbouncer.h" 

QAXFACTORY_DEFAULT(AxBouncer, 
                   "{5e2461aa-a3e8-4f7a-8b04-307459a4c08c}", 
                   "{533af11f-4899-43de-8b7f-2ddf588d1015}", 
                   "{772c14a5-a840-4023-b79d-19549ece0cd9}", 
                   "{dbce1e56-70dd-4f74-85e0-95c65d86254d}", 
                   "{3f3db5e0-78ff-4e35-8a5d-3d3b96c83e09}") 

int main() 
{ 
  return 0; 
}
      
</pre>Макрос <tt class="METHODNAME">QAXFACTORY_DEFAULT()</tt>
экспортирует компонент ActiveX. Этот макрос используется в случаях,
когда сервер экспортирует единственный элемент управления ActiveX. В
противном случае, сервер должен перекрыть класс <tt class="CLASSNAME">
          QAxFactory</tt> и использовать макрос <tt class="METHODNAME">QAXFACTORY_EXPORT()</tt>. Следующий пример в
          этом разделе продемонстрирует, как это делается.<br>
          <br>

          <p>Первый аргумент <tt class="METHODNAME">QAXFACTORY_DEFAULT()</tt> -- имя экспортируемого
          класса Qt. Остальные пять аргументов -- это GUID класса, GUID
          интерфейса, GUID интерфейса событий, GUID библиотеки типов и
          GUID приложения. Для генерации этих значений могут
          использоваться стандартные утилиты <tt class="USERINPUT"><strong>guidgen</strong></tt> и <tt class="USERINPUT"><strong>uuidgen</strong></tt>.</p>

          <p>Поскольку наш сервер является библиотекой, мы не
          предусматриваем никаких действий в функции <tt class="METHODNAME">main()</tt>. Однако она нужна нам, чтобы
          "умиротворить" программу-компоновщик (linker).</p>

          <p>Файл проекта для <tt class="FILENAME">.pro</tt> нашего
          сервера:</p>
          <pre class="SCREEN">    TEMPLATE     = lib 
    CONFIG      += activeqt dll 
    HEADERS      = axbouncer.h \ 
                   objectsafetyimpl.h 
    SOURCES      = axbouncer.cpp \ 
                   main.cpp \ 
                   objectsafetyimpl.cpp 
    RC_FILE      = qaxserver.rc 
    DEF_FILE     = qaxserver.def
      
</pre>Файлы <tt class="FILENAME">qaxserver.rc</tt> и
          <tt class="FILENAME">qaxserver.def</tt> могут быть
          скопированы из подкаталога библиотеки Qt: <tt class="FILENAME">extensions\activeqt\control</tt>.<br>
          <br>

          <p>Файл <tt class="FILENAME">makefile</tt> или файл проекта
          Visual C++, созданные <tt class="FILENAME">qmake</tt>, уже
          содержат правила регистрации сервера в реестре Windows. Чтобы
          зарегистрировать сервер на другой машине, можно
          воспользоваться утилитой <tt class="FILENAME">regsvr32</tt>,
          которая входит в состав ОС Windows.</p>

          <p>После этого мы можем включить компонент Bouncer в
          HTML-страничку, с помощью тега <tt class="VARNAME">&lt;object&gt;</tt>:</p>
          <pre class="SCREEN">  &lt;object id="AxBouncer" 
           classid="clsid:5e2461aa-a3e8-4f7a-8b04-307459a4c08c"&gt; 
  &lt;b&gt;The ActiveX control is not available. Make sure you have built and 
  registered the component server.&lt;/b&gt; 
  &lt;/object&gt;
      
</pre>А для управления объектом -- разместить кнопки:
          <pre class="SCREEN">  &lt;input type="button" value="Start" onClick="AxBouncer.start()"&gt; 
  &lt;input type="button" value="Stop" onClick="AxBouncer.stop()"&gt;
      
</pre>Этим объектом можно управлять из JavaScript или VBScript точно
так же, как и любым другим элементом управления ActiveX.<br>
          <br>

          <p>В нашем последнем примере мы рассмотрим реализацию
          приложения Address Book. Это приложение может использоваться
          как обычная Qt/Windows программа или как "внешний"
          ActiveX сервер, например для программ, написанных на Visual
          Basic.</p>
          <pre class="SCREEN">class AddressBook : public QMainWindow 
{ 
  Q_OBJECT 
  Q_PROPERTY(int count READ count) 
public: 
  AddressBook(QWidget *parent = 0, const char *name = 0); 
  ~AddressBook(); 
  
  int count() const; 
  
public slots: 
  ABItem *createEntry(const QString &amp;contact); 
  ABItem *findEntry(const QString &amp;contact) const; 
  ABItem *entryAt(int index) const; 
  ... 
};
      
</pre>Класс <tt class="CLASSNAME">AddressBook</tt> -- это виджет
главного окна приложения.
          <pre class="SCREEN">class ABItem : public QObject, public QListViewItem 
{ 
  Q_OBJECT 
  Q_PROPERTY(QString contact READ contact WRITE setContact) 
  Q_PROPERTY(QString address READ address WRITE setAddress) 
  Q_PROPERTY(QString phoneNumber READ phoneNumber 
             WRITE setPhoneNumber) 
public: 
  ABItem(QListView *listView); 
  
  void setContact(const QString &amp;contact); 
  QString contact() const { return text(0); } 
  void setAddress(const QString &amp;address); 
  QString address() const { return text(1); }
  void setPhoneNumber(const QString &amp;number); 
  QString phoneNumber() const { return text(2); } 
  
public slots: 
  void remove(); 
};
      
</pre>Класс <tt class="CLASSNAME">ABItem</tt> представляет одну запись
в адресной книге. Он является производным от класса
          <tt class="CLASSNAME">QListViewItem</tt>, что позволяет
          отображать его в <tt class="CLASSNAME">QListView</tt>. А
          поскольку в число его предков входит класс <tt class="CLASSNAME">QObject</tt>, то это позволяет экспортировать его
          как COM-объект.
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  QApplication app(argc, argv); 
  if (!QAxFactory::isServer()) { 
    AddressBook addressBook; 
    app.setMainWidget(&amp;addressBook); 
    addressBook.show(); 
    return app.exec(); 
  } 
  return app.exec(); 
}
      
</pre>В функции <tt class="METHODNAME">main()</tt> выполняется проверка
-- запущено ли приложение как автономная программа, или как сервер.
Если программа запускается как автономное приложение, то создается
главный виджет и дальше все идет как в обычных Qt-приложениях. Чтобы
запустить программу как сервер, нужно передать ей ключ командной
строки: <tt class="PARAMETER"><em>-activex</em></tt>.<br>
          <br>

          <p>В дополнение к ключу <tt class="PARAMETER"><em>-activex</em></tt>, серверы ActiveX могут
          принимать следующие ключи:</p>

          <ul>
            <li>
              <p><tt class="PARAMETER"><em>-regserver</em></tt> --
              регистрирует сервер в реестре Windows.</p>
            </li>

            <li>
              <p><tt class="PARAMETER"><em>-unregserver</em></tt> --
              удаляет регистрацию сервера из реестра Windows.</p>
            </li>

            <li>
              <p><tt class="PARAMETER"><em>-dumpidl file</em></tt> --
              записывает IDL сервера в указанный файл.</p>
            </li>
          </ul>Если приложение будет использоваться как сервер,
          необходимо экспортировать классы <tt class="CLASSNAME">AddressBook</tt> и <tt class="CLASSNAME">ABItem</tt> как COM-компоненты:
          <pre class="SCREEN">QAXFACTORY_EXPORT(ABFactory, 
                  "{2b2b6f3e-86cf-4c49-9df5-80483b47f17b}", 
                  "{8e827b25-148b-4307-ba7d-23f275244818}")
      
</pre>Макрос <tt class="CLASSNAME">QAXFACTORY_EXPORT()</tt>
экспортирует фабрику COM-объектов. Поскольку наше приложение
экспортирует два COM-объекта, то мы уже не можем воспользоваться
макросом <tt class="CLASSNAME">QAXFACTORY_DEFAULT()</tt>, как это было
сделано в предыдущем примере.<br>
          <br>

          <p>Первый аргумент макроса <tt class="CLASSNAME">QAXFACTORY_EXPORT()</tt> -- имя класса-наследника
          <tt class="CLASSNAME">QAxFactory</tt>, который реализует
          COM-объект. Другие два аргумента -- это GUID библиотеки типов
          и приложения.</p>
          <pre class="SCREEN">class ABFactory : public QAxFactory { 
public: 
  ABFactory(const QUuid &amp;lib, const QUuid &amp;app); 
  QStringList featureList() const; 
  QWidget *create(const QString &amp;key, QWidget *parent, 
                  const char *name); 
  QUuid classID(const QString &amp;key) const; 
  QUuid interfaceID(const QString &amp;key) const; 
  QUuid eventsID(const QString &amp;key) const; 
  QString exposeToSuperClass(const QString &amp;key) const; 
};
      
</pre>Класс <tt class="CLASSNAME">ABFactory</tt> порожден от класса
<tt class="CLASSNAME">QAxFactory</tt>, он реализует виртуальную
функцию, экспортирующую класс <tt class="CLASSNAME">AddressBook</tt>,
как элемент управления ActiveX, и класс <tt class="CLASSNAME">
          ABItem</tt>, как COM-объект.
          <pre class="SCREEN">ABFactory::ABFactory(const QUuid &amp;lib, const QUuid &amp;app) 
    : QAxFactory(lib, app) 
{ 
}
      
</pre>Конструктор класса <tt class="CLASSNAME">ABFactory</tt> просто
передает два аргумента конструктору родительского класса.
          <pre class="SCREEN">QStringList ABFactory::featureList() const 
{ 
  return QStringList() &lt;&lt; "AddressBook" &lt;&lt; "ABItem"; 
}
      
</pre>Функция <tt class="METHODNAME">featureList()</tt> возвращает
список COM-объектов, которые могут быть созданы фабрикой.
          <pre class="SCREEN">QWidget *ABFactory::create(const QString &amp;key, QWidget *parent, 
                           const char *name) 
{ 
  if (key == "AddressBook") 
    return new AddressBook(parent, name); 
  else 
    return 0; 
}
      
</pre>Функция <tt class="METHODNAME">create()</tt> создает экземпляр
элемента управления ActiveX. Для случая <tt class="CLASSNAME">
          ABItem</tt> возвращается пустой указатель, поскольку
          пользователь не должен иметь возможность создавать объекты
          этого типа.
          <pre class="SCREEN">QUuid ABFactory::classID(const QString &amp;key) const 
{ 
  if (key == "AddressBook") 
    return QUuid("{588141ef-110d-4beb-95ab-ee6a478b576d}"); 
  else if (key == "ABItem") 
    return QUuid("{bc82730e-5f39-4e5c-96be-461c2cd0d282}"); 
  else 
    return QUuid(); 
}
      
</pre>Функция <tt class="METHODNAME">classId()</tt> возвращает
идентификаторы классов, которые могут быть экспортированы фабрикой.
          <pre class="SCREEN">QUuid ABFactory::interfaceID(const QString &amp;key) const 
{ 
  if (key == "AddressBook") 
    return QUuid("{718780ec-b30c-4d88-83b3-79b3d9e78502}"); 
  else if (key == "ABItem") 
    return QUuid("{c8bc1656-870e-48a9-9937-fbe1ceff8b2e}"); 
  else 
    return QUuid(); 
}
      
</pre>Функция <tt class="METHODNAME">interfaceId()</tt> возвращает
идентификаторы интерфейсов классов, экспортируемых фабрикой.
          <pre class="SCREEN">QUuid ABFactory::eventsID(const QString &amp;key) const 
{ 
  if (key == "AddressBook") 
    return QUuid("{0a06546f-9f02-4f14-a269-d6d56ffeb861}"); 
  else if (key == "ABItem") 
    return QUuid("{105c6b0a-3fc7-460b-ae59-746d9d4b1724}"); 
  else 
    return QUuid(); 
}
      
</pre>Функция <tt class="METHODNAME">eventsId()</tt> возвращает
идентификаторы интерфейсов событий, для экспортируемых классов.
          <pre class="SCREEN">QString ABFactory::exposeToSuperClass(const QString &amp;key) const 
{ 
  return key; 
}
      
</pre>По-умолчанию, элементы управления ActiveX поставляют клиентам не
только свои собственные свойства, сигналы и слоты, но и свойства,
сигналы и слоты своих базовых классов, вплоть до <tt class="CLASSNAME">
          QWidget</tt>. Мы можем перекрыть метод <tt class="METHODNAME">exposeToSuperClass()</tt>, чтобы ограничить
          верхнюю границу (в дереве наследования) поставляемых
          классов.<br>
          <br>

          <p>Здесь, в виде верхней границы, мы просто возвращаем имя
          класса компонента ("AddressBook" или
          "ABItem"). Это означает, что свойства, сигналы и
          слоты классов-предков для <tt class="CLASSNAME">AddressBook</tt> и <tt class="CLASSNAME">ABItem</tt> поставляться не будут.</p>

          <p>Ниже приводится содержимое файла проекта для нашего
          "внешнего" сервера ActiveX:</p>
          <pre class="SCREEN">CONFIG      += activeqt 
HEADERS      = abfactory.h \ 
               abitem.h \ 
               addressbook.h \ 
               editdialog.h 
SOURCES      = abfactory.cpp \ 
               abitem.cpp \ 
               addressbook.cpp \ 
               editdialog.cpp \ 
               main.cpp 
RC_FILE      = qaxserver.rc
      
</pre>Файл <tt class="FILENAME">qaxserver.rc</tt> может быть скопирован
из подкаталога <tt class="FILENAME">extensions\activeqt\control</tt>.<br>
          <br>

          <p>На этом мы завершаем краткий обзор ActiveQt framework.
          Дистрибутив библиотеки Qt включает в себя ряд дополнительных
          примеров, которые содержат сведения о модулях <span class="emphasis"><em class="EMPHASIS">QAxContainer</em></span> и
          <span class="emphasis"><em class="EMPHASIS">QAxServer</em></span> и решения наиболее общих
          проблем совместимости.</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="SESSIONMANAGEMENT"></a>18.3.
          Управление сеансами.</h1>

          <p>В момент завершения сеанса X11, некоторые оконные
          менеджеры выдают запрос на подтверждение завершения сеанса.
          Если мы подтверждаем завершение сессии, то приложения,
          которые работали в этот момент, будут автоматически запущены
          в начале следующего сеанса, с теми же экранными координатами
          и, в идеале, в том же самом состоянии.</p>

          <p>Компонент X11, который управляет сохранением и
          восстановлением сеанса называется <span class="emphasis"><em class="EMPHASIS">менеджер сеанса</em></span>
          (или, если хотите, <span class="emphasis"><em class="EMPHASIS">менеджер сессии</em></span>). Чтобы добавить в
          Qt-приложение возможность сохранения своего состояния, в
          момент завершения сессии, необходимо перекрыть метод
          <tt class="METHODNAME">QApplication::saveState()</tt>, в
          котором выполнять сохранение всех необходимых параметров.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig18.6.png"></p>

            <div class="CAPTION">
              <p>Рисунок 18.6. Окно запроса подтверждения завершения
              сеанса в KDE.</p>
            </div>
          </div><br>
          Операционные системы Windows 2000/XP (и некоторые
          Unix-системы) предлагают иной механизм сохранения сеансов,
          который носит название <span class="emphasis"><em class="EMPHASIS">гибернация</em></span> (hibernation). Когда
          пользователь переводит систему в режим гибернации, то она
          просто скидывает дамп памяти на диск и на следующем запуске
          загружает его. В этом случае приложениям ничего не надо
          делать, им даже нет необходимости что либо "знать"
          о гибернации.<br>
          <br>

          <p>Момент завершения работы может быть перехвачен
          приложением, для этого надо перекрыть метод <tt class="METHODNAME">QApplication::commitData()</tt>. Это позволит
          сохранить любые несохраненные данные и запросить что либо у
          пользователя, если в этом возникнет необходимость. Это
          поведение реализуется одинаково на обеих платформах: X11 и
          Windows.</p>

          <p>Мы исследуем поведение приложения, которое может
          взаимодействовать с менеджером сеанса, на примере программы
          "Крестики-нолики". Сначала рассмотрим функцию
          <tt class="METHODNAME">main()</tt>:</p>
          <pre class="SCREEN">int main(int argc, char *argv[]) 
{ 
  Application app(argc, argv); 
  TicTacToe tic(0, "tic"); 
  app.setTicTacToe(&amp;tic); 
  tic.show(); 
  return app.exec(); 
}
      
</pre>Здесь создается экземпляр класса <tt class="CLASSNAME">Application</tt>, производный от класса
          <tt class="CLASSNAME">QApplication</tt>. Этот класс
          перекрывает методы предка -- <tt class="METHODNAME">commitData()</tt> и <tt class="METHODNAME">saveState()</tt>.<br>
          <br>

          <p>Затем создается виджет <tt class="CLASSNAME">TicTacToe</tt> и выводится на экран. Виджету
          <tt class="CLASSNAME">TicTacToe</tt> было присаоено имя
          "tic". Если вы хотите обеспечить взаимодействие
          программы с менеджером сеанса, то всем виджетам верхнего
          уровня должны быть присвоены уникальные имена.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig18.7.png"></p>

            <div class="CAPTION">
              <p>Рисунок 18.7. Внешний вид приложения
              "Крестики-нолики".</p>
            </div>
          </div><br>
          Ниже приводится определение класса <tt class="CLASSNAME">Application</tt>:
          <pre class="SCREEN">class Application : public QApplication 
{ 
  Q_OBJECT 
public: 
  Application(int &amp;argc, char *argv[]); 
  
  void setTicTacToe(TicTacToe *tic); 
  void commitData(QSessionManager &amp;sessionManager); 
  void saveState(QSessionManager &amp;sessionManager); 
  
private: 
  TicTacToe *ticTacToe; 
};
      
</pre>Класс <tt class="CLASSNAME">Application</tt> хранит указатель на
виджет <tt class="CLASSNAME">TicTacToe</tt> в приватной переменной.
          <pre class="SCREEN">void Application::saveState(QSessionManager &amp;sessionManager) 
{ 
  QString fileName = ticTacToe-&gt;saveState(); 
  
  QStringList discardCommand; 
  discardCommand &lt;&lt; "rm" &lt;&lt; fileName; 
  sessionManager.setDiscardCommand(discardCommand); 
}
      
</pre>На платформе X11, менеджер сеансов вызывает функцию
          <tt class="METHODNAME">saveState()</tt>, для сохранения
          состояния приложения. Она доступна и на других платформах, но
          никогда не вызывается. Аргумент типа <tt class="CLASSNAME">QSessionManager</tt> позволяет взаимодействовать
          с менеджером сеансов.<br>
          <br>

          <p>Функция начинается с сохранения состояния виджета
          <tt class="CLASSNAME">TicTacToe</tt> в файл. Затем менеджеру
          сеанса передается команда удаления. <span class="emphasis"><em class="EMPHASIS">Команда удаления</em></span>
          -- это команда, которая будет использована менеджером сеанса
          для удаления любой информации, имеющей отношение к текущему
          состоянию приложения. В данном случае команда выглядит
          как:</p>
          <pre class="SCREEN">      rm file
      
</pre>где <tt class="VARNAME">file</tt> -- это имя файла, в котором
сохраняется информация о текущем состоянии, а <tt class="VARNAME">
          rm</tt> -- это стандартная команда Unix, выполняющая удаление
          файлов.<br>
          <br>

          <p>Менеджеру сеанса может быть передана <span class="emphasis"><em class="EMPHASIS">команда
          восстановления</em></span>, которая будет выполнена
          менеджером для перезапуска приложения. По-умолчанию, Qt
          устанавливает команду восстановления:</p>
          <pre class="SCREEN">      appname -session id_key
      
</pre>где <tt class="VARNAME">appname</tt> берется из
          <tt class="VARNAME">argv[0]</tt>, <tt class="VARNAME">id</tt>
          -- идентификатор сессии, поставляемый самим менеджером.
          Менеджер сеансов гарантирует уникальность идентификатора для
          каждого экземпляра приложения. И наконец <tt class="VARNAME">key</tt> -- дополнительная информация, содержащая
          время сохранения состояния приложения. По различным причинам,
          функция <tt class="METHODNAME">saveState()</tt> может
          вызываться несколько раз, на протяжении одной сессии, таким
          образом пара <tt class="VARNAME">id</tt> и <tt class="VARNAME">key</tt> гарантируют уникальность каждого из
          сохраненных состояний.<br>
          <br>

          <p>Из-за ограничений, существующих в менеджерах сеансов, путь
          к исполняемому файлу приложения должен быть прописан в
          переменной <tt class="VARNAME">PATH</tt>. В данном конкретном
          случае, если вы пожелаете испытать приложение
          "Крестики-нолики", вы должны переписать исполняемый
          файл программы в каталог, скажем, <tt class="FILENAME">/usr/bin</tt>, и запустить ее командой <tt class="USERINPUT"><strong>tictactoe</strong></tt>.</p>

          <p>Для простых приложений, таких как
          "Крестики-нолики", состояние может быть сохранено в
          виде аргумента командной строки, которая перезапускает
          приложение в начале следующей сессии, например:</p>
          <pre class="SCREEN">      tictactoe -state OX-XO-X-O
      
</pre>В этом случае отпадает необходимость сохранения информации в
отдельный файл и установки команды удаления файла.
          <pre class="SCREEN">void Application::commitData(QSessionManager &amp;sessionManager) 
{ 
  if (ticTacToe-&gt;gameInProgress() 
          &amp;&amp; sessionManager.allowsInteraction()) { 
    int ret = QMessageBox::warning(ticTacToe, tr("Tic-Tac-Toe"), 
                tr("The game hasn t finished.\n" 
                   "Do you really want to quit?"), 
                QMessageBox::Yes | QMessageBox::Default, 
                QMessageBox::No | QMessageBox::Escape); 
    if (ret == QMessageBox::Yes) 
      sessionManager.release(); 
    else 
      sessionManager.cancel(); 
  } 
}
      
</pre>Функция <tt class="METHODNAME">commitData()</tt> вызывается в
момент завершения сеанса. Здесь выводится запрос на подтверждение
завершения приложения, чтобы предотвратить потерю данных. По-умолчанию
она закрывает все виджеты верхнего уровня, точно так же, как и в случае
завершения приложения нажатием на кнопку "X", в заголовке
окна. В <a href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#CHAPTER3">Главе 3</a> мы уже демонстрировали, как
перекрыть метод <tt class="METHODNAME">closeEvent()</tt> и вывести
запрос на подтверждение.<br>
          <br>

          <p>В данном примере, мы перекрыли метод <tt class="METHODNAME">commitData()</tt> и выводим запрос на
          подтверждение из него, если менеджер сеанса позволяет это
          сделать. Когда пользователь щелкает по кнопке <strong class="COMMAND">Yes</strong>, то вызывается функция <tt class="METHODNAME">release()</tt>, которая сообщает менеджеру
          сеанса о том, что он может продолжить процедуру завершения
          сессии. В противном случае процедура завершения сеанса будет
          остановлена, вызовом метода <tt class="METHODNAME">cancel()</tt>.</p>

          <div class="MEDIAOBJECT">
            <p><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/fig18.8.png"></p>

            <div class="CAPTION">
              <p>Рисунок 18.8. Запрос на подтверждение завершения
              работы программы.</p>
            </div>
          </div><br>
          Теперь перейдем к рассмотрению класса <tt class="CLASSNAME">TicTacToe</tt>:
          <pre class="SCREEN">class TicTacToe : public QWidget 
{ 
  Q_OBJECT 
public: 
  TicTacToe(QWidget *parent = 0, const char *name = 0); 
  
  QSize sizeHint() const; 
  bool gameInProgress() const; 
  QString saveState() const; 
  
protected: 
  void paintEvent(QPaintEvent *event); 
  void mousePressEvent(QMouseEvent *event); 
  
private: 
  enum { Empty = '-', Cross = 'X', Nought = 'O' }; 
  void clearBoard(); 
  void restoreState(); 
  QString sessionFileName() const; 
  QRect cellRect(int row, int col) const; 
  int cellWidth() const { return width() / 3; } 
  int cellHeight() const { return height() / 3; } 
  
  char board[3][3];
  int turnNumber; 
};
      
</pre>Класс <tt class="CLASSNAME">TicTacToe</tt> порожден от
          <tt class="CLASSNAME">QWidget</tt> и перекрывает методы
          предка: <tt class="METHODNAME">sizeHint(), paintEvent()</tt>
          и <tt class="METHODNAME">mousePressEvent()</tt>. Он так же
          реализует новые методы: <tt class="METHODNAME">gameInProgress()</tt> и <tt class="METHODNAME">saveState()</tt>, которые используются классом
          <tt class="CLASSNAME">Application</tt>.
          <pre class="SCREEN">TicTacToe::TicTacToe(QWidget *parent, const char *name) 
    : QWidget(parent, name) 
{ 
  setCaption(tr("Tic-Tac-Toe")); 
  clearBoard(); 
  if (qApp-&gt;isSessionRestored()) 
    restoreState(); 
}
      
</pre>В конструкторе производится очистка игрового поля и, если
приложение вызвано с ключом <tt class="PARAMETER"><em>-session</em></tt>, то вызывается приватная функция
<tt class="METHODNAME">restoreState()</tt>.
          <pre class="SCREEN">void TicTacToe::clearBoard() 
{ 
  for (int row = 0; row &lt; 3; ++row) { 
    for (int col = 0; col &lt; 3; ++col) { 
      board[row][col] = Empty; 
    } 
  } 
  turnNumber = 0; 
}
      
</pre>Функция <tt class="METHODNAME">clearBoard()</tt> выполняет
очистку ячеек игрового поля и записывает значение 0 в переменную
<tt class="VARNAME">turnNumber</tt> (номер хода).
          <pre class="SCREEN">QString TicTacToe::saveState() const 
{ 
  QFile file(sessionFileName()); 
  if (file.open(IO_WriteOnly)) { 
    QTextStream out(&amp;file); 
    for (int row = 0; row &lt; 3; ++row) { 
      for (int col = 0; col &lt; 3; ++col) { 
        out &lt;&lt; board[row][col]; 
      } 
    } 
  } 
  return file.name(); 
}
      
</pre>В функции <tt class="METHODNAME">saveState()</tt> производится
сохранение состояния игрового поля в файл. Формат файла очень прост --
на место крестика записывается символ 'X', на место нолика --
'O' и на место пустой ячейки -- '-'.
          <pre class="SCREEN">QString TicTacToe::sessionFileName() const 
{ 
  return QDir::homeDirPath() + "/.tictactoe_" 
         + qApp-&gt;sessionId() + "_" + qApp-&gt;sessionKey(); 
}
      
</pre>Функция <tt class="METHODNAME">sessionFileName()</tt> возвращает
имя файла, которое соответствует текущему идентификатору и ключу
сеанса. Эта функция вызывается как из <tt class="METHODNAME">saveState()</tt>, так и из <tt class="METHODNAME">
          restoreState()</tt>.
          <pre class="SCREEN">void TicTacToe::restoreState() 
{ 
  QFile file(sessionFileName()); 
  if (file.open(IO_ReadOnly)) { 
    QTextStream in(&amp;file); 
    for (int row = 0; row &lt; 3; ++row) { 
      for (int col = 0; col &lt; 3; ++col) { 
        in &gt;&gt; board[row][col]; 
        if (board[row][col] != Empty) 
          ++turnNumber; 
      } 
    } 
  } 
  repaint(); 
}
      
</pre>Функция <tt class="METHODNAME">restoreState()</tt> загружвет
файл, в котором было сохранено предыдущее состояние приложения и
заполняет игровое поле. Номер хода рассчитывается как сумма крестиков и
ноликов на игровом поле.<br>
          <br>

          <p>Функция <tt class="METHODNAME">restoreState()</tt>
          вызывается в конструкторе класса <tt class="CLASSNAME">TicTacToe</tt>, если <tt class="METHODNAME">QApplication::isSessionRestored()</tt>
          возвращает <tt class="VARNAME">true</tt>. В этом случае,
          функции <tt class="METHODNAME">sessionId()</tt> и <tt class="METHODNAME">sessionKey()</tt> возвращают те же значения, с
          которыми было сохранено предыдущее состояние приложения.
          Отсюда и <tt class="METHODNAME">sessionFileName()</tt> вернет
          имя файла, соответствующее этой сессии.</p>

          <p>Отладка взаимодействия с менеджером сеанса может оказаться
          занятием нудным и трудоемким, поскольку придется неоднократно
          перезапускать сессию. К счастью, в состав X11 входит утилита
          <tt class="USERINPUT"><strong>xsm</strong></tt>. На запуске,
          эта утилита откроет окно менеджера сеанса и терминал.
          Приложения, запускаемые из терминала, будут использовать
          <tt class="USERINPUT"><strong>xsm</strong></tt>, в качестве
          менеджера сеанса. После этого мы можем завершать и
          перезапускать сессии и следить за поведением отлаживаемого
          приложения. Дополнительные сведения по этой теме вы найдете
          по адресу: <a href="http://doc.trolltech.com/3.2/session.html" target="_top">http://doc.trolltech.com/3.2/session.html</a>.</p>
        </div>
      </div>

      <div class="CHAPTER">
        <hr>

        <h1><a name="ABOUTTHEAUTHORS"></a>Глава 19. Об авторах.</h1>

        <div class="SECTION">
          <h1 class="SECTION"><a name="AEN8505"></a>19.1. Jasmin
          Blanchette</h1>

          <p>Жасмен получил высшее образование в области информатики в
          2001 году, в Университете города Шербрук, штат Квебек,
          Канада, и был награжден медалью Фернанда Сегуина (Fernand
          Seguin) за успехи в обучении. Летом 2000 года он поступил в
          компанию Trolltech, на стажировку, на должность
          инженера-программиста и затем, в начале 2001 года, был принят
          на постоянную работу. Теперь он работает ведущим
          инженером-программистом. Он ведет проект <span class="emphasis"><em class="EMPHASIS">Qt Linguist</em></span> и
          отвечает за ежеквартальные выпуски <span class="emphasis"><em class="EMPHASIS">Qt Quarterly</em></span> --
          технический информационный бюллетень компании Trolltech. В
          свободное время увлекается написанием романов на норвежском и
          шведском языках. Живет в Осло со своей подругой Энни Лин
          (Anne-Lene).</p>
        </div>

        <div class="SECTION">
          <hr>

          <h1 class="SECTION"><a name="AEN8510"></a>19.2. Mark
          Summerfield</h1>

          <p>Марк получил высшее образование в области информатики в
          1993 году, в Уэльсском Университете. Там же он закончил
          аспирантуру. Прежде чем перейти на работу в Trolltech, он
          много лет, проработал инженером-программистом в различных
          фирмах. На протяжении последних нескольких лет работает
          управляющим отдела документации, в его багаже более 1500
          страниц справочной документации к библиотек Qt и материалов в
          ежеквартальнике <span class="emphasis"><em class="EMPHASIS">Qt Quarterly</em></span>. В свободное время он
          занимается созданием свободно распространяемых программ.
          Живет в Южном Уэльсе, Великобритания, с супругой Андреа
          (Andrea).</p>
        </div>
      </div>
    </div>
  </div>

  <h3 class="FOOTNOTES">Примечания</h3>

  <table border="0" class="FOOTNOTES" width="100%">
    <tbody><tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN66" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN66"><span class="footnote">[1]</span></a></td>

      <td align="left" valign="top" width="95%">
        <p>К настоящему моменту Реджинальд уже переехал в Германию, где
        стал одним из соучредителей компании froglogic, занимающейся
        оказанием консалтинговых услуг в сфере программного
        обеспечения.</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN79" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN79"><span class="footnote">[2]</span></a></td>

      <td align="left" valign="top" width="95%">
        <p>Несколько лет тому назад, Арнт оставил компанию и продолжил
        свою карьеру в Германии.</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN163" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN163"><span class="footnote">[3]</span></a></td>

      <td align="left" valign="top" width="95%">
        <p>Сигналы, в терминологии Qt -- совершенно не то же самое, что
        в терминологии Unix. На протяжении всей книги мы будем говорить
        исключительно о Qt-сигналах.</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN203" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN203"><span class="footnote">[4]</span></a></td>

      <td align="left" valign="top" width="95%">
        <p>Если во время компиляции возникла ошибка в строке 8, то это
        означает, что у вас установлена более старая версия Qt, чем
        требуется. Напоминаем еще раз, что для прогона примеров из этой
        книги вы должны установить Qt 3.2 или более поздний выпуск Qt
        3.</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN409" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN409"><span class="footnote">[5]</span></a></td>

      <td align="left" valign="top" width="95%">
        <p>Qt предоставляет в распоряжение программиста два
        макроопределения: <tt class="PARAMETER"><em>TRUE</em></tt> и
        <tt class="PARAMETER"><em>FALSE</em></tt>, которые могут
        использоваться взамен стандартных <tt class="PARAMETER"><em>true</em></tt> и <tt class="PARAMETER"><em>false</em></tt>. Не смотря на это, мы не видим
        достаточных причин, чтобы использовать макросы Qt, разве только
        в том случае, когда компилятор не поддерживает ключевые слова
        <tt class="PARAMETER"><em>true</em></tt> и <tt class="PARAMETER"><em>false</em></tt>.</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN1370" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN1370"><span class="footnote">[6]</span></a></td>

      <td align="left" valign="top" width="95%">
        <p>Если вы проживаете в стране, чье законодательство признает
        патенты на программное обеспечение и где компания Unisys имеет
        зарегистрированный патент на алгоритм сжатия LZW, то Unisys
        может потребовать от вас приобрести лицензию на использование
        GIF. По этой причине, поддержка формата GIF в Qt по-умолчанию
        запрещена. Мы полагаем, что срок действия этого патента по
        всему миру истечет к концу 2004 года.</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN5706" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN5706"><span class="footnote">[7]</span></a></td>

      <td align="left" valign="top" width="95%">
        <p><strong class="COMMAND">От переводчика:</strong> кроме
        вышеперечисленных, Qt 3.2 включает в себя еще один драйвер,
        который уважаемые авторы, видимо по забывчивости, не указали --
        это QIBASE (Interbase/Firebird).</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN7233" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN7233"><span class="footnote">[8]</span></a></td>

      <td align="left" valign="top" width="95%">
        <p>Вероятно, в состав Qt 3.3 будет включен класс <tt class="CLASSNAME">QLocale</tt>, который будет обслуживать
        представление числовых форматов.</p>
      </td>
    </tr>

    <tr>
      <td align="left" valign="top" width="5%"><a name="FTN.AEN7951" href="https://www.opennet.ru/docs/RUS/qt3_prog/qt3.html#AEN7951"><span class="footnote">[9]</span></a></td>

      <td align="left" valign="top" width="95%">
        <p>Возможно в Qt 3.3 будет включена возможность достигать этого
        эффекта независимо от типа операционной системы.</p>
      </td>
    </tr>
  </tbody></table>

<!--htdig_noindex-->
<noindex>
<br>


</noindex>
<!--/htdig_noindex-->


<!-- footer -->
<!--htdig_noindex-->
<br><br>
<div style="background-color: #E9EAD6; width:100%; height: 61px;">
<div style="margin-right: 20px; float:left; line-height:60px; vertical-align: middle; margin-left: 10px; font-size: 120%;">
Спонсоры:
</div>
<div style="float:left; height:60px;  line-height:60px; margin-left: 20px;">
<a style="align: middle;" target="_blank" href="https://inferno.name/"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/inferno2.png" height="57" width="200" alt="Inferno Solutions"></a>
</div>
<div style="float:right; height:60px;  line-height:60px;  margin-left: 15px;">
<a style="align: middle;" target="_blank" href="http://hoster.ru/?utm_source=site&amp;utm_medium=banner&amp;utm_campaign=opennet"><img src="./Разработка графического интерфейса с помощью библиотеки Qt3_files/dh143x60t.png" height="60" width="143" alt="Hosting by Hoster.ru"></a>
</div>
<div style="float:right;  height:60px;  line-height: 60px; vertical-align: middle;font-size: 120%;">
Хостинг:
</div>

</div>
<div style="clear: both;"></div>


<br>
<table class="ttxt" style="border-top: 3px solid #C9CaB6;">
<tbody><tr><td width="35%">
<a href="https://www.opennet.ru/cgi-bin/opennet/bookmark.cgi">Закладки на сайте</a><br>
<a href="https://www.opennet.ru/cgi-bin/opennet/bookmark.cgi?submit=add" target="blank_">Проследить за страницей</a>
</td>
<td width="65%" align="RIGHT">
Created&nbsp;1996-2022&nbsp;by <b><a href="https://www.opennet.ru/contact.shtml" title="email maxim.chirkov@gmail.com">Maxim&nbsp;Chirkov</a></b><br>
<a href="https://www.opennet.ru/add.shtml">Добавить</a>, <a href="https://www.opennet.ru/donate.shtml" style="color: #C00000;">Поддержать</a>, <a href="https://www.opennet.ru/banners2.shtml">Вебмастеру</a>
</td>
</tr>
</tbody></table>
<br><br>


<!--/htdig_noindex-->
<!-- end of footer -->
<!--
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-123449-1', 'auto');
    ga('send', 'pageview');
</script>
-->




</body><style id="stylus-1" type="text/css" class="stylus">body {
    font-family: 'pragmata pro mono regular';
}</style></html>