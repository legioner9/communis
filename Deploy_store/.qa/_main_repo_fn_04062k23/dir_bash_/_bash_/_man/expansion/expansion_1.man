# https://zalinux.ru/?p=1293#2

# Подстановочные символы, раскрытие, использование кавычек и экранирование символов в Bash

## Оглавление
1. Подстановочные символы

1.1 Диапазоны символов

1.2 Подстановочные символы работают также и в графическом пользовательском интерфейсе

2. Термин оболочки «expansion» – раскрытие или подстановка?

3. Раскрытие

3.1 Раскрытие пути к файлу

3.2 Раскрытие пути к файлу для скрытых файлов

3.3 Раскрытие тильды

3.4 Арифметическое раскрытие

3.5 Раскрытие фигурных скобок

3.6 Раскрытие параметров

3.7 Подстановка команд

4. Использование кавычек в командной строке

4.1 Двойные кавычки

4.2 Одинарные кавычки

5. Экранирование символов

6. Управляющие последовательности с обратным слешем

7. Традиционные диапазоны символов и классы символов POSIX

7.1 Возврат к традиционному порядку сортировки

Заключение

В этой статье мы познакомимся с «магией», которая случается в командной строке, когда вы нажимаете ENTER. Хотя мы проанализируем несколько интересных и комплексных возможностей оболочки, мы будем делать это с помощью одной единственной команды:

echo – показывает строку текста
## Подстановочные символы
Рассмотрим функцию оболочки, которая делает команды для работы с файлами такими мощными. Поскольку оболочка так много использует имена файлов, она предоставляет специальные символы для помощи вам быстро указывать группы имён файлов. Эти специальные символы называются подстановочными. Использование подстановочных символов позволяет вам выбирать имена на основе шаблонов символов. Таблица ниже содержит список подстановочных символов и что они выбирают:

Подстановочный символ	Значение
*	Соответствует любым символам
?	Соответствует любому единичному символу
[символы]	Соответствует любому символу, который является членом набора символов
[!символы]	Соответствует любому символу, который не является членом набора символов
[[:класс:]]	Соответствует любому символу, который является членом указанного класса
В следующей таблице представлен список самых часто используемых классов символов:

Класс символов	Значение
[:alnum:]	Соответствует любому алфавитно-цифровому символу
[:alpha:]	Соответствует любому алфавитному символу
[:digit:]	Соответствует любому цифровому символу
[:lower:]	Соответствует любой цифре
[:upper:]	Соответствует любой букве в нижнем регистре
Использование подстановочных символов делает возможным конструировать очень замысловатые критерии выбора для имён файлов. Далее несколько примеров шаблонов и их значений:

Шаблон	Совпадает с
*	Все файлы
g*	Любые файлы, начинающиеся с «g»
b*.txt	Любые файлы, начинающиеся с «b», за которым следует любой символ и заканчивающиеся на «.txt»
Data???	Любой файл, начинающийся с «Data», за которой следуют ровно три символа
[abc]*	Любой файл, начинающийся либо с «a», либо с «b», либо с «c»
BACKUP.[0-9][0-9][0-9]	Любой файл, начинающийся с «BACKUP.» за которым следуют ровно три цифры
[[:upper:]]*	Любой файл, начинающийся с заглавной буквы
[![:digit:]]*	Любой файл, начинающийся с цифры
*[[:lower:]123]	Любой файл, заканчивающийся на букву в нижнем регистре или цифру «1», «2» или «3»
Подстановочные символы могут использоваться с любыми командами, которые принимают имена файлов в качестве аргументов.

## Диапазоны символов
Если вы пришли из другого Unix-подобного окружения или читали какие-либо книги по данной теме, вы могли сталкиваться с обозначениями диапазонов символов [A-Z] или [a-z]. Это традиционные Unix обозначения также работавшие в старых версиях Linux. Они ещё могут работать, но вы с ними должны быть очень осторожны, поскольку они не воспроизведут ожидаемого результата если не настроены должны образом. На данный момент вам следует избегать использовать их, используйте вместо них классы символов.

Подстановочные символы работают также и в графическом пользовательском интерфейсе
Подстановочные символы особенно ценны не только от того, что они так часто используются в командной строке, но и по той причине, что они поддерживаются некоторыми графическими файловыми менеджерами.

В Nautilus (файловый менеджер для GNOME) или в Nemo (файловый менеджер для Cinnamon) вы можете выбрать файлы используя Правка - > Выделить по шаблону… Просто введите шаблон с подстановочными символами для выбора файлов и вы увидите, что соответствующие шаблону файлы подсвечены.


В некоторых версиях Dolphin и Konqueror (файловые менеджеры в KDE), вы можете ввести подстановочные символы прямо в адресную строку. Например, если вы хотите увидеть все файлы, начинающиеся с маленькой буквы «u» в директории /usr/bin, введите «/usr/bin/u*» в адресную строку и файловый менеджер покажет результат.
Многие идеи, изначально появившиеся в интерфейсе командной строке, перешли также в графический интерфейс. Это одна из многочисленных вещей, которые делают настольный компьютер с Linux таким мощным.

Термин оболочки «expansion» – раскрытие или подстановка?
В русскоязычной литературе «expansion» из документации Bash часто переводят как подстановка. Внешне этот процесс выглядит именно так – вместо одних символов в командной строке появляются другие символы или новые слова. Но если заглянуть глубже, то имеет место не механическая подстановка («найти символ звёздочка и заменить её на набор слов bin Видео Документы Загрузки Изображения Музыка Общедоступные Рабочий стол Шаблоны»), а именно расширение, раскрытие значения. Значение, которое может иметь * в командной строке, зависит от того, в какой директории пользователь запустил эту команду и что содержится в этой директории.

Аналогично выражение

    echo $(((5**2) * 3))
не подставляется в командной строке на

    75

Это выражение вычисляется, т.е. раскрывается его значение, которое равно 75 и которое выводится в окно терминала.

Тем не менее, использование слов «раскрытие» или «подстановка», в первую очередь, обусловлено привычкой, поскольку, как уже отмечено выше, визуально, интуитивно, происходит именно подстановка. Для меня более привычным является слово «раскрытие», поэтому именно оно будет далее использоваться в этом материале.

## Раскрытие
Каждый раз, когда вы печатаете строку команды и нажимаете клавишу ENTER, bash выполняет несколько обработок текста перед выполнением вашей команды. Простая последовательность символов, например, «*», может иметь много значений для оболочки. Процесс, который отвечает за то, чтобы это происходило, называется раскрытие. С раскрытием вы вводите что-то и это расширяется до чего-то ещё перед тем, как оболочка воздействует на него. Для демонстрации, что мы имеем ввиду под этими словами, давайте взглянем на команду echo. echo является встроенной в оболочку и выполняет очень простую задачу. Она печатает текстовые аргументы в стандартный вывод:

    echo this is a test
    this is a test
Это очень просто. Любой аргумент, переданный echo, отображается. Давайте попробуем другой пример:

    echo *
bin Видео Документы Загрузки Изображения Музыка Общедоступные Рабочий стол Шаблоны


Что произошло? Почему echo не напечатала «*»? Как вы уже знаете о подстановочных символах, символ «*» означает соответствие любому символу в имени файла. Как оболочка делает это? Простой ответ такой: оболочка раскрывает «*» в что-либо другое (в данном случае, имена файлов в текущей рабочей директории) перед выполнением команды echo. Когда нажимается кнопка ENTER, оболочка автоматический раскрывает любые квалификационные символы в командной строке перед тем, как команда выполняется, поэтому команда echo никогда не видит «*», а видит только раскрытый результат. Зная это, вы можете видеть, что echo ведёт себя как и ожидалось.

## Раскрытие пути к файлу
Механизм, по которому работают подстановочные символы, называется раскрытие пути к файлу.

Заданная домашняя директория выглядит примерно так:

    ls
    bin    Документы  Изображения  Общедоступные  Шаблоны
    Видео  Загрузки   Музыка       Рабочий стол
мы можем выполнить следующие раскрытия:

    echo Д*
    Документы
и:

    echo *ы
    Документы Шаблоны


или даже (про классы символов будет ниже):

    echo [[:upper:]]*
    Видео Документы Загрузки Изображения Музыка Общедоступные Рабочий стол Шаблоны


и заглянуть за пределы нашей домашней директории:

    echo /usr/*/share
    /usr/local/share
## Раскрытие пути к файлу для скрытых файлов
Как мы знаем, имена файлов, которые начинаются с символа точки, являются скрытыми. Раскрытие пути к файлу также уважает это поведение. Такое раскрытие как:

    echo *
не выдаст скрытые файлы.

На первый взгляд может показаться, что мы могли бы включить скрытые файлы в раскрытие начав шаблон с точки, примерно так:

    echo .*
Это почти работает. Тем не менее, внимательнее изучив результаты, мы увидим, что имена «.» и «..» также присутствуют в этих результатах. Поскольку эти имена указывают на текущую рабочую директорию и её родительскую директорию, использование этого шаблона вероятно выдаст некорректный результат. Мы можем увидеть это если попробуем команду:

    ls -d .* | less


Для улучшенного раскрытия пути до файла в этой ситуации, мы должны взять на вооружение более конкретный шаблон:

    echo .[!.]*
Этот шаблон раскрывается в каждое имя файла, которое начинается с точки, не включает вторую точку, и за которым следует любой другой символ. Это будет работать корректно с большинством скрытых файлов (хотя имена, начинающиеся с нескольких точек, не будут включены). Команда ls с опцией -A («почти всё») обеспечит корректным списком скрытых файлов:

    ls -A
## Раскрытие тильды
Возможно, вам уже доводилось видеть, что для команды cd символ тильды «~» имеет специальное значение. Когда используется в начале слова, она раскрывается в имя домашней директории названного пользователя, если пользователь не назван, то в домашнюю директорию текущего пользователя:

    echo ~
    /home/mial
Если пользователь «foo» имеет учётную запись, тогда:

    echo ~foo
    /home/foo
## Арифметическое раскрытие
Оболочка позволяет выполнять через раскрытие арифметические действия. Это позволяет нам использовать строку ввода оболочки в качестве калькулятора:

    echo $((2 + 2))
    4
Арифметическое раскрытие использует форму:

    $((выражение))
где выражение – это арифметическое выражение, состоящее из величин и арифметических операторов.

Арифметическое раскрытие поддерживает только целые числа (числа без дробной, десятичной части), но может выполнять довольно много различных операций. Вот несколько из поддерживаемых операторов:

Оператор	Описание
+	Сложение
-	Вычитание
*	Умножение
/	Деление (но помните, поскольку раскрытие поддерживает только целые числа, результатом будет целое число.)
%	Остаток от целочисленного деления
**	Возведение в степень
Пробелы не играют роли в арифметических выражениях и выражения могут быть вложенными. Например, для умножения 5 в квадрате на 3:

    echo $(($((5**2)) * 3))
    75
Одиночные круглые скобки могут использоваться для группировки нескольких подвыражений. Этой техникой вы можете переписать пример выше и получить результат используя единичное раскрытие вместо двух:

    echo $(((5**2) * 3))
    75
Здесь пример использования операторов деления и остатка от целочисленного деления. Обратите внимание на эффект от целочисленного деления:

    echo Пять делить на два равняется $((5/2))
    Пять делить на два равняется 2
    echo с остатком $((5%2)).
    с остатком 1.


## Раскрытие фигурных скобок
Самыми странными раскрытиями являются раскрытие фигурных скобок. С ним вы можете создать несколько текстовых строк из шаблона, содержащего фигурные скобки. Вот пример:

    echo Front-{A,B,C}-Back
    Front-A-Back Front-B-Back Front-C-Back
Шаблоны для раскрытия фигурных скобок могут содержать начальную часть, называемой преамбулой, и конечную часть, называемую постскриптум. Само выражение в фигурных скобках может содержать либо список разделённых запятой строк, либо диапазон целых чисел или единичные символы. Шаблон не может содержать включённых белых пробелов. Далее пример, использующий диапазон целых чисел:

    echo Number_{1..5}
    Number_1 Number_2 Number_3 Number_4 Number_5
Целые числа могут быть также дополнены нулями:

    echo {01..15}
    01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
 
    echo {001..15}
    001 002 003 004 005 006 007 008 009 010 011 012 013 014 015
Диапазон букв в обратном порядке:

    echo {Z..A}
    Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
Выражения в фигурных скобках могут быть вложенными:

    echo a{A{1,2},B{3,4}}b
    aA1b aA2b aB3b aB4b
## Раскрытие параметров
Для нашего знакомства мы весьма кратко коснёмся раскрытия параметров. Эта функция больше полезна для скриптов оболочки чем непосредственно в командной строке. Многое из возможностей раскрытия параметров связано со способностью системы хранить маленькие кусочки данных, каждому из которых она даёт имя. Много таких кусочков, которые правильнее называть переменные, доступны для вашего исследования. Например, переменная с именем «USER» содержит ваше имя пользователя. Для вызова раскрытия параметра и показа содержимого USER можно сделать так:

    echo $USER
    mial
Для просмотра доступных переменных, попробуйте это:

    printenv | less
Может быть вы заметили, что с другими типа раскрытия, если вы неправильно напечатали шаблон, раскрытие не будет иметь место и команда echo просто отобразит неправильно набранный шаблон. С раскрытием параметров, если вы ошиблись в написании имени переменной, раскрытие всё равно будет иметь место, но вернёт пустую строку:

    echo $SUER


## Подстановка команд
Подстановка команд позволяет нам использовать вывод команды раскрытия:

    echo $(ls)
    bin Видео Документы Загрузки Изображения Музыка Общедоступные Рабочий стол Шаблоны
Ещё один полезный пример:

    ls -l $(which cp)
    -rwxr-xr-x 1 root root 151024 мар  2 21:07 /bin/cp
Здесь мы передаём результаты which cp в качестве аргументов команде ls, тем самым получаем листинг программы cp без необходимости знать полный путь до файла. Мы не ограничены только простыми командами. Можно использовать несколько команд, в том числе передачу данных от одной к другой по трубе:

    file $(ls -d /usr/bin/* | grep zip)


В этом примере результат выполнения ls -d /usr/bin/* (показывает файлы и каталоги в директории /usr/bin/) передаётся по трубе на стандартный ввод команде grep zip (отфильтровывает только те, которые содержат в пути до файла строку «zip»). Результат выполнения этих двух команд становится списком аргументов команды file.

В более старых программах оболочек имеется альтернативный синтаксис для подстановки команд, который также поддерживается в bash. Вместо знака доллара и круглых скобок, он использует обратные кавычки:

    ls -l `which cp`
    -rwxr-xr-x 1 root root 151024 мар  2 21:07 /bin/cp
## Использование кавычек в командной строке
Теперь, когда мы увидели, сколько много способов у оболочки для выполнения раскрытий, настало время научиться, как мы можем контролировать это. Например:

    echo это просто      тест
    это просто тест


или:

    echo Общая сумма равна $100.00
    Общая сумма равна 00.00


В первом примере разбитие слов оболочкой удалила дополнительные белые пробелы из списка аргументов команды echo. Во втором примере раскрытие параметра подставило пустую строку для значения «$1» поскольку это была неопределённая величина. Для подавления ненужных раскрытий в командах оболочки используются кавычки.

## Двойные кавычки
Первым типом кавычек, которые мы начнём рассматривать, являются двойные кавычки. Если мы разместите текст внутри двойных кавычках, все специальные символы, используемые оболочкой, потеряют своё специальное значение и будут обрабатываться как обычные символы. Исключением являются «$», «\» (обратный слеш) и «`» (обратная кавычка). Это означает, что подавляются разбитие слов, раскрытие пути к файлу, раскрытие тильды и раскрытие фигурных скобок, но раскрытие параметра, арифметическое раскрытие и подстановка команд всё ещё выполняются. Используя двойные кавычки, мы можем совладать с именами файлов, содержащими включённые пробелы. Допустим, мы стали несчастной жертвой файла под названием два слова.txt. Если мы пытались использовать его в командной строке, разбитие слов приводило к тому, что это имя обрабатывалось как два раздельных аргумента, а не как желаемый единый аргумент:

    ls два слова.txt
    ls: невозможно получить доступ к 'два': Нет такого файла или каталога
    ls: невозможно получить доступ к 'слова.txt': Нет такого файла или каталога
Используя двойные кавычки, мы останавливаем разбитие слов и получаем желаемый результат; более того, мы даже можем восстановить повреждение:

    ls -l "два слова.txt"
    -rw-rw-r-- 1 mial mial 1 июл 29 06:57 два слова.txt
    mv "два слова.txt" два_слова.txt
Вот оно! Теперь нам даже не нужно печатать эти надоедливые двойные кавычки.

Помните, раскрытие параметров, арифметические выражения и подстановка команд всё равно имеют место внутри двойных кавычек:

    echo "$USER $((2+2)) $(cal)"


Нам следует затратить немного времени, чтобы взглянуть на эффект двойных кавычек на подстановку команд. Начнём с того, что заглянем глубже, как работает разделение слов. В одном из наших предыдущих примерах мы видели, как разбитие слов проявляется в удалении дополнительных пробелов в нашем тексте:

    echo это просто      тест
    это просто тест
По умолчанию, разбитие слов ищет присутствие пробелов, табуляций, символов новой строки и разрыва страницы и трактует их как разделители между словами. Это означает, что без кавычек пробелы, табуляции, символы новой строки не расцениваются как часть текста. Они служат только разделителями. Поскольку они разделяют слова на различные аргументы, строка команды в нашем примере содержит команду, за которой следует четыре раздельных аргумента. Если мы добавим двойные кавычки:

    echo "это просто      тест"
    это просто      тест


разбитие слов подавлено и включённые пробелы не обрабатываются как разделители, они все становятся частью аргумента. Как только добавлены двойные кавычки, наша строка команды содержит команду, за которой следует единичный аргумент.

Тот факт, что символы новой строки механизмом разбития слов рассматриваются как разделители, приводит к интересному, хотя и тонкому эффекту на подстановку команд. Рассмотрим следующее:

    echo $(cal)
    Июль 2017 Вс Пн Вт Ср Чт Пт Сб 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
    echo "$(cal)"
        Июль 2017        
    Вс Пн Вт Ср Чт Пт Сб  
                    1  
    2  3  4  5  6  7  8  
    9 10 11 12 13 14 15  
    16 17 18 19 20 21 22  
    23 24 25 26 27 28 29  
    30 31


В первом случае подстановка команды без кавычек стало результатом появления в строке команды 38 аргументов. Во втором имеется строка команды с одним аргументом, который включает внедрённые проблемы и символы новой строки.

## Одинарные кавычки
Если нам нужно подавить все раскрытия, мы используем одинарные кавычки. Далее сравниваются отсутствие кавычек, двойные кавычки и одинарные кавычки:

    echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
    text /home/mial/два_слова.txt a b foo 4 mial
    echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
    text ~/*.txt {a,b} foo 4 mial
    echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
    text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER


Как мы можем видеть, с каждым последующим уровнем использования кавычек, подавляется больше и больше раскрытий.

Смотрите также Как использовать кавычки в регулярных выражениях grep.

## Экранирование символов
Иногда нам нужно заключить в кавычки только единичный символ. Этот же эффект можно получить, если перед символом поставить обратный слеш, который в этом контексте называется экранирующим символом. Часто это делается внутри двойных кавычек, чтобы выборочно предотвратить раскрытие

    echo "Баланс для пользователя $USER равен: \$5.00"
    Баланс для пользователя mial равен: $5.00
Также популярно экранирование для устранения специального значения символа в имени файла. Например, возможно использовать символы в именах файлах, которые обычно имеют специальные значения для оболочки. Сюда могут быть отнесены «$», «!», «&», « » и другие. Для включения специального символа в имя файла вы можете делать так:

    mv плохое\&имя\ файла хорошее_имя_файла
Чтобы появился сам символ обратного слеша, экранируйте его набрав «\\». Обратите внимание, что внутри одинарных кавычек обратный слеш теряет своё специальное значение и обрабатывается как обычный символ.

## Управляющие последовательности с обратным слешем
В дополнении к роле экранирующего символа, обратный слеш также используется как часть обозначения в представлении определённых специальных символов, называемых управляющими кодами. Первые 32 символа в схеме кодирования ASCII, используемой для передачи команд телетайп подобным устройствам. Некоторые из этих кодов являются знакомыми (табуляция, возврат на одну позицию, разрыв страницы и возврат каретки), а другие нет (null, конец-передачи и acknowledge).

Управляющая последовательность	Значение
\a	Звонок («сигнал тревоги» - делает так, что компьютер издаёт сигнал)
\b	Возврат на одну позицию
\n	Новая строка. На Unix подобных системах это воспроизводит разрыв страницы.
\r	Возврат каретки
\t	Табуляция
Таблица выше приводит список некоторых популярных управляющих последовательностей с обратным слешем. Идея в таком представлении – с использованием обратных слешей – происходит из языка программирования C, она была принята многими другими, в том числе оболочкой.

Добавление опции «-e» к echo включит интерпретацию управляющих последовательностей. Вы также можете разместить их внутри $' '. Здесь, используя команду sleep (простая программа, которая просто ждёт указанное количество секунд, а затем завершает работу), мы можем создать примитивный таймер обратного отчёта:

    sleep 10; echo -e "Время просыпаться\a"
Мы также можем сделать это:

    sleep 10; echo "Время просыпаться" $'\a'
## Традиционные диапазоны символов и классы символов POSIX
Говоря о подстановочных символах, мы коснулись вопроса применения диапазонов символов. Как было показано выше, они могут использоваться для раскрытия пути до файла. Также диапазоны символов применяются, например, в шаблонах для команды grep. Было отмечено, что использование традиционных обозначений [A-Z] или [a-z] может привести к неожиданным результатам. Сейчас мы разберёмся, в чём проблема с традиционными обозначениями диапазонов.

Традиционные диапазоны символов ясны для понимания и с их помощью можно легко задать любой желаемый диапазон. К сожалению, они не всегда работают.

По идее, набор символов [ABCDEFGHIJKLMNOPQRSTUVWXYZ] должен быть идентичным диапазону символов [A-Z]. Следовательно, следующие две команды должны приводить к идентичному результату, проверим:

    ls /usr/sbin/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*
    ls /usr/sbin/[A-Z]*


Как видно из скриншота, результат выполнения команд очень сильно различается. Первая команда даёт ожидаемый результат – все файлы из директории /usr/sbin/, которые начинаются с заглавной буквы.

В чём дело? Это длинная история, вот её короткая версия:

Раньше, когда Unix только был разработан, было известно только об ASCII символах и с эхом этой особенности связана рассмотренная выше ситуация. В ASCII первые 32 символа (номера 0-31) являются контрольными кодами (вещи вроде табов, возвратов на один символ и возврат каретки). Следующие 32 (32-63) содержат печатные символы, включая самые популярные символы и цифры с нуля до девяти. Следующие 32 (номера 64-95) содержат буквы в верхнем регистре и ещё несколько пунктуационных символов. Последние 31 (числа 96-127) содержат буквы в нижнем регистре и ещё пунктуационных символов. На основе этой организации, системы, использующие ASCII, использовали порядок сортировки, выглядящий примерно так:

    ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
Это отличается от правильного алфавитного словарного порядка, который выглядит примерно так:

    aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
По мере разрастания популярности Unix за пределы Соединённых Штатов, выросла потребность в поддержке символов отсутствующих в американском английском языке. Таблица ASCII была расширена для использования полных восьми бит, добавив номера символов 128-255, которые разместили много больше языков. Для поддержки это возможности, стандарты POSIX представили концепцию под названием локаль (locale), которая может быть настроена для выбора необходимых символов для конкретной локации. Мы можем увидеть языковые настройки нашей системы используя эту команду:

    echo $LANG
    ru_RU.UTF-8
С этой настройкой POSIX-совместимые приложения будут использовать словарный порядок сортировки, а не ASCII порядок. Это объясняет поведение команды выше. Диапазон символов [A-Z], когда интерпретируется в словарном порядке, включает все алфавитные символы кроме «a», отсюда и наши результаты.

Чтобы частично решить эту проблему, стандарт POSIX включает ряд классов символов, которые обеспечивают полезные диапазоны символов. Они описаны в таблице ниже:

Класс символов	Описание
[:alnum:]	Алфавитно-цифровые символы. В ASCII эквивалентно: [A-Za-z0-9]
[:word:]	То же самое, что и [:alnum:], с дополнительным символом подчёркивания (_).
[:alpha:]	Алфавитные символы. В ASCII эквивалентно: [A-Za-z]
[:blank:]	Включает символы пробела и табуляции.
[:cntrl:]	Управляющие коды ASCII. Включает ASCII символы с 0 до 31 и 127.
[:digit:]	Цифры от нуля до девяти.
[:graph:]	Видимые символы. В ASCII сюда включены символы с 33 по 126.
[:lower:]	Буквы в нижнем регистре.
[:punct:]	Символы пунктуации. В ASCII эквивалентно: [-!»#$%&'()*+,./:;<=>?@[\\\]_`{|}~]
[:print:]	Печатные символы. Все символы в [:graph:] плюс символ пробела.
[:space:]	Символы белых пробелов, включающих пробел, табуляцию, возврат каретки, новую строку, вертикальную табуляцию и разрыв страницы. В ASCII эквивалентно: [ \t\r\n\v\f]
[:upper:]	Символы в верхнем регистре.
[:xdigit:]	Символы, используемые для выражения шестнадцатеричных чисел. В ASCII эквивалетно: [0-9A-Fa-f]
Внимание: в зависимости от настроек локали, [:alnum:], [:word:], [:alpha:] и другие буквенные диапазоны могут включать буквы вашего алфавита, например, русского. Т.е. [:alpha:] может соответствовать не [A-Za-z], а [A-Za-zА-Яа-я].

Даже с классами символов, всё ещё нет удобного способа для выражения частичных диапазонов, таких как [A-M].

Используя классы символов, мы можем повторить наш листинг директории чтобы увидеть улучшенный результат:

    ls /usr/sbin/[[:upper:]]*
Классы символов POSIX могут использоваться как в регулярных выражениях, так и для раскрытия пути к файлу.

## Возврат к традиционному порядку сортировки
По вашему выбору вы можете сделать так, чтобы ваша система использовала традиционный (ASCII) порядок сортировки, изменив значение переменной окружения LANG. Как видно выше, переменная LANG содержит имя языка и набор символов, используемый в вашей локали. Изначально это значение было определено, когда вы выбрали язык установки во время установки Linux.

Чтобы увидеть настройки локали, используйте команду locale

    locale
    LANG=ru_RU.UTF-8
    LANGUAGE=ru
    LC_CTYPE="ru_RU.UTF-8"
    LC_NUMERIC="ru_RU.UTF-8"
    LC_TIME="ru_RU.UTF-8"
    LC_COLLATE="ru_RU.UTF-8"
    LC_MONETARY="ru_RU.UTF-8"
    LC_MESSAGES="ru_RU.UTF-8"
    LC_PAPER="ru_RU.UTF-8"
    LC_NAME="ru_RU.UTF-8"
    LC_ADDRESS="ru_RU.UTF-8"
    LC_TELEPHONE="ru_RU.UTF-8"
    LC_MEASUREMENT="ru_RU.UTF-8"
    LC_IDENTIFICATION="ru_RU.UTF-8"
    LC_ALL=
Для изменения локали для использования традиционных поведений Unix, установите переменную LANG на POSIX:

    export LANG=POSIX
Помните, что это изменение переводит систему на использование американского английского языка (ещё более точно ASCII) для её набора символов, поэтому убедитесь, действительно ли это то, чего вы хотите.

Вы можете сделать это изменение постоянным, добавив эту строку в ваш файл .bashrc:

    export LANG=POSIX
Заключение
По мере продолжения знакомства с оболочкой, вы увидите, что раскрытия и использование кавычек будет использоваться с нарастающей частотой, поэтому имеет смысл хорошо понять, как они работают. Можно спорить, являются ли эти вопросы самыми важными темами в изучении оболочке. Но несомненно, что без должного понимания раскрытия, оболочка всегда будет источником непонятного и сбивающего с толку, и значительная часть её потенциальной мощи будет потеряна.