# https://zalinux.ru/?p=1330

## Оглавление
1. Команда find

2. Синопсис find

3. Описание find

4. Опции find

5. Выражение find

5.1 Позиционные опции find

5.2 Глобальные опции find

5.3 Тесты find

5.4 Действия find

5.5 Операторы find

6. Необычные имена файлов

7. Соответствие стандартам

8. Переменные окружения find

9. Примеры использования find

10. Статус выхода find

11. Смотрите также

12. История find

13. Не являются ошибками find

14. Баги find

## Синопсис find

    find [-H] [-L] [-P] [-D debugopts] [-Olevel] [начальная-точка...] [выражение]
## Описание find

Эта страница мануала документирует GNU версию find. GNU find ищет от корня начальной-точки по дереву каталогов, оценивая заданное выражение слева направо в соответствии с правилами приоритета (смотрите раздел Операторы), пока не будет известен исход (левая часть является false для операций and (и), true для or), в этом момент find переходит к следующему имени файла. Если не указана начальная-точка, то подразумевается «.».

Если вы используете find в окружении где важна безопасность (например, если вы используете её для поиска по директориям, в которые могут записывать другие пользователи), вам следует прочитать раздел «Security Considerations» документации findutils, которая называется Finding Files и поставляется с findutils. Этот документ также включает больше подробностей и обсуждений, чем эта страница мануала, следовательно, вы можете найти её более полезным источником информации (для доступа наберите info find).

## Опции find
Опции -H, -L и -P управляют обработкой символических ссылок. Аргументы командной строки, которые следуют за ними, принимаются как имена файлов или директорий для поиска, до первого аргумента, начинающегося с «-» или аргумента «(» или «!». Этот аргумент и все последующие аргументы принимаются как выражения, описывающие, что именно ищется. Если не указаны пути, используется текущая директория. Если не дано выражение, то используется выражение -print (но вы, вероятно, должны всё равно подумать об использовании вместо него info find).

Страница мануала говорит об «опциях» внутри списка выражений. Эти опции управляют поведением find, но указываются сразу после последнего пути к файлу. Пять «настоящих» опций -H, -L, -P, -D и -O, если они используются, должны появляться до первого пути к файлу. Также может использоваться двойная черта -- для сигнализации, что любые оставшиеся аргументы не являются опциями (хотя гарантия, что все начальные точки начинаются с «./» или с «/» это обычно безопаснее, если вы используете подстановочные символы в списке начальных точек).

    -P

Никогда не следовать символическим ссылкам. Это поведение по умолчанию. Если find исследует или печатает информацию о файле, а файл является символической ссылкой, используемая информация должна быть взята из свойств самой символической ссылки.

    -L

Следовать символическим ссылкам. Когда find исследует или печатает информацию о файлах, используемая информация должна браться из свойств файла на который указывает ссылка, а не от самой ссылки (если это не сломанная символическая ссылка или find не может исследовать файл, на который эта ссылка указывает). Использование этой опции подразумевает -noleaf. Если вы позднее используете опцию -P, -noleaf всё равно будет в силе. Если в силе -L и find обнаружил во время поиска символическую ссылку на поддиректорию, будет проведён поиск по поддиректории, на которую указывает симлинк.

Когда в силе опция -L, предикат -type будет всегда соответствовать типу файла, на который указывает символическая ссылка, а не самой ссылке (если символическая ссылка не является сломанной). Действия, которые могут стать причиной поломки символических ссылок во время выполнения find (например, -delete), могут привести к запутанному поведению Использование -L приводит к тому, что предикаты -lname и -ilname всегда возвращают false.

    -H

Не следовать символическим ссылкам, кроме во время обработки аргументов командной строки. Когда find исследует или печатает информацию о файлах, используемая должна быть взята из свойств самой символической ссылки. Единственное исключение из этого поведения, когда файл указан в командной строке является символической ссылкой и ссылка может быть преобразована. Для этой ситуации используемая информация берётся из того, на что указывает ссылка (куда следует ссылка). Информация о самой ссылке используется как резерв если файл, на который указывает символическая ссылка, не может быть проанализирован. Если -H имеет действие и один из указанный в командной строке путей является символической ссылкой на директорию, будет исследовано содержимое этой директории (хотя, конечно, -maxdepth 0 предотвратило бы это).

Если указана более чем одна из -H, -L и -P, каждая перезаписывает другие; последняя появившаяся в строке команды опция вступает в силу. Поскольку она является значением по умолчанию, опция -P должна рассматриваться как имеющая силу, если какая-либо из -H или -L не указаны.

GNU find часто получает статус файла (stat) во время обработки самой строки команды, перед началом поиска. Эти опции также влияют, как эти аргументы обрабатываются. А именно, имеется ряд тестов, которые сравнивают файлы, перечисленные в строке команды, с текущим рассматриваемым файлом. В каждом случае, указанный в строке команды файл будет анализироваться и некоторые из его свойств будут сохранены. Если названный файл является в действительности символической ссылкой, и опция -P имеет действие (или если ни -H, ни -L не указаны), используемая для сравнения информация будет взята из свойств символической ссылки. В противном случае, она будет взята из свойств файла, на который указывает ссылка. Если find не может проследовать по ссылке (например, из-за недостаточных привилегий или ссылка указывает на несуществующий файл), то будут использованы свойства самой ссылки.

Когда имеют действие опции -H или -L, по любым символическим ссылкам, перечисленным как аргумент -newer, будет сделан переход, и временные метки будут взяты из файла, на который указывает символическая ссылка.

Это же соображение применимо к -newerXY, -anewer и -cnewer.

Опция -follow имеет схожий эффект с -L, хотя она вступает в силу в точке, где она появилась (так, если -L не используется, но используется -follow, по любым символическим ссылкам, стоящим после -follow в строке команды, будет сделан переход, а по тем, которые стоят до неё, переход сделан не будет).

    -D опции отладки

Выводить диагностическую информацию; это может быть полезно для определения проблем, почему find не делает что вы хотите. Список опций отладки должен быть разделён запятой. Совместимость опций отладки не гарантировано между релизами findutils. Для полного списка валидных опций отладки смотрите вывод:

    find -D help
Валидные опции отладки включают

    help

Объяснение опций отладки

    tree

показать дерево выражения в оригинальной и оптимизированной форме.



    search

Вербально переходить по дереву каталогов.

    stat

Печатать сообщения при анализе сайтов с системными вызовами stat и lstat. Программа find пытается минимизировать такие вызовы.

    opt

Печатать диагностическую информацию, относящуюся к оптимизации дерева выражения; смотрите опцию -O;

    rates

Печатать краткую информацию о том, как часто предикат был успешен или потерпел неудачу.

    exec

Показать диагностическую информацию, относящуюся к -exec, -execdir, -ok и -okdir

    -Olevel

Включает оптимизацию запросов. Программа find меняет порядок тестов для ускорения выполнения при этом сохраняя общий эффект; предикаты со сторонними эффектами не меняют порядка относительно друг друга. Оптимизация выполняется на каждом уровне оптимизации так, как описано ниже.

    0

Эквивалент уровню оптимизации 1.

    1

Это уровень оптимизации по умолчанию, и он соответствует традиционному поведению. Меняется порядок выражений так, чтобы тесты на основе имён файлов (например, -name и -regex) выполнялись первыми.

    2

Любые тесты -type или -xtype выполняются после любых тестов на основе только имён файлов, но перед тестами, которые требуют информацию из иноды. На многих современных версиях Unix типы файлов возвращаются от readdir() и поэтому эти предикаты быстрее для оценки чем предикаты, которым вначале нужно выполнить stat в отношении файла. Если вы используете предикат -fstype FOO и указали тип файловой системы FOO, который не являются известным (т.е. присутствующим в «/etc/mtab») в момент, когда запускается find, этот предикат эквивалент -false.

    3

На этом уровне оптимизации, включён полный оптимизатор запросов на основе их затрат. Порядок тестов изменяется так, чтобы дешёвые (т.е. быстрые) тесты выполнялись первыми, а более дорогие выполнялись позже, если они вообще понадобятся. Внутри каждого диапазона цен, предикаты оцениваются раньше или позже на предмет вероятности, будут ли они успешными или нет. Для -o, предикаты, которые с большей вероятностью будут успешными, вычисляются ранее, а для -a предикаты, которые с большей вероятностью будут неудачными, вычисляются ранее.

Оптимизатор, основанный на затратах имеет фиксированную идею, с какой вероятностью любой заданный текст будет успешным. В некоторых случаях вероятность учитывается из специфической природы теста (например, -type f предполагается быть более успешным, чем -type c). Оптимизатор , основанный на затратах, в настоящее время проходит оценку. Если на самом деле он не улучшает производительность find, он снова будет удалён. Напротив, оптимизации, которые доказали свою надёжность, крепость и эффективность со временем могут быть включены на более низких уровнях оптимизации. Тем не менее, поведение по умолчанию (т.е. уровень оптимизации 1) не будет изменено в серии релизов 4.3.x. Набор тестов findutils запускает все тесты над find на каждом уровне оптимизации и гарантирует, что результаты являются одинаковыми.

Выражение find
Часть строки команды после списка начальных точек является выражением. Это своего рода спецификация запроса, описывающая, какие файлы являются подходящими и что делать с файлами, которые подошли. Выражение составляется из последовательности следующих элементов:

### Тесты

Тесты возвращают значение true или false, обычно на основе свойств рассматриваемого файла. Тест -empty, например, является true, когда текущий файл является пустым.

### Действия

Действия имеют сторонние эффекты (такие как печать чего-либо в стандартный вывод) и возвращают true или false обычно в зависимости от того, были ли они успешными или нет. Действие -print, например, печатает имя текущего файла в стандартный вывод.

### Глобальные опции

Глобальные опции влияют на обработку указанных глобальных тестов и действий в любой части командной строки. Глобальные опции всегда возвращают true. Например, опция -depth, делает так, что find лазает по файловой системе начиная с глубины.

### Позиционные опции

Позиционные опции влияют только на тесты или действия, которые следуют за ними. Позиционные опции всегда возвращают true. Опция -regextype, например, является позиционной, определяет диалект регулярного выражения для регулярных выражений, которые позже встретятся в командной строке.

### Операторы

Операторы соединяют вместе другие элементы внутри выражения. Они включают, например, -o (означает логическое ИЛИ) и -a (означает логическое И). Где оператор пропущен, подразумевается -a.

Если всё выражение не содержит иных действий кроме -prune или -print, то на все файлы, для которых всё выражение является true, выполняется -print.

Действие -delete также действует как опция (поскольку она применяет -depth).

## Позиционные опции find
Позиционные опции всегда возвращают true. Они влияют только на тесты, встретившиеся в командной строке после них.

    -daystart

Измерять время (для -amin, -atime, -cmin, -ctime, -mmin, и -mtime) от начала сегодняшнего дня, а не от 24 часов назад. Эта опция только влияет на тесты, которые встречаются позже в командной строке.

    -follow

Устаревшая; вместо не используйте -L. Переходить по символическим ссылкам. Применяет -noleaf. Опция -follow оказывает воздействие только на те тесты, которые встречаются после неё в командной строке. Если была указана опция -H или -L, позиция опции -follow меняет поведение предиката -newer; по любым файлам, которые перечислены как аргумент -newer, будет сделан переход если они являются символическими ссылками. Это же суждение применимо к -newerXY, -anewer и -cnewer. Похожим образом, предикат -type всегда будет соответствовать типу файла, на который указывает символическая ссылка, а не самой ссылки. Использование -follow приводит к тому, что предикаты -lname и -ilname всегда возвращают false.

    -regextype тип

Изменяет понимаемый синтаксис регулярных выражений тестов -regex и -iregex, которые встречаются в командной строке. Чтобы увидеть, какие известны типы регулярных выражений, используйте

    find -regextype help
Примеры допустимых типов регулярных выражений find: ‘findutils-default’, ‘awk’, ‘egrep’, ‘ed’, ‘emacs’, ‘gnu-awk’, ‘grep’, ‘posix-awk’, ‘posix-basic’, ‘posix-egrep’, ‘posix-extended’, ‘posix-minimal-basic’, ‘sed’.

Документация Texinfo (см. Смотрите также) объясняет значение и разницу между различными типами регулярных выражений.

-warn, -nowarn

Отключить или включить сообщения с предупреждениями. Эти предупреждения применяются только к использованию командной строки, а не к каким-либо условиям, с которыми find может столкнуться во время поиска по директориям. Поведение по умолчанию соответствует -warn если стандартным выводом является tty, и -nowarn в других случаях. Если созданы сообщения с предупреждениями связанные с использованием командной строки, статус выхода find не затрагивается. Если переменная окружения POSIXLY_CORRECT установлена и также используется -warn, без указания какие (если будут) предупреждения будут активны.

### Глобальные опции find
Глобальные опции всегда возвращают true. Глобальные опции имеют эффект даже для тестов, которые встречаются на командной строке до них. Для предотвращения путаницы, глобальные опции должны быть указаны в командной строке после списка начальных точек, сразу перед первым тестом, позиционной опцией или действием. Если вы указали глобальную опцию в каком-то другом месте, find выведет сообщение, объясняющее, что это может вызвать путаницу.

Глобальные опции вставляются после списка начальных точек и, следовательно, они являются опциями не того же рода, что и, например, -L.

    -d

Синоним для -depth, для совместимости с FreeBSD, NetBSD, MacOS X и OpenBSD.

    -depth

Обрабатывать содержимое каждый директорий перед самой директорией. Действие -delete также применяет -depth.

    -help, --help

Печать краткой информации об использовании find в командной строке и выход.

    -ignore_readdir_race

Обычно find будет испускать сообщение об ошибке при неудачном вызове stat в отношении файла. Если вы зададите эту опцию и файл будет удалён в промежутке между временем, когда find считывает имя файла из директории и временем, когда она пытается выполнить stat в отношении этого файла, сообщение об ошибке не будет выведено. Это также применяется к файлам или директориям, чьи имена даны в командной строке. Эта опция имеет эффект во время, когда считывается командная строка, это означает, что вы не можете искать на одной части файловой системы с включённой этой опцией, а по другой части с выключенной этой опцией (если вам нужно сделать это, вам необходимо запустить две команды find – одну с этой опцией, а другую – без).

    -maxdepth число

Спускаться на максимум число (неотрицательное целое число) уровней директорий вниз от стартовых точек. -maxdepth 0 означает применять тесты и действия только к самим стартовым точкам.

    -mindepth уровни

Не применять какие-либо тесты или действия ниже, чем уровни (неотрицательное целое число). -mindepth 1 означает обрабатывать все файлы, кроме начальных точек.

    -mount

Не спускаться по директориям на других файловых системах. Альтернативное имя для -xdev, для совместимости с другими версиями find.

    -noignore_readdir_race

Отключает действие -ignore_readdir_race.

    -noleaf

Не оптимизировать предполагая, что директории содержат на 2 меньше поддиректорий, чем их счётчик жёстких ссылок. Эта опция нужна при поиске по файловым системам, которые не следуют конвенции Unix по ссылкам в директориях, таким как CD-ROM или файловые системы MS-DOS или точки монтирования AFS. Каждая директория в нормальной файловой системе Unix имеет по крайней мере 2 жёстких ссылки: её имя и пункт «.».

Дополнительно, её субдиректории (если есть), каждая имеет пункт «..» указывающий на эту директорию. Когда команда find анализирует директорию, и в отношении поддиректорий выполнено stat на две меньше, чем счётчик ссылок директорий, то она знает, что оставшиеся записи в списке директорий являются не-директориями (файлы «leaf» в дереве директорий). Если нужно анализировать только имена файлов, то нет нужды выполнять в отношении них stat; это даёт значительное увеличение в скорости поиска.

    -version, --version

 Напечатать версию find и выйти.

    -xdev

Не спускаться по директориям на других файловых системах.

### Тесты find
Некоторые тесты, например, -newerXY и -samefile, позволяют сравнения между файлом на текущем анализе и указанным в строке команды эталонным файлом. Когда используются эти тесты, интерпретация эталонного файла определяется опциями -H, -L и -P и предшествующей -follow, но эталонный файл исследуется только единожды, в момент разбора строки команды. Если эталонный файл не может быть проанализирован (например, системный вызов stat(2) завершился неудачей для него) пишется сообщение об ошибке и find завершается с ненулевым статусом.

Числовые аргументы могут быть указаны как

+n     для более чем n,

-n     для менее чем n,

n      для точного n.

    -amin n

Последний раз к файлу был совершён доступ n минут назад.

    -anewer файл

К файлу был совершён доступ недавнее, чем файл был изменён. Если файл является символической ссылкой и опция -H или опция -L имеют силу, всегда используется время доступа файла, на который указывает ссылка.

    -atime n

К файлу был совершён доступ n*24 часов назад. Когда find определяет, как много 24-часовых периодов назад к файлу был совершён доступ, любая дробная часть игнорируется, поэтому для соответствия -atime +1 к файлу должен быть сделан доступ по крайней мере два дня назад.

    -cmin n

Статус файла был изменён последний раз n минут назад.

    -cnewer файл

Статус файла был последний раз изменён недавнее, чем файл был изменён. Если файл является символической ссылкой и опция -H или опция -L имеют силу, всегда используется время изменения статуса файла, на который указывает ссылка.

    -ctime n

Последний раз статус файла был изменён n*24 часов назад. Смотрите комментарий для -atime для понимания, как округление влияет на интерпретацию времени изменения статуса файла.

    -empty

Файл является пустым и является либо обычным файлом или директорией.

    -executable

Соответствует файлам, которые являются исполнимыми и директориям, пригодными к поиску (в смысле раскрытия имени файла). Это учитывает списки управления доступом и другие артефакты разрешений, которые игнорирует тест -perm. Этот тест использует системный вызов access(2), и поэтому его можно обмануть серверами NFS, которые выполняют сопоставление UID (или root-squashing), поскольку многие системы реализуют access(2) в ядре клиента и поэтому не могут использовать информацию отображения UID, хранящуюся на сервере. Поскольку этот тест основан только на результате системного вызова access(2), нет гарантии, что файл, для которого этот тест успешно завершен, может быть фактически выполнен.

    -false

Всегда false.

    -fstype тип

Файл на файловой системе типа тип. Валидные типы файловых систем различаются среди различных версий Unix; неполный список типов файловых систем, которые принимаются на тех или иных версиях Unix это: ufs, 4.2, 4.3, nfs, tmp, mfs, S51K, S52K. Вы можете использовать -printf с директивой %F чтобы увидеть типы ваших файловых систем.

    -gid n

Числовой ID группы файла равен n.

    -group gname

Файл принадлежит группе gname (разрешён числовой ID группы).

    -ilname шаблон

Как -lname, но совпадение не чувствительно к регистру. Если опция -L или опция -follow имеют силу, это возвращает false за исключением сломанной символической ссылки.

    -iname шаблон

Как -name, но совпадение не чувствительно к регистру. Например, шаблоны «fo*» и «F??» соответствуют именам файлов «Foo», «FOO», «foo», «fOo» и т.д. Шаблон «*foo*» также будет соответствовать файлу под названием «.foobar».

    -inum n

Файл имеет номер иноды n. Обычно проще использовать вместо этого тест -samefile.

    -ipath шаблон

Как -path, но совпадение не чувствительно к регистру.

    -iregex шаблон

Как -regex, но совпадение не чувствительно к регистру.

    -iwholename шаблон

Смотрите -ipath. Эта альтернатива менее портативна чем -ipath.

    -links n

Файл имеет n ссылок.

    -lname шаблон

Файл является символической ссылкой, чьё содержимое совпадает с шаблоном оболочки шаблон. Метасимволы не обрабатывают специально «/» или «.». Если имеют действие опция -L или опция -follow, этот тест возвращает false за исключением сломанной символической ссылки.

    -mmin n

Данные файла последний раз были изменены n минут назад.

    -mtime n

Данные файла были изменены последний раз n*24 часов назад. Смотрите комментарий для -atime для понимания, как округление влияет на интерпретацию времени модификации файла.

    -name шаблон

Базовое имя файла (без начального пути с директориями) соответствует шаблону оболочки шаблон. Поскольку начальные директории удаляются, рассматриваемые на совпадение с -name имена файлов никогда не будут включать слеш, поэтому «-name a/b» никогда не будет соответствовать чему-либо (вероятно, вам вместо этого нужно использовать -path). Будет выведено предупреждение, если вы попытаетесь сделать это, если не установлена переменная окружения POSIXLY_CORRECT. Метасимволы («*», «?» и «[]») соответствуют «.» на начале базового имени (это изменено в findutils-4.2.2; смотрите ниже раздел Соответствие стандартам). Для игнорирования директории и файлов в ней, используйте -prune; смотрите пример в описании -path. Фигурные скобки не распознаются как специальные символы, не смотря на факт, что некоторые оболочки, включая Bash, наполняют скобки специальным значением в шаблонах оболочки. Проверка на совпадение имени файла выполняется с использованием функции библиотеки fnmatch(3). Не забудьте заключить шаблон в кавычки, чтобы защитить его от раскрытия оболочкой.

    -newer файл

Файл был изменён недавнее, чем файл. Если файл является символической ссылкой и опция -H или опция -L имеет силу, всегда используется время модификации файла, на который она указывает.

    -newerXY эталон

Успех, если временная метка X анализируемого файла новее, чем временная метка Y эталонного файла. Буквы X и Y могут быть любыми из следующих букв:

    a

Время доступа эталонного файла

    B

Время рождения эталонного файла

    c

Время изменения статуса иноды эталона

    m

Время модификации эталонного файла

    t

Эталон интерпретируется напрямую как время

Некоторые комбинации являются невалидными; например, неверно для X быть t. Некоторые комбинации реализованы не на всех системах; например, B поддерживается не на всех системах. Если указана невалидная или неподдерживаемая комбинация XY, результатом будет фатальная ошибка. Указания времени интерпретируются как аргументы для опции -d программы GNU date. Если вы пытаетесь использовать время рождения эталонного файла, а дата рождения не может быть определена, результатом станет фатальная ошибка. Если вы указали тест, который отсылает к дате рождения анализируемых файлов, тест потерпит неудачу для файлов, чьё имя рождения неизвестно.

    -nogroup

Нет групп, соответствующих числовому ID группы, к которой принадлежит файл.

    -nouser

Нет пользователя, соответствующему числовому ID пользователя, которому принадлежит файл.

    -path шаблон

Имя файла соответствует шаблону оболочки шаблон. Метасимволы не трактуют особо «/» или «.»; т.е., например:

    find . -path "./sr*sc"
напечатает записи для директории, названной «/src/misc» (если она существует). Для игнорирования всего дерева директории, используйте -prune, а не проверку каждого файла в дереве. Например, для пропуска директории «src/emacs» и всех файлов и директорий в ней, и вывода имён всех других найденных файлов, сделайте примерно так:


    find . -path ./src/emacs -prune -o -print
Помните, что тест соответствия шаблона применяется к полному имени файла, начиная с одной из начальных точек, названных в строке команды. Здесь имеет смысл использовать абсолютный путь имени только если соответствующая начальная точка также является абсолютным путём. Это означает, что эта команда никогда не найдёт соответствий:


    find bar -path /foo/bar/myfile -print
Find сравнивает -path аргумент с объединением имени директории и базового имени файла анализируемого файла. Поскольку объединение никогда не закончится слешем, аргументы -path, заканчивающиеся на слеш, ничему не будут соответствовать (кроме, возможно, указанной в строке команды начальной точке). Предикат -path также поддерживается в HP-UX find и будет в предстоящих версиях стандарта POSIX.

    -perm режим

Биты разрешений файла являющиеся точным режимом (восьмеричным или символическим). Поскольку требуется точное соответствие, если вы хотите использовать эту форму для символических режимов, вам может понадобиться указать довольно сложную строку режима. Например, «-perm g=w» будет соответствовать только файлам, которые имеют режим 0020 (т.е. тем, чьи групповые разрешения записи являются единственным набором разрешений). Более вероятно, что вы захотите использовать формы «/» или «-», например, «-perm -g=w», которая соответствует любым файлам с групповыми разрешениями записи. Смотрите в разделе Примеры несколько пояснительных примеров.

    -perm -режим

Для файла установлены все биты разрешений режима. Символические режимы принимаются в этой форме, и обычно это способ, которым вы хотели бы их использовать. Вы должны указать «u», «g» или «o» если вы используете символический режим. Смотрите в разделе Примеры несколько пояснительных примеров использования этой опции.

-   perm /режим

Для файла установлены какие-либо биты разрешений режима. В этой форме принимаются символические режимы. Вы должны указать «u», «g» или «o» если вы используете символический режим. Смотрите в разделе Примеры несколько пояснительных примеров использования этой опции. Если в режиме не установлены биты разрешений, этот тест соответствует любому файлу (идея здесь быть согласующимся поведению -perm -000).

    -perm +mode

Это больше не поддерживается (и была объявлена устаревшей с 2005). Вместо неё используйте -perm /mode.

    -readable

Соответствует читаемым файлам. Тест принимает списки контроля доступа учётных записей и другие артефакты разрешений, которые игнорирует тест -perm. Этот тест использует системный вызов access(2), из-за особенностей которого может быть неточным.

    -regex шаблон

Имя файла соответствует шаблону регулярного выражения. Это не поиск, это соответствие полному пути. Например, для соответствия файла с именем «./fubar3» вы можете использовать регулярное выражение «.*bar.» или «.*b.*3», но не «f.*r3». Регулярными выражениями, которые понимает find, по умолчанию являются Emacs Regular Expressions, но их можно изменить опцией -regextype.

    -samefile имя

Файл ссылается на ту же иноду, что и имя. Когда в действии -L, это может включать символические ссылки.

    -size n[cwbkMG]

Файл использует n единиц пространства, делается округление в большую сторону. Можно использовать следующие суффиксы:

    b

для 512-байтных блоков (это значение по умолчанию, если не используется суффикс)

    c

для байт

    w

для двух-байтных слов

    k

для килобайт (единица из 1024 байт)

    M

для мегабайт (единица из 1048576 байт)

    G

для гигабайт (единица из 1073741824 байт)

Этот размер не учитывает косвенные блоки, но учитывает блоки в разреженных файлах, которые фактически не распределены. Помните, что спецификаторы формата «%k» и «%b» от -printf обрабатывают разреженные файлы по-другому. Суффикс «b» всегда обозначает 512-байтные блоки и никогда блоки в 1 килобайт, что является отличием от поведения -ls. Префиксы + и - означают, как обычно, большее и меньшее значение; но помните, что размер округляется в большую сторону к следующей единице (так 1-байтовый файл не соответствует -size -1M).

    -true

 Всегда true.

    -type c

Файл является типом c:

    b

специальным блочным (буферным)

    c

специальным символьным (небуферным)

    d

директорией

    p

именной трубой (FIFO)

    f

обычным файлом

    l

символической ссылкой; это никогда не true если в силе опция -L или опция -follow за исключением сломанных ссылок. Если вы хотите искать символические ссылки когда в силе -L, используйте -xtype.

    s

сокет

    D

door (Solaris)

    -uid n

Числовой ID пользователя файла равен n.

    -used n

Последний раз к файлу был совершён доступ n дней после последнего изменения его статуса.

    -user uname

 Файл принадлежит пользователю uname (числовой ID пользователя разрешён).

    -wholename шаблон

Смотрите -path. Эта альтернатива менее портативна чем -path.

    -writable

Соответствует файлам, которые являются записываемыми (доступны для записи). Этот тест берёт список контроля доступа учётных данных и другие артефакты, которые игнорирует тест -perm. Этот тест использует системный вызов access(2) и может быть неточным.

    -xtype c

То же самое, что и -type, если файл не является символической ссылкой. Для символических ссылок: если была указана опция -H или -P, true если файл является ссылкой на файл типа c; если была задана опция -L, true если c это «l». Другими словами, для символических ссылок -xtype проверят тип файла, который -type не проверяет.

    -context шаблон

(Только для SELinux) Контекст безопасности файла совпадает с глобальным шаблоном.

### Действия find

    -delete

Удаляет файл; true если удаление прошло успешно. Если удаление потерпело неудачу, будет выведено сообщение об ошибке. Если -delete закончилось неудачей, статус выхода find будет ненулевым. Использование -delete автоматически включает опцию «-depth».

Предупреждение: не забудьте, что команда find оценивает выражения, поэтому разместив на первом месте -delete вы сделает так, что find будет пытаться удалить всё что ниже указанных вами начальных точек. При тестировании команды find, с которой позднее вы собираетесь использовать -delete, явно укажите -depth, чтобы избежать последующих сюрпризов. Поскольку -delete применяет -depth, вы не можете использовать вместе -prune и -delete.

    -exec команда ;

Выполнить команду; true если возвращён 0 статус. Все последующие аргументы find становятся аргументами команды, пока не встретится аргумент состоящий из «;». Строка «{}» везде, где она встречается в аргументах команды, заменяется на имя текущего анализируемого файла. Обе из этих конструкций требует экранирования (с «\») или заключения в кавычки, для предотвращения их раскрытия оболочкой. Смотрите раздел Примеры для примеров использования опции -exec. Указанная команда запускается один раз для каждого совпавшего файла. Команда выполняется в начальной директории. Имеются неизбежные проблемы безопасности вокруг использования действия -exec; вместо неё вам следует использовать опцию -execdir.

    -exec команда {} +

Этот вариант действия -exec запускает указанную команду на выбранные файлы, но командная строка строится добавлением каждого выбранного имени файла к концу; общее число вызова команды будет намного меньшим, чем число совпавших файлов. Строка команды строится во многом схожим образом, как строит свою строку командны xargs. Внутри команды разрешён только один экземпляр «{}». Команда выполняется в начальной директории. Если find сталкивается с ошибкой, это иногда может вызвать немедленный выход, поэтому некоторые отложенные команды вообще могут не быть запущенными. Этот вариант -exec всегда возвращает true.

    -execdir команда ;

    -execdir команда {} +

Похожа на -exec, но указанная команда выполняется из поддиректории, содержащей подошедший файл, которой обычно не является директория, в которой вы запустили find. Это намного более безопасный метод вызова команд, поскольку он избегает гонку условий во время преобразования путей подошедших файлов. Как с действием -exec, «+» форма -execdir будет строить строку команды для обработки более чем одного совпавшего файла, но любые заданные вызовы команды будут содержать в списке файлы, которые размещены в одинаковых поддиректориях. Если вы используете эту опцию, вы должны убедиться, что ваша переменная окружения $PATH не указывает на «.»; в противном случае, атакующий может запускать любые команды по своему усмотрению, покидая надлежащим образом названный файл в директории, в которой вы запускаете -execdir. Это же применимо если у вас в $PATH есть пустые или не являющиеся абсолютными именами директорий записи. Если find сталкивается с ошибкой, это иногда может привести к немедленному выходу, поэтому некоторые ожидающие очереди команды могут быть совсем не запущены. Результат каждого действия зависит от использования + или ; варианта; -execdir команда {} + всегда возвращает  true,  а  -execdir  команда  {} ; возвращает true только если команда вернула 0.

    -fls файл

True; как -ls но записывает файлы как -fprint. Файл вывод всегда создаётся, даже если предикат никогда ни разу не совпал. Смотрите раздел Необычные имена файлов для дополнительной информации об обработке необычных символов в именах файлов.

    -fprint файл

True; печатает полное имя файла в файл файл. Если файл не существует при запуске find, то он создаётся; если он существует, то он усекается. Имена файлов «/dev/stdout» и «/dev/stderr» обрабатываются особым образом; они, соответственно, указывают на стандартный вывод и стандартный вывод ошибок. Файл вывода всегда создаётся, даже если предикат ни разу не совпал. Смотрите раздел Необычные имена файлов для дополнительной информации об обработке необычных символов в именах файлов.

    -fprint0 файл

True; как -print0 но записывает в файл как -fprint. Файл вывода всегда создаётся, даже если предикат ни разу не совпал. Смотрите раздел Необычные имена файлов для дополнительной информации об обработке необычных символов в именах файлов.

    -fprintf файл формат

True;  как  -printf  но записывает в файл как -fprint. Файл вывода всегда создаётся, даже если предикат ни разу не совпал. Смотрите раздел Необычные имена файлов для дополнительной информации об обработке необычных символов в именах файлов.

    -ls

True; выводит в стандартный вывод список текущих файлов в формате ls -dils. Счётчик блоков считает по блокам 1K, если не установлена переменная окружения POSIXLY_CORRECT, в этом случае используются 512-байтные блоки.  Смотрите раздел Необычные имена файлов для дополнительной информации об обработке необычных символов в именах файлов.

    -ok команда ;

Как -exec но сначала спрашивает пользователя.  Если пользователь согласен, запускает команду.  В противном случае возвращает false.  Если команда запущена, её стандартный ввод перенаправляется с /dev/null.

Ответ на запрос проверяется по паре регулярных выражений для определения, был ли ответ положительным или отрицательным. Это регулярное выражение получается от системы, если установлена переменная окружения «POSIXLY_CORRECT», а в других случаях от переводом сообщений find. Если система не имеет подходящего определения, будет использоваться собственное определение find. В любом случае, на интерпретацию самого регулярного выражения будет оказывать влияние переменная окружения «LC_CTYPE» (классы символов) и «LC_COLLATE» (диапазоны символов и классы эквивалентности).

    -okdir команда ;

Как -execdir но сначала спрашивает пользователя как и с -ok.  Если пользователь не согласен просто возвращает false.  Если команда запущена, её стандартный ввод перенаправляется с /dev/null.

    -print

True; печатает полное имя файла в стандартный вывод, за которым следует символ новой строки. Если вы передаёте по трубе вывод find в другую программу и имеется даже маленькая вероятность, что файлы, по которым вы делаете поиск, могут содержать символ новой строки, то вы должны всерьёз рассмотреть использование вместо -print вариант -print0. Смотрите раздел Необычные имена файлов для дополнительной информации об обработке необычных символов в именах файлов.

    -print0

True; печатает полные имена файлов в стандартный вывод, за которыми следует null-символ (вместо символа новой строки, который использует -print). Это позволяет именам, содержащим символ новой строки или другие типы белых пробелов, быть корректно интерпретированными программами, которые обрабатывают вывод find. Эта опция соответствует опции -0 программы xargs.

    -printf формат

True; формат печати в стандартный вывод, интерпретирующий директивы с «\» экранированием и «%». Ширина полей и уточнения могут быть указаны так же, как с C функцией «printf». Пожалуйста имейте ввиду, что многие из полей печатаются как %s а не как %d, и это может означать, что флаги не работают так, как вы могли бы ожидать. Это также означает, что флаг «-» работает (он принуждает поля быть выравненными по левому краю). В отличие от -print, -printf не добавляет символ новой строки к концу строки. Директивы с символом экранирования следующие:

     \a

Сигнальный звонок.

    \b

Возврат на одну позицию.

    \c

Немедленно становить печать из этого формата и смыть вывод.

    \f

Разрыв страницы.

    \n

Новая строка.

    \r

Возврат каретки.

    \t

Горизонтальный таб.

    \v

Вертикальный таб.

    \0

ASCII NUL.

\\

Буквальный обратный слеш («\»).

    \NNN

Символ, чей ASCII код равен NNN (восьмеричный).

Символ «\», за которым следует любой другой символ трактуется как обычный символ, поэтому они будут оба напечатаны.

    %%

Буквальный знак процента.

    %a

Время последнего доступа к файлу, возвращённого C функцией «ctime».

    %Ak

Время последнего доступа к файлу в формате, указанным k, которая является либо «@» или директивой для C функции «strftime». Возможные значения k перечислены ниже; некоторые из них могут быть недоступны на некоторых системах из-за различий «strftime» между системами.

    @

секунды с 1 января, 1970, 00:00 GMT, с дробной частью.

Поля времени:

    H

час (00..23)

    I

час (01..12)

    k

час ( 0..23)

    l

час ( 1..12)

    M

минута (00..59)

    p

AM (до полудня) или PM (после полудня) локали

    r

время, 12-часовой формат (hh:mm:ss [AP]M)

    S

Секунды (00.00 .. 61.00). Имеется дробная часть.

    T

время, 24-часовой формат (hh:mm:ss)

    +

Дата и время, разделённые «+», например «2004-04-28+22:22:05.0». Это расширение GNU. Время даётся в текущей временной зоне (на которую могут влиять настройки переменной окружения TZ). Поле секунд включает дробную часть.

    X

представление времени локали (H:M:S)

    Z

временная зона (т.е., EDT), или ничего, если нет определённой временной зоны

Поля даты:

    a

аббревиатура имени дня недели локали (Sun..Sat)

    A

полное имя дня недели локали, переменная длина (Sunday..Saturday)

    b

аббревиатура имени месяца локали (Jan..Dec)

    B

Полное имя месяца локали, переменная длина (January..December)

    c

дата и время локали (Sat Nov 04 12:02:33 EST 1989). Формат тот же, как для ctime(3) и поэтому для сохранения совместимости с тем форматом, в поле секунд отсутствует дробная часть.

    d

день месяца (01..31)

    D

дата (mm/dd/yy)

    h

то же самое, что и b

    j

день года (001..366)

    m

месяц (01..12)

    U

номер недели в году с воскресеньем в качестве первого дня недели (00..53)

    w

день недели (0..6)

    W

номер недели в году с понедельником в качестве первого дня недели (00..53)

    x

представление даты локали (mm/dd/yy)

    y

последние две цифры года (00..99)

    Y

год (1970…)

    %b

Количество дискового пространства, используемого для этого файла в 512-байтных блоках. Поскольку дисковое пространство распределяется в кратных блокам файловой системы размерах, обычно оно больше чем %s/512, но также может быть меньше, если файлом является разреженный файл.

    %c

Время последнего изменения статуса файла в формате, возвращаемом C функцией «ctime».

    %Ck

Время последнего изменения статуса файла в формате, определённом k, которая точно такая же, как для %A.

    %d

Глубина файла в дереве директорий; 0 означает, что файл является начальной точкой.

    %D

Номер устройства, на котором существует файл (поле st_dev из struct stat), в десятеричном виде.

    %f

Имя файла, из которого удалены все директории (оставлен только последний элемент).

    %F

Тип файловой системы, на которой размещён файл; это значение может использоваться для -fstype.

    %g

Имя группы файла, или числовой ID группы, если имя не имеет имени.

    %G

Числовой ID группы файла.

    %h

Имя файла, в котором сохранены директории, но убран последний элемент (без базового имени). Если имя файла не содержит слешей (поскольку он в текущей директории), спецификатор %h расширяется до «.».

    %H

Начальная точка под которой был найден файл.

    %i

Номер иноды файла (в десятеричном формате).

    %k

Количество дискового пространства, используемого для этого файла в 1K блоках. Поскольку дисковое пространство распределено в кратных размеру блоков файловой системы, оно обычно больше, чем %s/1024, но также может быть и меньше в разреженном файле.

    %l

Объект или символическая ссылка (пустая строка, если файл не является символической ссылкой).

    %m

Биты файловых разрешений (в восьмеричном формате). Эта опция использует «традиционные» числа, которые используют большинство реализаций Unix, но если ваша конкретная реализация использует необычный порядок восьмеричных битов разрешений, вы увидите разницу между действительным значением разрешений доступа к файлу и выводом %m. Обычно вам нужен начальный ноль на этом числе, чтобы сделать это используйте флаг # (к примеру «%#m»).

    %M

Файловые разрешения (в символической форме, как для ls). Эта директива поддерживается в findutils 4.2.5 и более поздних.

    %n

Число жёстких ссылок на файл.

    %p

Имя файла.

    %P

Имя файла с именем начальной точки под которой он был найден/удалён.

    %s

Размер файла в байтах.

    %S

Разреженность файла. Она вычисляется как (BLOCKSIZE * st_blocks / st_size). Точное значение, которое вы получите для обычного файла определённой длины зависит от системы. Тем не менее, обычно разреженные файлы будут иметь значения меньше чем 1.0, а файлы, которые используют неявные блоки могут иметь величину которая больше чем 1.0. Значение используемое для BLOCKSIZE зависит от системы, но обычно это 512 байт. Если размер файла равен нулю, то выводимое значение не определено. На системах, с отсутствием поддержки st_blocks, разреженность файла предполагается равной 1.0.

    %t

Время последней модификации файла в формате, который возвращает C функция «ctime».

    %Tk

Время последней модификации файла в формате определённом k, который является таким же как для %A.

    %u

Имя пользователя файла или числовой ID пользователя если у пользователя нет имени.

    %U

Числовой ID пользователя файла.

    %y

Тип файла (как в ls -l), U=неизвестный тип (такого не должно случаться)

    %Y

Тип файла (как %y), плюс последующие симлинки: L=петля, N=несуществующий

    %Z

(только SELinux) контекст безопасности файла.

    %{ %[ %(

Зарезервированы для будущего использования.

Символ «%» за которым следует любой другой символ отбрасывается, но другой символ печатается (не полагайтесь на это, поскольку может быть представлены последующие форматы символов). «%» на конце аргумента формата приводит к неопределённому поведению, поскольку отсутствует последующий символ.

Директивы %m и %d поддерживают флаги # , 0 и +, но другие директивы не поддерживают, даже если они печатают числа. Числовые директивы, которые не поддерживают эти флаги, включают G, U, b, D, k и n. Флаг формата «-» поддерживается и изменяет выравнивание поле с выравнивания по правому краю (по умолчанию) на выравнивание по левому краю.

Смотрите раздел Необычные имена файлов для информации об обработке необычных символов в именах файлов.

    -prune

True; если файл является директорией, не спускаться в него. Если дана -depth, false; отсутствие действия. Поскольку -delete применяет -depth, вы не можете использовать вместе -prune и -delete.

    -quit

Немедленный выход. Не дочерние процессы будут оставлены работающими, но больше не будет обработано путей, указанных в строке команды. Например,

    find /tmp/foo /tmp/bar -print -quit
напечатает только /tmp/foo.

Любые строки команд, которые были построены с -execdir … {} + будут вызваны перед выходом find. Статус выхода может быть или не быть нулевым, зависит от того, успели ли уже случиться ошибки.

Операторы find
Перечислены в порядке уменьшения приоритета:

    ( expr )

Принудительный приоритет. Поскольку круглые скобки являются специальными символами для оболочки, обычно вам нужно будет заключить их в кавычки. Многие примеры в этой странице манула используют для этих целей обратные слеши: «\(…\)» вместо «(…)».

    ! expr

True если expr равен false. Этот символ также обычно нуждается в защите от интерпретирования оболочкой.

    -not expr

То же самое, что и ! expr, но для совместимости с POSIX.

    expr1 expr2

Два выражения подряд – объединяются логическим И; expr2 не оценивается, если expr1 является false.

    expr1 -a expr2

То же самое, что и expr1 expr2.

    expr1 -and expr2

Как и expr1 expr2, но для совместимости с POSIX.

    expr1 -o expr2

Логическое ИЛИ; expr2 не оценивается, если expr1 является true.

    expr1 -or expr2

То же самое, что и expr1 -o expr2, но для совместимости с POSIX.

    expr1 , expr2

Список; оба expr1 и expr2 всегда оцениваются. Значение expr1 отбрасывается; значение списка – это значение expr2. Разделитель запятая может быть полезен для поиска по нескольким различным типам вещей, но для только одного обхода иерархии файловой системы. Может использоваться действие -fprintf для сохранения списков различных совпавших элементов в несколько различных файлов вывода.

Необычные имена файлов
Многие действия find приводят к тому, что выводятся данные, которые под контролем других пользователей. Сюда относятся имена файлов, размер, время модификации и т.п. Имена файлов является потенциальной проблемой, поскольку они могут содержать любые символы, кроме «\0» и «/». Необычные символы в именах файлов могут делать неожиданные и часто не желаемые вещи в вашем терминале (например, менять настройки ваших функциональных клавиш в некоторых терминалах). Необычные символы обрабатываются поразному различными действиями, как описано ние.

    -print0, -fprint0

Всегда печатать точное имя файла, неизменное, даже если вывод идёт в терминал.

    -ls, -fls

Необычные символы всегда экранируются. Белые пробелы, обратные слеши и символы двойных кавычек печатаются с использованием экранирования в стиле C (например, «\f», «\"»).

    -printf, -fprintf

Если вывод не идёт в терминал, он печатается как-есть. В противном случае, результат зависит от того, какая директива используется. %D, %F, %g, %G, %H, %Y и %y раскрываются в значения, которые не контролируются владельцами файлов и поэтому печатаются как-есть. Директивы %a, %b, %c, %d, %i, %k, %m, %M, %n, %s, %t, %u и %U имеют значения, которые под контролем владельца файлов, но которые не могут использоваться для отправки произвольных данных в терминал и поэтому печатаются как-есть. Директивы %f, %h, %l, %p и %P заключаются в кавычки. Добавление кавычек выполняется таким же образом, как для GNU ls. Это не тот же самый механизм добавления кавычек, какой используется для -ls и -fls. Если вы в состоянии решить, какой формат использовать для вывода find, то обычно лучше использовать «\0» как разделитель, чем использовать символ новой строки, поскольку имена файлов могут содержать белые пробелы и символы новой строки. Настройка переменной окружения «LC_CTYPE» используется для определения, какие символы необходимо взять в кавычки.

    -print, -fprint

Обёртывание в кавычки обрабатывается тем же способом, что и для -printf и -fprintf. Если вы используете find в скрипте или в ситуации, где совпавшие файлы могут иметь произвольные имена, вы должны рассмотреть использование -print0 вместо -print.

Действия -ok и -okdir печатают текущее имя файла как-есть. Это может измениться в будущих релизах.

Соответствие стандартам
Для максимального соблюдения стандартов POSIX, вам следует установить переменную окружения POSIXLY_CORRECT. Следующие опции указаны в стандарте POSIX (IEEE Std 1003.1, 2003 Edition):

    -H

Эта опция поддерживается.

    -L

Эта опция поддерживается.

    -name

Эта опция поддерживается, но соответствие POSIX зависит от соответствия POSIX функции системной библиотеки fnmatch(3). С findutils-4.2.2, метасимволы оболочки (например, «*», «?» или «[]») будут совпадать с начальной «.», поскольку этого требует IEEE PASC interpretation 126. Это изменение с предыдущей версии findutils.

    -type

Поддерживается. POSIX определяет «b», «c», «d», «l», «p», «f'» и «s». GNU find также поддерживает «D» Ответ интерпретируется в соответствии с шаблонами «yes» и «no», выбранными настройками переменной окружения «LC_MESSAGES». Когда установлена переменная окружения «POSIXLY_CORRECT», эти шаблоны беруться из системного определения положительного (yes – да) или отрицательного (no – нет) ответа. Смотрите системную документацию для nl_langinfo(3), в особенности YESEXPR и NOEXPR. Когда «POSIXLY_CORRECT» не установлена, шаблоны беруться из собственного каталога сообщений find.

    -newer

Поддерживается. Если указанный файл является символической ссылкой, то по нему всегда происходит переход. Это изменено с предыдущего поведения, которое брало соответствующее время из символической ссылки; смотрите ниже раздел История.

    -perm

Поддерживается. Если установлена переменная окружения «POSIXLY_CORRECT», некоторые аргументы режимов (например, +a+x), которые не являются верными в POSIX, поддерживаются для обратной совместимости.

Другие предикаты

Предикаты -atime, -ctime, -depth, -group, -links, -mtime, -nogroup, -nouser, -print,  -prune, -size,  -user  и  -xdev  все поддерживаются.

Стандарт POSIX определяет круглые скобки «(», «)», отрицание «!» и операторы И и ИЛИ (-a, -o).

Все другие опции, предикаты, выражения и т.д. являются расширениями за пределами стандарта POSIX. Тем не менее, многие из этих расширений не являются уникальными для GNU find.

Стандарт POSIX требует, чтобы find выявляла петли:

Утилита find определит бесконечные петли; т.е. ввод ранее посещённой директории, которая является прародителем последнего попавшегося файла. Когда она выявляет бесконечную петлю, find запишет диагностическое сообщение в стандартный вывод ошибок и либо восстановит свою позицию в иерархии каталогов или завершит работу.

GNU find соблюдает эти требования. Счётчик ссылок директорий, который содержит записи, которые является жёсткими ссылками к прародителю, будет часто ниже, чем он должен бы быть в другом случае. Это может означать, что GNU find иногда оптимизирует поддиректории, которые в действительности является ссылкой на предка. Поскольку find в действительности не заходит в эту поддиректорию, возможно избежать появления диагностического сообщения. Хотя это поведение может отчасти быть непонятным, вряд ли кто-либо в действительности зависит от этого поведения. Если leaf оптимизация была отключена с -noleaf, запись в директории всегда будет исследоваться и будут выводиться диагностическое сообщение где оно применимо. Символические ссылки как таковые не могут использоваться для создания циклов файловой системы, но если опция -L или опция -follow имеют силу, будет выводиться диагностическое сообщение, когда find сталкивается с петлёй символических ссылок. Как с петлёй, содержащей жёсткие ссылки, leaf оптимизация будет часто означать, что find известно, что ей не нужно вызывать stat() или chdir() на символических ссылках, поэтому такая диагностика часто не является необходимой.

Опция -d поддерживается для совместимости с различными системами BSD, но вы должны использовать вместо неё опцию совместимую с POSIX.

Переменная окружения POSIXLY_CORRECT не имеет влияния на поведение тестов -regex или -iregex поскольку эти тесты не указаны в стандарте POSIX.

Переменные окружения find

    LANG

Обеспечивает значение по умолчанию для интернациональных переменных, которые не установлены или null.

    LC_ALL

Если установлена не пустое значение строки, переопределяет значения всех других интернациональных переменных.

    LC_COLLATE

Стандарт POSIX определяет, что эта переменная влияет на шаблон соответствия для использования с опцией -name. GNU find использует библиотеку функции fnmatch(3), и поэтому поддержка «LC_COLLATE» зависит от системной библиотеки. Эта переменная также влияет на интерпретацию ответа для -ok; хотя переменная «LC_MESSAGES» выбирает шаблон, используемый для интерпретации ответа на -ok, интерпретация любых выражений в квадратных скобках в шаблоне будет подвержена «LC_COLLATE».

    LC_CTYPE

Эта переменная затрагивает обработку классов символов используемых в регулярных выражениях и также с тестом -name, если функция системной библиотеки fnmatch(3) поддерживает это. Эта переменная также затрагивает интерпретацию любых классов символов в регулярных выражениях, используемых для ответа на запросы, вызванные -ok. Переменная окружения «LC_CTYPE» также затронет, какие символы расцениваются как непечатные когда печатаются имена файлов; смотрите раздел Необычные имена файлов.

    LC_MESSAGES

Определяет используемую локаль для интернационализованных сообщений. Если установлена переменная окружения «POSIXLY_CORRECT», это также определяет интерпретацию ответов на запросы, делаемые действием -ok.

    NLSPATH

Определяет локаль интернационализованных сообщений каталогов.

    PATH

Затрагивает директории, по которым делается поиск исполнимых файлов, вызываемых -exec, -execdir, -ok и -okdir.

    POSIXLY_CORRECT

Определяет размер блока, используемого -ls и -fls. Если установлена POSIXLY_CORRECT, блок – это единица в 512 байт. В противном случае это являются единицами в 1024 байт.

Установка этой переменной также по умолчанию отключает сообщения предупреждений (т.е. применяет -nowarn), поскольку POSIX требует это отдельно от вывода для -ok, все напечатанные в stderr сообщения являются диагностическими и должны приводить к ненулевому статусу выхода.

Когда не установлена POSIXLY_CORRECT, -perm +zzz трактуется как -perm /zzz если +zzz не является валидным символьным режимом. Когда установлена POSIXLY_CORRECT, такие конструкции трактуются как ошибки.

Когда установлена POSIXLY_CORRECT, ответ на запрос, сделанный действием -ok, интерпретируются в соответствии с каталогом системных сообщений, в отличии от собственных сообщений перевода find.

    TZ

Затрагивает используемую временную зону для некоторых связанных с временем директив -printf и -fprintf.

### Примеры использования find
Ищет файлы по имени core в или ниже директории /tmp и удаляет их. Обратите внимание, что это будет работать неправильно, если имеются имена файлов, содержащие символы новой строки, одинарные или двойные кавычки, или пробелы:

    find /tmp -name core -type f -print | xargs /bin/rm -f
Ищет файлы по имени core в или ниже директории /tmp и удаляет их, работая с именами файлов так, что корректно обрабатываются имена файлов или директорий содержащих единичные или двойные кавычки, пробелы или символ новой строки. Тест -name ставится перед тестом -type, чтобы избежать необходимости вызывать stat(2) для каждого файла:

    find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
Запускает file на каждый файл в или ниже текущей директории. Обратите внимание, что фигурные скобки заключены в единичные кавычки для защиты их от интерпретации как скриптовой пунктуации оболочки. Точка с запятой похожим образом защищена использованием обратного слеша, хотя в этой ситуации также можно было бы использовать одинарные кавычки:

    find . -type f -exec file '{}' \;
Обойти файловую систему только один раз, вывести файлы и директории с setuid в /root/suid.txt и большие файлы в /root/big.txt. Данный запуск требует привилегий суперпользователя:

    sudo find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)
Поиск файлов в вашей домашней директории, которые были изменены за последние двадцать четыре часа. Эта команда работает так поскольку время с момента последней модификации каждого файла делится на 24 часа, а остаток отбрасывается. Это означает, чтобы соответствовать -mtime 0 файл должен быть изменён в прошлом, которое произошло менее 24 часов назад.

    find $HOME -mtime 0
Поиск файлов, которые являются выполнимыми, но не читаемыми:

    find /sbin /usr/sbin -executable \! -readable -print
Поиск файлов, которые имеют разрешения на чтение и запись для их владельца и группы, но которые другие пользователи могут читать, но не записывать в них. Файл, который соответствует этим критериям, но имеет другой набор битов разрешений (например, если кто-нибудь может выполнять файл) не будет соответствовать:

    find . -perm 664
Поиск файлов, которые имеют разрешения на чтение и запись их владельцем и группой, и которые другие пользователи могут читать, без учёта наличия любых других дополнительных битов разрешений (например, бита исполнимости). Этот пример будет соответствовать файлу, например, с режимом 0777.

    find . -perm -664
Поиск файлов, в которые кто-либо может записывать (их владелец, или их группа, или кто-нибудь другой):

    find . -perm /222
Все эти три команды делают то же самое, но первая использует восьмеричное представление прав доступа, а другие две используют символическую форму. Все эти команды ищут файлы, которые доступные для записи либо их владельцу, либо их группе. Эти файлы не обязаны быть доступны для записи одновременно для владельца и для группы, одного из вариантов достаточно:

    find . -perm /220
    find . -perm /u+w,g+w
    find . -perm /u=w,g=w
Обе эти команды делают то же самое; поиск файлов, которые доступны для записи и их владельцу, и их группе:

    find . -perm -220
    find . -perm -g+w,u+w
Обе эти две команды ищут файлы, которые доступны для чтения каждому (-perm -444 или -perm -a+r), имеют по крайней мере один установленный бит записи (-perm /222 или -perm /a+w), но ни для кого не являются исполнимым (соответственно, ! -perm /111 и ! -perm /a+x):

    find . -perm -444 -perm /222 ! -perm /111
    find . -perm -a+r -perm /a+w ! -perm /a+x
Эта команда копирует содержимое /source-dir в /dest-dir, но пропускает файлы и директории с именем .snapshot (и всё внутри них). Она также пропускает файлы или директории, чьё имя заканчивается на ~, но не их содержимое. Конструкция -prune -o \( … -print0 \) является весьма популярной. Идея здесь в том, что выражение перед -prune соответствует тому, что должно быть обрезано. Тем не менее, само действие -prune возвращает true, поэтому последующее -o гарантирует, что файлы с правой стороны оцениваются только для тех директорий, которые не были обрезаны (содержимое обрезанных директорий даже не посещается, поэтому их содержимое является неподходящим). Выражение на правой стороне от -o заключено в круглые скобки только для ясности. Оно выражает, что действие -print0 имеет место только для вещей, к которым не было применено -prune. Поскольку условие по умолчанию И между тестами связывает более крепко, чем -o, всё равно так было бы по умолчанию, но круглые скобки помогают яснее показать, что происходит:

    cd /source-dir
find . -name .snapshot -prune -o \( \! -name *~ -print0 \) | cpio -pmd0 /dest-dir
Дана следующая директория проектов и ассоциированных с ними административных директорий SCM, выполнить эффективный поиск корней проекта:

    repo/project1/CVS
    repo/gnu/project2/.svn
    repo/gnu/project3/.svn
    repo/gnu/project3/src/.svn
    repo/project4/.git
В этом примере -prune предотвращает ненужное спускание в директории, которые уже были изучены (например, мы не ищем по project3/src, поскольку мы уже нашли project3/.svn), но гарантирует быть найденным родственным директориям (project2 и project3):

    find repo/ -exec test -d {}/.svn \; -or -exec test -d {}/.git \; -or -exec test -d {}/CVS \; -print -prune
### Статус выхода find
find завершает работу со статусом 0 если все файлы успешно обработаны, выше чем 0 если случились ошибки. Это сознательно очень широкое описание, но если возвращаемой величиной является не-ноль, вам не следует полагаться на правильность результатов find.

Когда происходят некоторые ошибки, find останавливается немедленно, без завершения всех указанных действий. Например, некоторые начальные точки могут быть не проанализированы или некоторые ожидающие очередь вызовы для -exec … {} + или -execdir … {} + могут быть не выполнены.