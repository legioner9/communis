## sed what

    sed '
    s/regex1/sub/
    s/regex2/sub/
    s/regex2/sub/
    '

    sed -i 's/SEARCH_REGEX/REPLACEMENT/g' INPUTFILE
    sed -i 's%SEARCH_REGEX%REPLACEMENT%g' INPUTFILE
    $ sed -i 's|/bin/bash|/usr/bin/zsh|g' file.txt

Чтобы сделать сопоставление с шаблоном нечувствительным к регистру, используйте флаг I. В приведенном ниже примере мы используем флаги g и I:

    $ sed -i 's/foo/linux/gI' file.txt

Вы также можете использовать регулярные выражения. Например, чтобы найти все трехзначные числа и заменить их строкой number:

    $ sed -i 's/\b[0-9]\{3\}\b/number/g' file.txt

## [Поиск и замена строк в файлах с помощью sed](http://distrland.blogspot.com/2020/08/sed.html)

Довольно часто при работе с текстовыми файлами вам нужно находить и заменять строки текста в одном или нескольких файлах.

sed - это потоковый редактор. Он может выполнять основные операции с текстом над файлами и входными потоками, такими как конвейеры. С помощью sed вы можете искать, находить и заменять, вставлять и удалять слова и строки. Он поддерживает базовые и расширенные регулярные выражения, которые позволяют сопоставлять сложные шаблоны.

В этой статье мы поговорим о том, как находить и заменять строки с помощью sed. Мы также покажем вам, как выполнять рекурсивный поиск и замену. 

Поиск и замена с помощью sed

Существует несколько версий sed, с некоторыми функциональными отличиями между ними. macOS использует версию BSD, а большинство дистрибутивов Linux поставляются с предварительно установленной GNU sed по умолчанию. Мы будем использовать версию GNU.

Общая форма команды поиска и замены текста с использованием sed имеет следующий вид:

sed -i 's/SEARCH_REGEX/REPLACEMENT/g' INPUTFILE
-i - По умолчанию sed записывает свой вывод в стандартный вывод. Эта опция указывает sed редактировать файлы на месте. Если указано расширение (например, -i.bak), будет создана резервная копия исходного файла. 
s - Команда замены, вероятно, наиболее часто используемая команда в sed.
/ / / - Разделитель символов. Это может быть любой символ, но обычно используется символ косой черты (/).
SEARCH_REGEX - Обычная строка или регулярное выражение для поиска.
REPLACEMENT - Строка замены.
g - Флаг глобальной замены. По умолчанию sed читает файл построчно и изменяет только первое вхождение SEARCH_REGEX в строке. Если указан флаг замены, будут заменены все вхождения.
INPUTFILE - Имя файла, для которого вы хотите выполнить команду.

Рекомендуется заключать аргументы в кавычки, чтобы метасимволы оболочки не расширялись.

Давайте рассмотрим примеры использования команды sed для поиска и замены текста в файлах с некоторыми из его наиболее часто используемых опций и флагов.

В демонстрационных целях мы будем использовать следующий файл:

file.txt
123 Foo foo foo 
foo /bin/bash Ubuntu foobar 456

Если вы опустите флаг g, будет заменен только первый экземпляр строки поиска в каждой строке:

$ sed -i 's/foo/linux/' file.txt

С помощью флага глобальной замены sed заменяет все вхождения шаблона поиска:

$ sed -i 's/foo/linux/' file.txt

Output
123 Foo linux foo linux 
/bin/bash Ubuntu foobar 456

Как вы могли заметить, в предыдущем примере подстрока foo внутри строки foobar также заменяется. Если такое поведение вас не устраивает, используйте выражение «boundery» (\b) на обоих концах строки поиска. Это гарантирует, что отдельные слова не совпадут.

$ sed -i 's/\bfoo\b/linux/g' file.txt

Output
123 Foo linux linux
linux /bin/bash Ubuntu foobar 456

Чтобы сделать сопоставление с шаблоном нечувствительным к регистру, используйте флаг I. В приведенном ниже примере мы используем флаги g и I:

$ sed -i 's/foo/linux/gI' file.txt

Output
123 linux linux linux
linux /bin/bash Ubuntu linuxbar 456

Если вы хотите найти и заменить строку, содержащую символ разделителя (/), вам нужно использовать обратную косую черту (\), чтобы экранировать ее. Например, чтобы заменить /bin/bash на /usr/bin/zsh, вы бы использовали следующую команду:

$ sed -i 's/\/bin\/bash/\/usr\/bin\/zsh/g' file.txt

Более простой и читаемый вариант - использовать другой символ-разделитель. Большинство людей используют вертикальную черту (|) или двоеточие (:), но вы можете использовать любой другой символ:

$ sed -i 's|/bin/bash|/usr/bin/zsh|g' file.txt

Output
123 Foo foo foo
foo /usr/bin/zsh Ubuntu foobar 456

Вы также можете использовать регулярные выражения. Например, чтобы найти все трехзначные числа и заменить их строкой number:

$ sed -i 's/\b[0-9]\{3\}\b/number/g' file.txt

Output
number Foo foo foo
foo /bin/bash demo foobar number

Еще одна полезная особенность sed -  вы можете использовать символ амперсанда &, который соответствует подходящему шаблону. Символ может быть использован несколько раз.

Например, если вы хотите добавить фигурные скобки {} вокруг каждого трехзначного числа, введите:

$ sed -i 's/\b[0-9]\{3\}\b/{&}/g' file.txtCopy

Output
{123} Foo foo foo
foo /bin/bash demo foobar {456}

И последнее, но не менее важное: всегда полезно сделать резервную копию при редактировании файла с помощью sed. Для этого просто добавтьте расширение к опции -i. Например, чтобы отредактировать файл file.txt и сохранить исходный файл как file.txt.bak, вы должны ввести:

$ sed -i.bak 's/foo/linux/g' file.txt

Если вы хотите убедиться, что резервная копия создана, выведите список файлов с помощью команды ls:

$ ls

Output
file.txt 
file.txt.bak

Рекурсивный поиск и замена

Иногда вам нужно рекурсивно искать в каталогах файлы, содержащие заданную строку, и заменять эту строку во всех файлах. Это можно сделать с помощью таких команд, как find или grep, для рекурсивного поиска файлов в каталоге и передачи имен файлов в sed.

Следующая команда будет рекурсивно искать файлы в текущем рабочем каталоге и передавать имена файлов в sed.

$ find . -type f -exec sed -i 's/foo/bar/g' {} +Copy

Чтобы избежать проблем с файлами, содержащими пробел в их именах, используйте опцию -print0, которая указывает find печатать имя файла, с символом null после него, и направлять вывод в sed с помощью xargs -0:

$ find . -type f -print0 | xargs -0 sed -i 's/foo/bar/g'

Чтобы исключить каталог, используйте опцию -not -path. Например, если вы заменяете строку в локальном репозитории git, чтобы исключить все файлы, начинающиеся с точки (.), выполните:

$ find . -type f -not -path '*/\.*' -print0 | xargs -0 sed -i 's/foo/bar/g'

Если вы хотите искать и заменять текст только в файлах с определенным расширением, вы должны ввести:

$ find . -type f -name "*.md" -print0 | xargs -0 sed -i 's/foo/bar/g'

Другой вариант - использовать команду grep для рекурсивного поиска всех файлов, содержащих заданный шаблон, а затем передать имена файлов в sed:

$ grep -rlZ 'foo' . | xargs -0 sed -i.bak 's/foo/bar/g'
