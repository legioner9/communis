{Специальные переменные BASH
Переменная 	Значение
$0 	Имя скрипта
$1 	Позиционный параметр #1
$2-$9 	Позиционный параметр #2-#9
${10} 	Позиционный параметр #10
$# 	Кол-во позиционный параметров
«$*» 	Все параметры (как одно слово) *
«$@» 	Все параметры (как несколько слов)
${#var} 	Кол-во слов в переменной var
${#*} 	Число параметров, переданных скрипту
${#@} 	Число параметров, переданных скрипту
$? 	Код, возвращенный работой предыдущей команды
$$ 	Process ID (PID) скрипта
$- 	Флаги, переданные скрипту (using set)
$_ 	Последний аргумент предыдущей команды?
$! 	Process ID (PID) предыдущей команды, запущенной в фоновом режиме
$FUNCNAME 	имя текущей функции
$LINENO 	Номер строки исполняемого сценария.
$OLDPWD 	прежний рабочий каталог («OLD-Print-Working-Directory»)
$PIPESTATUS 	Код возврата канала (конвейера).
	Переменная $PIPESTATUS может давать неверные значения при вызове из командной строки.
	bash$who|grepnobody|sort bash$echo${PIPESTATUS[*]}
$PPID 	Переменная $PPID хранит PID (идентификатор) родительского процесса.
$PWD 	рабочий (текущий) каталог
* Должны быть в кавычках, иначе эквивалентно «$@».
}

{Бинарное сравнение
Оператор 	Значение (Возвращает true=0, если)
-eq 	Равно
-ne 	Не равно
-lt 	Менше ( < )
-le 	Меньше или равно ( <= )
-gt 	Больше ( > )
-ge 	Больше или равно ( >= )
> 	Больше ( > )
>= 	Больше или равно ( >= )
< 	Менше ( < )
<= 	Меньше или равно ( <= )
= 	равны
== 	равны
!= 	Не равны
\< 	Меньше (ASCII) *
\> 	Больше (ASCII) *
-z 	Пустая строка
-n 	Строковая переменная не пуста
* Если без двойных кавычек, тогда экранирующий символ \ нужен
}

{Работа с файлами
Оператор 	Значение (Возвращает true=0 если)
-e 	Файл существует
-s 	Файл не пустой
-f 	Файл - обычный файл
-d 	Файл - директория
-b 	Файл - блоковое устройство
-c 	Файл - символьное устройство
-h 	Файл - символическая ссылка
-L 	Файл - символическая ссылка
-r 	Файл доступен на чтение
-w 	Файл доступен на запись
-x 	Файл разрешен на выполнение
-g 	Файл имеет sgid флаг
-u 	Файл имеет suid флаг
-k 	«sticky bit» установлен
-G 	gid файла совпадает с вашим
-O 	uid файла совпадает с вашим
}

{Работа со строками
Выражение 	Значение
Извлечение подстроки: 	 
${string:position} 	с position до конца
${string:position:length} 	с position длиной length символов
${string:-length} 	последние length символов
Удаление части строки: 	 
${string#substring} 	до первого с начала
${string##substring} 	до последнего с начала
${string%substring} 	до первого с конца
${string%%substring} 	до последнего с конца
Замена подстроки: 	 
${string/substring/replacement} 	первое вхождение
${string//substring/replacement} 	все вхождения
${var/#Pattern/Replacement} 	Если в переменной var найдено совпадение с Pattern, причем совпадающая подстрока расположена в начале строки (префикс), то оно заменяется на Replacement. Поиск ведется с начала строки
${var/%Pattern/Replacement} 	Если в переменной var найдено совпадение с Pattern, причем совпадающая подстрока расположена в конце строки (суффикс), то оно заменяется на Replacement. Поиск ведется с конца строки
  	 
{#string} 	Длина строки
}

{Интерактивные комбинации и команды оболочки bash
Комбинация 	Значение
{CTRL-команды:
Ctrl+a 	переход к началу строки
Ctrl+b 	аналог стрелки влево (ну, если не работает)
Ctrl+c 	отменить редактирование команды или прекратить работу (если запущена)
Ctrl+d 	аналог Delete. Если строка пустая - выход из shell
Ctrl+e 	переход к концу строки
Ctrl+f 	аналог стрелки вправо
Ctrl+g 	выход из режима дополнения
Ctrl+h 	аналог BackSpace
Ctrl+i 	аналог Tab
Ctrl+k 	удалить всё до конца строки
Ctrl+l 	Очистить экран (набранная строка и даже позиция курсора остаётся)
Ctrl+r 	(ну, это все знают) - поиск по истории набранных команд
Ctrl+R 	поиск по истории набранных команд назад (это когда есть несколько вариантов и проскочили нужный)
Ctrl+t 	поменять местами текущий символ с предыдущим
Ctrl+u 	удалить всё до начала строки
Ctrl+v 	преобразует следующую клавишу в её символьное отображение (Enter - ^M, Esc - ^[ и т.д.)
Ctrl+w 	удалить от курсора до начала слова
Ctrl+xдважды 	скачок между началом строки и текущей позицией курсора.
Ctrl+y 	вставить из буфера (все удаляемое по горячим клавишам удаляется не просто так, а в буфер)
Ctrl+x@ 	Показывает возможные варианты дополнения доменного имени (вот это мне воспроизвести не удалось).
Ctrl+z 	притормозить/остановить выполнение команды в фон
Ctrl+_ 	отмена последнего изменения
}
{ALT-команды:
Alt+< 	к первой команде в истории (вообще к самой первой в .bash_history)
Alt+> 	к последней команде в истории
Alt+? 	показать весь список вариантов дополнения (аналог 2Т - см. ниже)
Alt+* 	вставить все возможные варианты дополнения
Alt+/ 	попытатся дополнить имя файла (из имеющихся в текущем каталоге)
Alt+. 	вставить последний аргумент из предыдущей команды
Alt+b 	влево на слово
Alt+c 	сделать первую букву слова заглавной (и перейти к следующему слову)
Alt+d 	удалить от текущей позиции до конца слова
Alt+f 	вправо на слово
Alt+l 	сделать первую букву слова строчной (и перейти к следующему слову)
Alt+n 	искать по истории (но не сразу, а после полного ввода и нажатия Ентер)
Alt+p 	искать по истории назад
Alt+r 	очистить всю строку
Alt+t 	поменять слова местами
Alt+u 	сделать все буквы заглавными от текущей позиции до конца слова
Alt+BackSpace 	Удалить от текущей позиции до начала слова
}
{Esc-команды:
Esc+d 	удалить от курсора до конца слова
Esc+f 	вправо на слово
Esc+b 	влево на слово
Esc+t 	поменять местами слова
Esc. 	«експейп точка» - ввести последнее использованное слово
}
{Tab-команды:
2T 	обозначает дважды нажатый Tab
2T 	все доступные команды (это тоже все знают)
(string)2T 	все доступные команды начинающиеся на string
/2T 	все каталоги, включая скрытые. Для текущего надо набрать ./2Т
*2T 	каталоги, кроме скрытых
~2T 	все пользователи, присутствющие в /etc/passwd
~f2T 	все пользователи, присутствющие в /etc/passwd, начинающиеся на f
$2T 	все системные переменные
@2T 	все записи в /etc/hosts
=2T 	вывод наподобии ls или dir
}
{Другие команды и комбинации:
!! 	последняя использованная команда. Удобно, если команду выполнил, но забыл sudo.
	$mount/dev/sdb1/media/flash mount:onlyrootcandothat Делаем sudo!!
!abc 	выполнить последнюю команду в истории, начинающуюся на abc
!a:p 	напечатать последнюю команду в истории, начинающуюся на a
!n 	выполнить n-ную команду в истории
!$ 	посдедний аргумент последней команды
!^ 	первый аргумент последней команды (прямо “старший помощник младшего дворника” )
^abc^xyz 	заменить abc на xyz в последней команде и выполнить результат
Сtlr-xCtrl+e 	только что набранная команда откроется в редакторе установленном в переменной $EDITOR. Удобно для набора длинных команд
Alt+-Alt+u 	(Зажать «Alt», за ним нажать «-», отпустить кнопки, потом Зажать «Alt», за ним «u») Сделать слово слева от курсора большими буквами. Удобно при выводе значений переменных окружения.
Alt+-Alt-c 	Сделать слово слева от курсора с большой буквы.
Alt+-Alt-d 	Удалить слово влево до слеша.
	Только нужно помнить, что все эти сочетания клавиш должны добраться до шелла целыми, поэтому если их перехватит другое приложение (менеджер окон, например), то шеллу ничего не достанется.
}
}

{Специальные символы в командах
Комбинация 	Значение
- 	предыдущий рабочий каталог. Соответствует содержимому внутренней переменной $OLDPWD.
~+ 	текущий рабочий каталог. Соответствует содержимому внутренней переменной $PWD.
: 	символ заполнитель в операция с двумя операндами создать пустой файл :>file
\’; 	ввод одинарной кавычки в строку в одинарных кавычках: echo’str’\»ing’ str’ing
Специальное назначение некоторых экранированных символов используемых совместно с echo и sed
\n 	перевод строки (новая строка)
\r 	перевод каретки
\t 	табуляция
\v 	вертикальная табуляция
\b 	забой (backspace)
\a 	«звонок» (сигнал)
\0xx 	ASCII-символ с кодом 0xx в восьмеричном виде)
}

{Цвета echo
Цвет 	Комбинация
BOLD 	‘\e[1m’
UNDERLINE 	‘\e[4m’
BLINK 	‘\e[5m’
INVERSE 	‘\e[7m’
BREAK 	‘\e[m’
{Foreground colors:
BLACK 	‘\e[0;30m’
RED 	‘\e[0;31m’
GREEN 	‘\e[0;32m’
BROWN 	‘\e[0;33m’
BLUE 	‘\e[0;34m’
MAGENTA 	‘\e[0;35m’
CYAN 	‘\e[0;36m’
GRAY 	‘\e[0;37m’
DEF 	‘\e[0;39m’
DGRAY 	‘\e[1;30m’
LRED 	‘\e[1;31m’
LGREEN 	‘\e[1;32m’
YELLOW 	‘\e[1;33m’
LBLUE 	‘\e[1;34m’
LMAGENTA 	‘\e[1;35m’
LCYAN 	‘\e[1;36m’
WHITE 	‘\e[1;37m’
}
{Backgrounds colors:
BLACK 	‘\e[40m’
RED 	‘\e[41m’
GREEN 	‘\e[42m’
BROWN 	‘\e[43m’
BLUE 	‘\e[44m’
MAGENTA 	‘\e[45m’
CYAN 	‘\e[46m’
GRAY 	‘\e[47m’
DEF 	‘\e[49m’
}
}
Автор: Олег Макарихин

z=$2_port
export $z=$1
# последующее использование
echo "значение переменной с именем $z равно ${!z}"

{
	a="bbb"

	# eval $a="ccc"
	read $a <<< "ccc"

	# echo $bbb
	echo ${!a}

	cd "$idir"

	unset filename
}