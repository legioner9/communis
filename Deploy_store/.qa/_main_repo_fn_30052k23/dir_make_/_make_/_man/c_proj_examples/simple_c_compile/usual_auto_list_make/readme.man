## [1.3. Автоматическое построение списка объектных файлов](https://www.opennet.ru/docs/RUS/gnumake/#Tradition-style_makefile)
"Ручное" перечисление всех объектных файлов, входящих в программу - достаточно нудная работа, которая, к счастью, может быть автоматизирована. Разумеется "простой трюк" вроде:
    iEdit: *.o
        gcc $< -o $@
не сработает, так как будут учтены только существующие в данный момент объектные файлы. Я использую чуть более сложный способ, который основан на предположении, что все файлы с исходным текстом должны быть скомпилированы и скомпонованы в собираемую программу. Моя методика состоит из двух шагов:

Получить список всех файлов с исходным текстом программы (всех файлов с расширением ".cpp"). Для этого можно использовать функцию wildcard.
Преобразовать список исходных файлов в список объектных файлов (заменить расширение ".cpp" на расширение ".o"). Для этого можно воспользоваться функцией patsubst.
Следующий пример содержит модифицированную версию make-файла:
example_2-auto_obj /
main.cpp
main.h
Editor.cpp
Editor.h
TextLine.cpp
TextLine.h
Makefile
Файл Makefile теперь выглядит так:
    #
    #   example_2-auto_obj/Makefile
    #
    #   Пример автоматического построения списка объектных файлов
    #

    iEdit: $(patsubst %.cpp,%.o,$(wildcard *.cpp))
        gcc $^ -o $@ 

    %.o: %.cpp
        gcc -c $<

    main.o:     main.h Editor.h TextLine.h
    Editor.o:   Editor.h TextLine.h
    TextLine.o: TextLine.h 
Список объектных файлов программы строится автоматически. Сначала с помощью функции wildcard получается список всех файлов с расширением ".cpp", находящихся в директории проекта. Затем, с помощью функции patsubst, полученный таким образом список исходных файлов, преобразуется в список объектных файлов. Make-файл теперь стал более универсальным - с небольшими изменениями его можно использовать для сборки разных программ.