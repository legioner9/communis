## [1.2. "Традиционный" способ построения make-файлов](https://www.opennet.ru/docs/RUS/gnumake/#GNU_Make)
В первом примере make-файл построен "традиционным" способом. Все исходные файлы собираемой программы находятся в одном каталоге:

example_1-traditional /
main.cpp
main.h
Editor.cpp
Editor.h
TextLine.cpp
TextLine.h
Makefile
Предполагается, что для компиляции программы используется компилятор GCC, и объектные файлы имеют расширение ".o". Файл Makefile выглядит так:
    
    #
    #   example_1-traditional/Makefile
    #
    #   Пример "традиционного" строения make-файла 
    #

    iEdit: main.o Editor.o TextLine.o 
        gcc $^ -o $@

    .cpp.o:
        gcc -c $<

    main.o:     main.h Editor.h TextLine.h
    Editor.o:   Editor.h TextLine.h
    TextLine.o: TextLine.h 
Первое правило заставляет make перекомпоновывать программу при изменении любого из объектных файлов. Второе правило говорит о том, что объектные файлы зависят от соответствующих исходных файлов. Каждое изменение файла с исходным текстом будет вызывать его перекомпиляцию. Следующие несколько правил указывают, от каких заголовочных файлов зависит каждый из объектных файлов. Такой способ построения make-файла мне кажется неудобным потому что:
Требуется "явно" перечислять все объектные файлы, из которых компонуется программа
Требуется "явно" перечислять, от каких именно заголовочных файлов зависит тот или иной объектный файл
Исполняемый файл программы помещается в "текущую" директорию. Если мне нужно иметь несколько различных вариантов программы (например, отладочный и рабочий), то каждый раз при переходе от одного варианта к другому требуется полная перекомпиляция программы во избежание нежелательного "смешивания" разных версий объектных файлов.
Видно, что традиционный способ построения make-файлов далек от идеала. Единственно, чем этот способ может быть удобен - своей "совместимостью". По-видимому, с таким make-файлом будут нормально работать даже самые "древние" или "экзотические" версии make (например, nmake фирмы Microsoft). Если подобная "совместимость" не нужна, то можно сильно облегчить себе жизнь, воспользовавшись широкими возможностями утилиты GNU Make. Попробуем избавиться от недостатков "традиционного" подхода.